var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { loadFileConfig, mergeConfigs } from '../../config/configLoad.js';
import { repomixConfigCliSchema, } from '../../config/configSchema.js';
import { readFilePathsFromStdin } from '../../core/file/fileStdin.js';
import { RepomixError, rethrowValidationErrorIfZodError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { splitPatterns } from '../../shared/patternUtils.js';
import { initTaskRunner } from '../../shared/processConcurrency.js';
import { reportResults } from '../cliReport.js';
import { runMigrationAction } from './migrationAction.js';
export const runDefaultAction = (directories, cwd, cliOptions) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    logger.trace('Loaded CLI options:', cliOptions);
    // Run migration before loading config
    yield runMigrationAction(cwd);
    // Load the config file in main process
    const fileConfig = yield loadFileConfig(cwd, (_a = cliOptions.config) !== null && _a !== void 0 ? _a : null);
    logger.trace('Loaded file config:', fileConfig);
    // Parse the CLI options into a config
    const cliConfig = buildCliConfig(cliOptions);
    logger.trace('CLI config:', cliConfig);
    // Merge default, file, and CLI configs
    const config = mergeConfigs(cwd, fileConfig, cliConfig);
    logger.trace('Merged config:', config);
    // Handle stdin processing in main process (before worker creation)
    // This is necessary because child_process workers don't inherit stdin
    let stdinFilePaths;
    if (cliOptions.stdin) {
        // Validate directory arguments for stdin mode
        const firstDir = (_b = directories[0]) !== null && _b !== void 0 ? _b : '.';
        if (directories.length > 1 || firstDir !== '.') {
            throw new RepomixError('When using --stdin, do not specify directory arguments. File paths will be read from stdin.');
        }
        const stdinResult = yield readFilePathsFromStdin(cwd);
        stdinFilePaths = stdinResult.filePaths;
        logger.trace(`Read ${stdinFilePaths.length} file paths from stdin in main process`);
    }
    // Create worker task runner
    const taskRunner = initTaskRunner({
        numOfTasks: 1,
        workerPath: new URL('./workers/defaultActionWorker.js', import.meta.url).href,
        runtime: 'child_process',
    });
    try {
        // Wait for worker to be ready (Bun compatibility)
        yield waitForWorkerReady(taskRunner);
        // Create task for worker (now with pre-loaded config and stdin file paths)
        const task = {
            directories,
            cwd,
            config,
            cliOptions,
            stdinFilePaths,
        };
        // Run the task in worker (spinner is handled inside worker)
        const result = (yield taskRunner.run(task));
        // Report results in main process
        reportResults(cwd, result.packResult, result.config);
        return {
            packResult: result.packResult,
            config: result.config,
        };
    }
    finally {
        // Always cleanup worker pool
        yield taskRunner.cleanup();
    }
});
/**
 * Builds CLI configuration from command-line options.
 *
 * Note: Due to Commander.js behavior with --no-* flags:
 * - When --no-* flags are used (e.g., --no-file-summary), the options explicitly become false
 * - When no flag is specified, Commander defaults to true (e.g., options.fileSummary === true)
 * - For --no-* flags, we only apply the setting when it's explicitly false to respect config file values
 * - This allows the config file to maintain control unless explicitly overridden by CLI
 */
export const buildCliConfig = (options) => {
    var _a, _b, _c;
    const cliConfig = {};
    if (options.output) {
        cliConfig.output = { filePath: options.output };
    }
    if (options.include) {
        cliConfig.include = splitPatterns(options.include);
    }
    if (options.ignore) {
        cliConfig.ignore = { customPatterns: splitPatterns(options.ignore) };
    }
    // Only apply gitignore setting if explicitly set to false
    if (options.gitignore === false) {
        cliConfig.ignore = Object.assign(Object.assign({}, cliConfig.ignore), { useGitignore: options.gitignore });
    }
    // Only apply dotIgnore setting if explicitly set to false
    if (options.dotIgnore === false) {
        cliConfig.ignore = Object.assign(Object.assign({}, cliConfig.ignore), { useDotIgnore: options.dotIgnore });
    }
    // Only apply defaultPatterns setting if explicitly set to false
    if (options.defaultPatterns === false) {
        cliConfig.ignore = Object.assign(Object.assign({}, cliConfig.ignore), { useDefaultPatterns: options.defaultPatterns });
    }
    if (options.topFilesLen !== undefined) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { topFilesLength: options.topFilesLen });
    }
    if (options.outputShowLineNumbers !== undefined) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { showLineNumbers: options.outputShowLineNumbers });
    }
    if (options.copy) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { copyToClipboard: options.copy });
    }
    if (options.style) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { style: options.style.toLowerCase() });
    }
    if (options.parsableStyle !== undefined) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { parsableStyle: options.parsableStyle });
    }
    if (options.stdout) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { stdout: true });
    }
    // Only apply securityCheck setting if explicitly set to false
    if (options.securityCheck === false) {
        cliConfig.security = { enableSecurityCheck: options.securityCheck };
    }
    // Only apply fileSummary setting if explicitly set to false
    if (options.fileSummary === false) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { fileSummary: false });
    }
    // Only apply directoryStructure setting if explicitly set to false
    if (options.directoryStructure === false) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { directoryStructure: false });
    }
    // Only apply files setting if explicitly set to false
    if (options.files === false) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { files: false });
    }
    if (options.removeComments !== undefined) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { removeComments: options.removeComments });
    }
    if (options.removeEmptyLines !== undefined) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { removeEmptyLines: options.removeEmptyLines });
    }
    if (options.truncateBase64 !== undefined) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { truncateBase64: options.truncateBase64 });
    }
    if (options.headerText !== undefined) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { headerText: options.headerText });
    }
    if (options.compress !== undefined) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { compress: options.compress });
    }
    if (options.tokenCountEncoding) {
        cliConfig.tokenCount = { encoding: options.tokenCountEncoding };
    }
    if (options.instructionFilePath) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { instructionFilePath: options.instructionFilePath });
    }
    if (options.includeEmptyDirectories) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { includeEmptyDirectories: options.includeEmptyDirectories });
    }
    if (options.includeFullDirectoryStructure) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { includeFullDirectoryStructure: options.includeFullDirectoryStructure });
    }
    // Only apply gitSortByChanges setting if explicitly set to false
    if (options.gitSortByChanges === false) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { git: Object.assign(Object.assign({}, (_a = cliConfig.output) === null || _a === void 0 ? void 0 : _a.git), { sortByChanges: false }) });
    }
    if (options.includeDiffs) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { git: Object.assign(Object.assign({}, (_b = cliConfig.output) === null || _b === void 0 ? void 0 : _b.git), { includeDiffs: true }) });
    }
    // Configure git logs inclusion and count - consolidating related git log options
    if (options.includeLogs || options.includeLogsCount !== undefined) {
        const gitLogConfig = Object.assign(Object.assign(Object.assign({}, (_c = cliConfig.output) === null || _c === void 0 ? void 0 : _c.git), (options.includeLogs && { includeLogs: true })), (options.includeLogsCount !== undefined && { includeLogsCount: options.includeLogsCount }));
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { git: gitLogConfig });
    }
    if (options.tokenCountTree !== undefined) {
        cliConfig.output = Object.assign(Object.assign({}, cliConfig.output), { tokenCountTree: options.tokenCountTree });
    }
    try {
        return repomixConfigCliSchema.parse(cliConfig);
    }
    catch (error) {
        rethrowValidationErrorIfZodError(error, 'Invalid cli arguments');
        throw error;
    }
};
/**
 * Wait for worker to be ready by sending a ping request.
 * This is specifically needed for Bun compatibility due to ES module initialization timing issues.
 */
const waitForWorkerReady = (taskRunner) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const isBun = (_a = process.versions) === null || _a === void 0 ? void 0 : _a.bun;
    if (!isBun) {
        // No need to wait for Node.js
        return;
    }
    const maxRetries = 3;
    const retryDelay = 50; // ms
    let pingSuccessful = false;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            yield taskRunner.run({
                ping: true,
            });
            logger.debug(`Worker initialization ping successful on attempt ${attempt}`);
            pingSuccessful = true;
            break;
        }
        catch (error) {
            logger.debug(`Worker ping failed on attempt ${attempt}/${maxRetries}:`, error);
            if (attempt < maxRetries) {
                logger.debug(`Waiting ${retryDelay}ms before retry...`);
                yield new Promise((resolve) => setTimeout(resolve, retryDelay));
            }
        }
    }
    if (!pingSuccessful) {
        logger.debug('All Worker ping attempts failed, proceeding anyway...');
    }
});
//# sourceMappingURL=defaultAction.js.map