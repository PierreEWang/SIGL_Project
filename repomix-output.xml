This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
API_test/Auth/Change Password - Valid.bru
API_test/Auth/Change Password - Weak Password.bru
API_test/Auth/folder.bru
API_test/Auth/Login - Invalid Credentials.bru
API_test/Auth/Login - Valid Admin.bru
API_test/Auth/Login - Valid Credentials.bru
API_test/Auth/Logout - Valid.bru
API_test/Auth/Protected Route - Invalid Token.bru
API_test/Auth/Protected Route - No Token.bru
API_test/Auth/Token Refresh - Invalid Token.bru
API_test/Auth/Token Refresh - Valid.bru
API_test/Auth/User Registration - Complete Flow.bru
API_test/Booking/Annuler un entretien.bru
API_test/Booking/Confirmer un entretien.bru
API_test/Booking/Demander un entretien.bru
API_test/Booking/folder.bru
API_test/Booking/Obtenir mes entretiens.bru
API_test/bruno.json
API_test/collection.bru
API_test/environments/local.bru
API_test/SETUP.md
API_test/Status.bru
API_test/Test/folder.bru
API_test/Test/Test GET.bru
API_test/Test/Test POST.bru
API_test/Upload/folder.bru
API_test/User/Delete User - Invalid ID.bru
API_test/User/Delete User - Valid ID.bru
API_test/User/folder.bru
API_test/User/Get User Profile - Invalid ID.bru
API_test/User/Get User Profile - Not Found.bru
API_test/User/Get User Profile - Valid ID copy.bru
API_test/User/Get User Profile - Valid ID.bru
API_test/User/List All Users.bru
API_test/User/Register User - Admin].bru
API_test/User/Register User - Duplicate Email.bru
API_test/User/Register User - Invalid Email.bru
API_test/User/Register User - Invalid Role.bru
API_test/User/Register User - Invalid Username.bru
API_test/User/Register User - Missing Fields.bru
API_test/User/Register User - Valid copy.bru
API_test/User/Register User - Valid Role.bru
API_test/User/Register User - Valid.bru
API_test/User/Register User - Weak Password.bru
API_test/User/Update User - Invalid ID.bru
API_test/User/Update User - No Fields.bru
API_test/User/Update User - Valid.bru
database/database/candidatures.bson
database/database/candidatures.metadata.json
database/database/commentaires.bson
database/database/commentaires.metadata.json
database/database/competences.bson
database/database/competences.metadata.json
database/database/creneaux.bson
database/database/creneaux.metadata.json
database/database/documents.bson
database/database/documents.metadata.json
database/database/entreprises.bson
database/database/entreprises.metadata.json
database/database/entretiens.bson
database/database/entretiens.metadata.json
database/database/evaluations.bson
database/database/evaluations.metadata.json
database/database/journal_entries.bson
database/database/journal_entries.metadata.json
database/database/jurys.bson
database/database/jurys.metadata.json
database/database/notifications.bson
database/database/notifications.metadata.json
database/database/offres.bson
database/database/offres.metadata.json
database/database/prelude.json
database/database/promotions.bson
database/database/promotions.metadata.json
database/database/rapports.bson
database/database/rapports.metadata.json
database/database/soutenances.bson
database/database/soutenances.metadata.json
database/database/utilisateurs.bson
database/database/utilisateurs.metadata.json
package.json
README.md
sigl_backend/.env
sigl_backend/.gitignore
sigl_backend/app/app.js
sigl_backend/app/auth/auth.controller.js
sigl_backend/app/auth/auth.model.js
sigl_backend/app/auth/auth.repository.js
sigl_backend/app/auth/auth.routes.js
sigl_backend/app/auth/auth.service.js
sigl_backend/app/auth/mfa.service.js
sigl_backend/app/auth/mfaToken.model.js
sigl_backend/app/calendar/controller.js
sigl_backend/app/calendar/data.js
sigl_backend/app/calendar/routes.js
sigl_backend/app/common/models/user.model.js
sigl_backend/app/config/jwt.config.js
sigl_backend/app/creneau/creneau.model.js
sigl_backend/app/entretien/entretien.controller.js
sigl_backend/app/entretien/entretien.model.js
sigl_backend/app/entretien/entretien.repository.js
sigl_backend/app/entretien/entretien.routes.js
sigl_backend/app/entretien/entretien.service.js
sigl_backend/app/journal/controller.js
sigl_backend/app/journal/journalEntry.model.js
sigl_backend/app/journal/repository.js
sigl_backend/app/journal/routes.js
sigl_backend/app/journal/service.js
sigl_backend/app/middleware/authenticate.js
sigl_backend/app/middleware/authorize.js
sigl_backend/app/soutenance/jury.model.js
sigl_backend/app/soutenance/soutenance.controller.js
sigl_backend/app/soutenance/soutenance.model.js
sigl_backend/app/soutenance/soutenance.repository.js
sigl_backend/app/soutenance/soutenance.routes.js
sigl_backend/app/soutenance/soutenance.service.js
sigl_backend/app/test/controller.js
sigl_backend/app/test/routes.js
sigl_backend/app/user/controller.js
sigl_backend/app/user/repository.js
sigl_backend/app/user/routes.js
sigl_backend/app/user/service.js
sigl_backend/Dockerfile
sigl_backend/package.json
sigl_backend/README.md
sigl_frontend/.env
sigl_frontend/.gitignore
sigl_frontend/index.html
sigl_frontend/package.json
sigl_frontend/postcss.config.js
sigl_frontend/public/images/image_accueil (2).jpg
sigl_frontend/public/images/image_accueil (3).jpg
sigl_frontend/public/images/image_accueil (4).jpg
sigl_frontend/public/images/image_accueil.jpg
sigl_frontend/src/App.jsx
sigl_frontend/src/components/calendar/CalendarGrid.jsx
sigl_frontend/src/components/calendar/CalendarNavigation.jsx
sigl_frontend/src/components/calendar/EventCard.jsx
sigl_frontend/src/components/Header.jsx
sigl_frontend/src/components/LoginForm.jsx
sigl_frontend/src/components/TestConnection.jsx
sigl_frontend/src/components/ToggleSwitch.jsx
sigl_frontend/src/main.jsx
sigl_frontend/src/pages/calendar/CalendarPage.jsx
sigl_frontend/src/pages/calendar/EventDetailPage.jsx
sigl_frontend/src/pages/dashboard/StudentDashboard.jsx
sigl_frontend/src/pages/entretien/DemandeEntretienPage.jsx
sigl_frontend/src/pages/entretien/MesEntretiensPage.jsx
sigl_frontend/src/pages/HomePage.jsx
sigl_frontend/src/pages/journal/CreateJournalPage.jsx
sigl_frontend/src/pages/journal/JournalDetailPage.jsx
sigl_frontend/src/pages/profile/ProfilePage.jsx
sigl_frontend/src/pages/RegisterPage.jsx
sigl_frontend/src/pages/soutenance/GestionSoutenancesPage.jsx
sigl_frontend/src/pages/soutenance/MaSoutenancePage.jsx
sigl_frontend/src/pages/soutenance/PlanifierSoutenancePage.jsx
sigl_frontend/src/services/Api.js
sigl_frontend/src/services/authService.js
sigl_frontend/src/services/bookingService.js
sigl_frontend/src/services/calendarService.js
sigl_frontend/src/services/journalService.js
sigl_frontend/src/styles/index.css
sigl_frontend/tailwind.config.js
sigl_frontend/vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
/.idea/
</file>

<file path="API_test/Auth/Change Password - Valid.bru">
meta {
  name: Change Password - Valid
  type: http
  seq: 5
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/change-password
  body: json
  auth: bearer
}

auth:bearer {
  token: {{accessToken}}
}

body:json {
  {
    "currentPassword": "{{testPassword}}",
    "newPassword": "NewSecurePass123!"
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response has appropriate message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('Password changed successfully');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('password');
    expect(res.getBody()).to.not.have.property('tokens');
    expect(res.getBody()).to.not.have.property('data');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 200) {
    // Update password in environment for future tests
    bru.setEnvVar("testPassword", "NewSecurePass123!");
    // Clear tokens as they should be invalidated after password change
    bru.setEnvVar("accessToken", "");
    bru.setEnvVar("refreshToken", "");
  }
}
</file>

<file path="API_test/Auth/Change Password - Weak Password.bru">
meta {
  name: Change Password - Weak Password
  type: http
  seq: 7
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/change-password
  body: json
  auth: bearer
}

auth:bearer {
  token: {{accessToken}}
}

body:json {
  {
    "currentPassword": "{{testPassword}}",
    "newPassword": "weak"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has appropriate error", function() {
    expect(res.getBody()).to.have.property('error');
    expect(['WEAK_PASSWORD', 'WEAK_PASSWORD_COMPLEXITY']).to.include(res.getBody().error);
  });
  
  test("Response has descriptive message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('password');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('tokens');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/folder.bru">
meta {
  name: Auth
  seq: 4
}

auth {
  mode: inherit
}
</file>

<file path="API_test/Auth/Login - Invalid Credentials.bru">
meta {
  name: Login - Invalid Credentials
  type: http
  seq: 2
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/login
  body: json
  auth: none
}

body:json {
  {
    "email": "{{testUserEmail}}",
    "password": "wrongpassword"
  }
}

tests {
  test("Status code is 401", function() {
    expect(res.getStatus()).to.equal(401);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has error code", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal('INVALID_CREDENTIALS');
  });
  
  test("Response message is generic", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Invalid email or password');
  });
  
  test("No sensitive information leaked", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('tokens');
    expect(res.getBody()).to.not.have.property('user');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Login - Valid Admin.bru">
meta {
  name: Login - Valid Admin
  type: http
  seq: 11
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/login
  body: json
  auth: none
}

body:json {
  {
    "email": "admin@admin.fr",
    "password": "goodlife"
  }
}

script:post-response {
  if (res.getStatus() === 200) {
    const data = res.getBody().data;
    bru.setEnvVar("accessToken", data.tokens.accessToken);
    bru.setEnvVar("refreshToken", data.tokens.refreshToken);
    bru.setEnvVar("loggedInUserId", data.user.id);
    bru.setEnvVar("userRole", data.user.role);
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('data');
    expect(res.getBody().data).to.have.property('user');
    const user = res.getBody().data.user;
    expect(user).to.have.property('id');
    expect(user).to.have.property('nom');
    expect(user).to.have.property('email');
    expect(user).to.have.property('role');
    expect(user).to.not.have.property('password');
  });
  
  test("Response contains tokens", function() {
    expect(res.getBody().data).to.have.property('tokens');
    const tokens = res.getBody().data.tokens;
    expect(tokens).to.have.property('accessToken');
    expect(tokens).to.have.property('refreshToken');
    expect(tokens).to.have.property('tokenType');
    expect(tokens).to.have.property('expiresIn');
    expect(tokens.tokenType).to.equal('Bearer');
  });
  
  test("Tokens are valid JWT format", function() {
    const tokens = res.getBody().data.tokens;
    // JWT tokens should have 3 parts separated by dots
    expect(tokens.accessToken.split('.').length).to.equal(3);
    expect(tokens.refreshToken.split('.').length).to.equal(3);
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Login - Valid Credentials.bru">
meta {
  name: Login - Valid Credentials
  type: http
  seq: 1
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/login
  body: json
  auth: none
}

body:json {
  {
    "email": "{{testUserEmail}}",
    "password": "{{testPassword}}"
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('data');
    expect(res.getBody().data).to.have.property('user');
    const user = res.getBody().data.user;
    expect(user).to.have.property('id');
    expect(user).to.have.property('nom');
    expect(user).to.have.property('email');
    expect(user).to.have.property('role');
    expect(user).to.not.have.property('password');
  });
  
  test("Response contains tokens", function() {
    expect(res.getBody().data).to.have.property('tokens');
    const tokens = res.getBody().data.tokens;
    expect(tokens).to.have.property('accessToken');
    expect(tokens).to.have.property('refreshToken');
    expect(tokens).to.have.property('tokenType');
    expect(tokens).to.have.property('expiresIn');
    expect(tokens.tokenType).to.equal('Bearer');
  });
  
  test("Tokens are valid JWT format", function() {
    const tokens = res.getBody().data.tokens;
    // JWT tokens should have 3 parts separated by dots
    expect(tokens.accessToken.split('.').length).to.equal(3);
    expect(tokens.refreshToken.split('.').length).to.equal(3);
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 200) {
    const data = res.getBody().data;
    bru.setEnvVar("accessToken", data.tokens.accessToken);
    bru.setEnvVar("refreshToken", data.tokens.refreshToken);
    bru.setEnvVar("loggedInUserId", data.user.id);
    bru.setEnvVar("userRole", data.user.role);
  }
}
</file>

<file path="API_test/Auth/Logout - Valid.bru">
meta {
  name: Logout - Valid
  type: http
  seq: 4
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/logout
  body: none
  auth: bearer
}

auth:bearer {
  token: {{accessToken}}
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response has logout message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Logout successful');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('tokens');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 200) {
    // Clear tokens after successful logout
    bru.setEnvVar("accessToken", "");
    bru.setEnvVar("refreshToken", "");
  }
}
</file>

<file path="API_test/Auth/Protected Route - Invalid Token.bru">
meta {
  name: Protected Route - Invalid Token
  type: http
  seq: 9
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{loggedInUserId}}
  body: none
  auth: bearer
}

auth:bearer {
  token: invalid.jwt.token
}

tests {
  test("Status code is 401", function() {
    expect(res.getStatus()).to.equal(401);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has token error", function() {
    expect(res.getBody()).to.have.property('error');
    expect(['INVALID_TOKEN', 'TOKEN_VERIFICATION_FAILED']).to.include(res.getBody().error);
  });
  
  test("Response has appropriate message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('token');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('user');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Protected Route - No Token.bru">
meta {
  name: Protected Route - No Token
  type: http
  seq: 8
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{loggedInUserId}}
  body: none
  auth: none
}

tests {
  test("Status code is 401", function() {
    expect(res.getStatus()).to.equal(401);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has authentication error", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal('MISSING_TOKEN');
  });
  
  test("Response has appropriate message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('No token provided');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('user');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Token Refresh - Invalid Token.bru">
meta {
  name: Token Refresh - Invalid Token
  type: http
  seq: 6
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/refresh
  body: none
  auth: bearer
}

auth:bearer {
  token: invalid.jwt.token
}

tests {
  test("Status code is 401", function() {
    expect(res.getStatus()).to.equal(401);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has appropriate error", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal('INVALID_REFRESH_TOKEN');
  });
  
  test("Response has error message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('Invalid or expired refresh token');
  });
  
  test("No tokens in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('tokens');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Token Refresh - Valid.bru">
meta {
  name: Token Refresh - Valid
  type: http
  seq: 3
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/refresh
  body: none
  auth: bearer
}

auth:bearer {
  token: {{refreshToken}}
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response contains new tokens", function() {
    expect(res.getBody()).to.have.property('data');
    const data = res.getBody().data;
    expect(data).to.have.property('accessToken');
    expect(data).to.have.property('refreshToken');
    expect(data).to.have.property('tokenType');
    expect(data).to.have.property('expiresIn');
    expect(data.tokenType).to.equal('Bearer');
  });
  
  test("New access token is different from old one", function() {
    const newAccessToken = res.getBody().data.accessToken;
    const oldAccessToken = bru.getEnvVar("accessToken");
    expect(newAccessToken).to.not.equal(oldAccessToken);
  });
  
  test("Tokens are valid JWT format", function() {
    const data = res.getBody().data;
    expect(data.accessToken.split('.').length).to.equal(3);
    expect(data.refreshToken.split('.').length).to.equal(3);
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 200) {
    const data = res.getBody().data;
    bru.setEnvVar("accessToken", data.accessToken);
    bru.setEnvVar("refreshToken", data.refreshToken);
  }
}
</file>

<file path="API_test/Auth/User Registration - Complete Flow.bru">
meta {
  name: User Registration - Complete Flow
  type: http
  seq: 10
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "authtest",
    "email": "authtest@example.com",
    "password": "AuthTest123!",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('succès');
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('user');
    const user = res.getBody().user;
    expect(user).to.have.property('_id');
    expect(user).to.have.property('nom');
    expect(user).to.have.property('email');
    expect(user).to.have.property('role');
    expect(user).to.not.have.property('password');
  });
  
  test("User data is correct", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('authtest');
    expect(user.email).to.equal('authtest@example.com');
    expect(user.role).to.equal('APPRENTI');
  });
  
  test("Response contains auth record info", function() {
    expect(res.getBody()).to.have.property('auth');
    const auth = res.getBody().auth;
    expect(auth).to.have.property('userId');
    expect(auth).to.have.property('isActive');
    expect(auth.isActive).to.equal(true);
    expect(auth).to.not.have.property('passwordHash');
    expect(auth).to.not.have.property('refreshToken');
  });
  
  test("User and auth records are linked", function() {
    const user = res.getBody().user;
    const auth = res.getBody().auth;
    expect(auth.userId).to.equal(user._id);
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(3000);
  });
}

script:post-response {
  if (res.getStatus() === 201) {
    const user = res.getBody().user;
    bru.setEnvVar("authTestUserId", user._id);
    bru.setEnvVar("authTestEmail", user.email);
  }
}
</file>

<file path="API_test/Booking/Annuler un entretien.bru">
meta {
  name: Annuler un entretien
  type: http
  seq: 4
}

put {
  url: http://localhost:3000/api/entretiens/ID_ENTRETIEN/annuler
  body: none
  auth: inherit
}

headers {
  Authorization: Bearer TOKEN
}

settings {
  encodeUrl: false
}
</file>

<file path="API_test/Booking/Confirmer un entretien.bru">
meta {
  name: Confirmer un entretien
  type: http
  seq: 3
}

put {
  url: http://localhost:3000/api/entretiens/ID_ENTRETIEN/confirmer
  body: none
  auth: inherit
}

headers {
  Authorization: Bearer TOKEN
}

settings {
  encodeUrl: false
}
</file>

<file path="API_test/Booking/folder.bru">
meta {
  name: Booking
  seq: 6
}

auth {
  mode: inherit
}
</file>

<file path="API_test/Booking/Obtenir mes entretiens.bru">
meta {
  name: Obtenir mes entretiens
  type: http
  seq: 2
}

get {
  url: http://localhost:3000/api/entretiens/mes-entretiens
  body: none
  auth: inherit
}

headers {
  Authorization: Bearer TOKEN
}

settings {
  encodeUrl: false
}
</file>

<file path="API_test/bruno.json">
{
  "version": "1",
  "name": "SIGL",
  "type": "collection",
  "ignore": [
    "node_modules",
    ".git"
  ]
}
</file>

<file path="API_test/environments/local.bru">
vars {
  baseUrl: http://localhost:3000
  apiPath: /api
  testUserId:
  testUserEmail: test@example.com
  testUsername: testuser
  testPassword: password123
  adminUserId:
  flowTestUserId:
  validObjectId: 507f1f77bcf86cd799439011
  invalidObjectId: invalid_id
  accessToken:
  refreshToken:
  loggedInUserId:
  userRole:
  authTestUserId:
  authTestEmail: authtest@example.com
}
</file>

<file path="API_test/SETUP.md">
# Bruno Environment Setup

## Quick Setup Instructions

1. **Open Bruno and import this collection**

2. **Create Environment:**
   - Click the dropdown in top-right that says "No Environment"
   - Select "Configure" → "Create Environment"
   - Name it "Local" or "Development"

3. **Add these variables:**
   ```
   baseUrl = http://localhost:3000
   apiPath = /api
   testUserId = (leave empty - will be set automatically)
   testUserEmail = test@example.com
   testUsername = testuser
   testPassword = password123
   adminUserId = (leave empty - will be set automatically)
   flowTestUserId = (leave empty - will be set automatically)
   validObjectId = 507f1f77bcf86cd799439011
   invalidObjectId = invalid_id
   ```

4. **Select the environment** from the dropdown

5. **Start your backend server** on http://localhost:3000

6. **Run tests in this order:**
   - Register User - Valid (creates test user)
   - Other registration tests
   - Get User Profile tests
   - List All Users
   - Update User tests
   - Delete User tests

## Notes
- Tests automatically manage user IDs via environment variables
- Some tests depend on previous tests creating users
- All URLs resolve to: `{{baseUrl}}{{apiPath}}/users/...`
</file>

<file path="API_test/Status.bru">
meta {
  name: Status
  type: http
  seq: 5
}

get {
  url: http://localhost:3000/status
  body: none
  auth: inherit
}

settings {
  encodeUrl: true
  timeout: 0
}
</file>

<file path="API_test/Test/folder.bru">
meta {
  name: Test
  seq: 2
}

auth {
  mode: inherit
}
</file>

<file path="API_test/Test/Test GET.bru">
meta {
  name: Test GET
  type: http
  seq: 3
}

get {
  url: http://localhost:3000/api/test
  body: none
  auth: inherit
}

settings {
  encodeUrl: true
  timeout: 0
}
</file>

<file path="API_test/Test/Test POST.bru">
meta {
  name: Test POST
  type: http
  seq: 1
}

post {
  url: http://localhost:3000/api/test
  body: none
  auth: inherit
}

settings {
  encodeUrl: true
  timeout: 0
}
</file>

<file path="API_test/Upload/folder.bru">
meta {
  name: Upload
  seq: 2
}

auth {
  mode: inherit
}
</file>

<file path="API_test/User/Delete User - Invalid ID.bru">
meta {
  name: Delete User - Invalid ID
  type: http
  seq: 13
}

delete {
  url: {{baseUrl}}{{apiPath}}/users/{{invalidObjectId}}
  body: none
  auth: none
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid ID format", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Format d'ID utilisateur invalide");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Delete User - Valid ID.bru">
meta {
  name: Delete User - Valid ID
  type: http
  seq: 12
}

delete {
  url: {{baseUrl}}{{apiPath}}/users/{{testUserId}}
  body: none
  auth: none
}

script:pre-request {
  // Ensure we have a valid test user ID from registration
  if (!bru.getEnvVar("testUserId")) {
    throw new Error("testUserId not set. Run 'Register User - Valid' test first.");
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Compte utilisateur supprimé avec succès');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}

script:post-response {
  // Clear the testUserId since user is deleted
  if (res.getStatus() === 200) {
    bru.setEnvVar("testUserId", "");
  }
}
</file>

<file path="API_test/User/folder.bru">
meta {
  name: User
  seq: 1
}

auth {
  mode: inherit
}
</file>

<file path="API_test/User/Get User Profile - Invalid ID.bru">
meta {
  name: Get User Profile - Invalid ID
  type: http
  seq: 7
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{invalidObjectId}}
  body: none
  auth: none
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid ID format", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Format d'ID utilisateur invalide");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Get User Profile - Not Found.bru">
meta {
  name: Get User Profile - Not Found
  type: http
  seq: 8
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{validObjectId}}
  body: none
  auth: none
}

tests {
  test("Status code is 404", function() {
    expect(res.getStatus()).to.equal(404);
  });
  
  test("Response has error message for user not found", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Utilisateur non trouvé");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Get User Profile - Valid ID copy.bru">
meta {
  name: Get User Profile - Valid ID copy
  type: http
  seq: 20
}

get {
  url: {{baseUrl}}{{apiPath}}/users/3
  body: none
  auth: inherit
}
</file>

<file path="API_test/User/List All Users.bru">
meta {
  name: List All Users
  type: http
  seq: 9
}

get {
  url: {{baseUrl}}{{apiPath}}/users
  body: multipartForm
  auth: inherit
}

headers {
  : 
}

body:multipart-form {
  accessToken: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTFkODFkNjE4ZjQwMWY3YTUwYzcxMjEiLCJlbWFpbCI6InRlc3RAZXhhbXBsZS5jb20iLCJyb2xlIjoiQVBQUkVOVEkiLCJ0eXBlIjoiYWNjZXNzIiwiaWF0IjoxNzYzNjI1NzkwLCJleHAiOjE3NjM2MjY2OTAsImF1ZCI6Imxtcy11c2VycyIsImlzcyI6ImxlYXJuaW5nLW1hbmFnZW1lbnQtc3lzdGVtIn0.vGG6q-3M2o1-t1tkL2iMJnZH2xha40znLC6wMOcNEUc
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response contains users array", function() {
    expect(res.getBody()).to.have.property('users');
    expect(res.getBody().users).to.be.an('array');
  });
  
  test("Response contains count", function() {
    expect(res.getBody()).to.have.property('count');
    expect(res.getBody().count).to.be.a('number');
    expect(res.getBody().count).to.equal(res.getBody().users.length);
  });
  
  test("Users array contains at least one user", function() {
    expect(res.getBody().users.length).to.be.at.least(1);
  });
  
  test("Each user has required properties", function() {
    res.getBody().users.forEach(user => {
      expect(user).to.have.property('_id');
      expect(user).to.have.property('nom');
      expect(user).to.have.property('email');
      expect(user).to.have.property('role');
      expect(user).to.not.have.property('password');
    });
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/User/Register User - Admin].bru">
meta {
  name: Register User - Admin]
  type: http
  seq: 19
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "admin",
    "email": "admin@admin.fr",
    "password": "goodlife",
    "role": "ADMIN"
  }
}

script:post-response {
  if (res.getStatus() === 201) {
    bru.setEnvVar("testUserId", res.getBody().user._id);
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur enregistré avec succès');
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('user');
    expect(res.getBody().user).to.have.property('_id');
    expect(res.getBody().user).to.have.property('nom');
    expect(res.getBody().user).to.have.property('email');
    expect(res.getBody().user).to.have.property('role');
    expect(res.getBody().user).to.not.have.property('password');
  });
  
  test("User data is correct", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('testuser');
    expect(user.email).to.equal('test@example.com');
    expect(user.role).to.equal('APPRENTI');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/User/Register User - Duplicate Email.bru">
meta {
  name: Register User - Duplicate Email
  type: http
  seq: 5
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser5",
    "email": "{{testUserEmail}}",
    "password": "password123",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 409", function() {
    expect(res.getStatus()).to.equal(409);
  });
  
  test("Response has error message for duplicate email", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Email déjà enregistré");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Invalid Email.bru">
meta {
  name: Register User - Invalid Email
  type: http
  seq: 3
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser3",
    "email": "invalid-email",
    "password": "password123",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid email", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Format d'email invalide");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Invalid Role.bru">
meta {
  name: Register User - Invalid Role
  type: http
  seq: 15
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser_invalid",
    "email": "invalid_role@example.com",
    "password": "password123",
    "role": "InvalidRole"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid role", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.include("Le rôle doit être l'un des suivants");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Invalid Username.bru">
meta {
  name: Register User - Invalid Username
  type: http
  seq: 16
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "ab",
    "email": "short_username@example.com",
    "password": "password123",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid username", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.include("Le nom d'utilisateur doit contenir entre 3 et 20 caractères");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Missing Fields.bru">
meta {
  name: Register User - Missing Fields
  type: http
  seq: 2
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser2"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Le nom d'utilisateur, l'email et le mot de passe sont obligatoires");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Valid copy.bru">
meta {
  name: Register User - Valid copy
  type: http
  seq: 18
}

post {
  url: http://pierre.wang:3000/api/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "{{testUsername}}",
    "email": "{{testUserEmail}}",
    "password": "{{testPassword}}",
    "role": "APPRENTI"
  }
}

script:post-response {
  if (res.getStatus() === 201) {
    bru.setEnvVar("testUserId", res.getBody().user._id);
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur enregistré avec succès');
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('user');
    expect(res.getBody().user).to.have.property('_id');
    expect(res.getBody().user).to.have.property('nom');
    expect(res.getBody().user).to.have.property('email');
    expect(res.getBody().user).to.have.property('role');
    expect(res.getBody().user).to.not.have.property('password');
  });
  
  test("User data is correct", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('testuser');
    expect(user.email).to.equal('test@example.com');
    expect(user.role).to.equal('APPRENTI');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/User/Register User - Valid Role.bru">
meta {
  name: Register User - Valid Role
  type: http
  seq: 14
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "admin_user",
    "email": "admin@example.com",
    "password": "adminpass123",
    "role": "ADMIN"
  }
}

script:post-response {
  if (res.getStatus() === 201) {
    bru.setEnvVar("adminUserId", res.getBody().user._id);
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur enregistré avec succès');
  });
  
  test("User has correct role", function() {
    expect(res.getBody().user.role).to.equal('ADMIN');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/User/Register User - Valid.bru">
meta {
  name: Register User - Valid
  type: http
  seq: 1
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "{{testUsername}}",
    "email": "{{testUserEmail}}",
    "password": "{{testPassword}}",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur enregistré avec succès');
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('user');
    expect(res.getBody().user).to.have.property('_id');
    expect(res.getBody().user).to.have.property('nom');
    expect(res.getBody().user).to.have.property('email');
    expect(res.getBody().user).to.have.property('role');
    expect(res.getBody().user).to.not.have.property('password');
  });
  
  test("User data is correct", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('testuser');
    expect(user.email).to.equal('test@example.com');
    expect(user.role).to.equal('APPRENTI');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 201) {
    bru.setEnvVar("testUserId", res.getBody().user._id);
  }
}
</file>

<file path="API_test/User/Register User - Weak Password.bru">
meta {
  name: Register User - Weak Password
  type: http
  seq: 4
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser4",
    "email": "test4@example.com",
    "password": "123",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for weak password", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Le mot de passe doit contenir au moins 6 caractères");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Update User - Invalid ID.bru">
meta {
  name: Update User - Invalid ID
  type: http
  seq: 11
}

put {
  url: {{baseUrl}}{{apiPath}}/users/{{invalidObjectId}}
  body: json
  auth: none
}

body:json {
  {
    "username": "updateduser2",
    "email": "updated2@example.com"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid ID format", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Format d'ID utilisateur invalide");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Update User - No Fields.bru">
meta {
  name: Update User - No Fields
  type: http
  seq: 17
}

put {
  url: {{baseUrl}}{{apiPath}}/users/{{validObjectId}}
  body: json
  auth: none
}

body:json {
  {}
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for no fields", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Aucun champ valide fourni pour la mise à jour");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Update User - Valid.bru">
meta {
  name: Update User - Valid
  type: http
  seq: 10
}

put {
  url: {{baseUrl}}{{apiPath}}/users/{{testUserId}}
  body: json
  auth: none
}

body:json {
  {
    "username": "updateduser",
    "email": "updated@example.com",
    "role": "TP"
  }
}

script:pre-request {
  // Ensure we have a valid test user ID from registration
  if (!bru.getEnvVar("testUserId")) {
    throw new Error("testUserId not set. Run 'Register User - Valid' test first.");
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur mis à jour avec succès');
  });
  
  test("Response contains updated user data", function() {
    expect(res.getBody()).to.have.property('user');
    expect(res.getBody().user).to.have.property('_id');
    expect(res.getBody().user).to.have.property('nom');
    expect(res.getBody().user).to.have.property('email');
    expect(res.getBody().user).to.have.property('role');
    expect(res.getBody().user).to.not.have.property('password');
  });
  
  test("User data is updated correctly", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('updateduser');
    expect(user.email).to.equal('updated@example.com');
    expect(user.role).to.equal('TP');
  });
  
  test("User ID remains the same", function() {
    expect(res.getBody().user._id).to.equal(bru.getEnvVar("testUserId"));
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="database/database/candidatures.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["offre","apprenti","etat"],"properties":{"offre":{"bsonType":"objectId"},"apprenti":{"bsonType":"objectId"},"etat":{"enum":["DEPOSEE","ACCEPTEE","REFUSEE","RETIRÉE"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"offre":{"$numberInt":"1"},"apprenti":{"$numberInt":"1"}},"name":"offre_1_apprenti_1","unique":true}],"uuid":"0698f2c00fcf43ce8d11ed22775e09e9","collectionName":"candidatures","type":"collection"}
</file>

<file path="database/database/commentaires.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["auteur","cibleType","cibleId","texte"],"properties":{"auteur":{"bsonType":"objectId"},"cibleType":{"enum":["JournalEntry","Document"]},"cibleId":{"bsonType":"objectId"},"texte":{"bsonType":"string","minLength":{"$numberInt":"1"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"cibleType":{"$numberInt":"1"},"cibleId":{"$numberInt":"1"}},"name":"cibleType_1_cibleId_1"}],"uuid":"8d56546c5da74e75b1980b82abe7e56a","collectionName":"commentaires","type":"collection"}
</file>

<file path="database/database/competences.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["libelle"],"properties":{"libelle":{"bsonType":"string","minLength":{"$numberInt":"2"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"}],"uuid":"20817414ada143aa9f7799f0f0d34b33","collectionName":"competences","type":"collection"}
</file>

<file path="database/database/creneaux.metadata.json">
{"options":{"validator":{"$and":[{"$jsonSchema":{"bsonType":"object","required":["debut","fin"],"properties":{"debut":{"bsonType":"date"},"fin":{"bsonType":"date"}},"additionalProperties":false}},{"$expr":{"$gt":["$fin","$debut"]}}]},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"debut":{"$numberInt":"1"},"fin":{"$numberInt":"1"}},"name":"debut_1_fin_1"}],"uuid":"25e5ab221c9c408783f896d8ca8ac653","collectionName":"creneaux","type":"collection"}
</file>

<file path="database/database/documents.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["type","url","apprenti"],"properties":{"type":{"enum":["RAPPORT","COMPTE_RENDU","AUTRE"]},"url":{"bsonType":"string","minLength":{"$numberInt":"5"}},"apprenti":{"bsonType":"objectId"}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"apprenti":{"$numberInt":"1"},"_id":{"$numberInt":"-1"}},"name":"apprenti_1__id_-1"}],"uuid":"0fcd7f1ed848438298ee74e6f39f4d67","collectionName":"documents","type":"collection"}
</file>

<file path="database/database/entreprises.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["nom"],"properties":{"nom":{"bsonType":"string","minLength":{"$numberInt":"2"}},"adresse":{"bsonType":["string","null"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"nom":{"$numberInt":"1"}},"name":"nom_1","unique":true}],"uuid":"11d928b212c04ea58c514a60503278d8","collectionName":"entreprises","type":"collection"}
</file>

<file path="database/database/entretiens.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["objet","creneau","participants"],"properties":{"objet":{"bsonType":"string","minLength":{"$numberInt":"2"}},"creneau":{"bsonType":"objectId"},"participants":{"bsonType":"array","minItems":{"$numberInt":"2"},"items":{"bsonType":"objectId"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"creneau":{"$numberInt":"1"}},"name":"creneau_1"}],"uuid":"ccb602901f4849ec878cfeac2fa512ce","collectionName":"entretiens","type":"collection"}
</file>

<file path="database/database/evaluations.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["apprenti","evaluateur","note","type"],"properties":{"apprenti":{"bsonType":"objectId"},"evaluateur":{"bsonType":"objectId"},"note":{"bsonType":["double","int","decimal"],"minimum":{"$numberInt":"0"},"maximum":{"$numberInt":"20"}},"appreciation":{"bsonType":["string","null"]},"type":{"enum":["RAPPORT","SOUTENANCE","CONTINU"]},"soutenance":{"bsonType":["objectId","null"]},"rapport":{"bsonType":["objectId","null"]},"competence":{"bsonType":["objectId","null"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"apprenti":{"$numberInt":"1"},"type":{"$numberInt":"1"}},"name":"apprenti_1_type_1"}],"uuid":"e76aaf0c4a5e4e39873aa523e80837cb","collectionName":"evaluations","type":"collection"}
</file>

<file path="database/database/journal_entries.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["apprenti","date","contenu"],"properties":{"apprenti":{"bsonType":"objectId"},"date":{"bsonType":"date"},"contenu":{"bsonType":"string","minLength":{"$numberInt":"1"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"apprenti":{"$numberInt":"1"},"date":{"$numberInt":"-1"}},"name":"apprenti_1_date_-1"}],"uuid":"adc53a365fa748b58843dc087ab4075e","collectionName":"journal_entries","type":"collection"}
</file>

<file path="database/database/jurys.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["professeurs"],"properties":{"professeurs":{"bsonType":"array","minItems":{"$numberInt":"3"},"maxItems":{"$numberInt":"5"},"items":{"bsonType":"objectId"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"}],"uuid":"5768759c122e44c78b1c1ee9c9bb5ea1","collectionName":"jurys","type":"collection"}
</file>

<file path="database/database/notifications.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["destinataire","message","lu"],"properties":{"destinataire":{"bsonType":"objectId"},"message":{"bsonType":"string","minLength":{"$numberInt":"1"}},"lu":{"bsonType":"bool"},"objet":{"bsonType":["object","null"],"properties":{"type":{"bsonType":"string"},"id":{"bsonType":"objectId"}}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"destinataire":{"$numberInt":"1"},"lu":{"$numberInt":"1"}},"name":"destinataire_1_lu_1"}],"uuid":"27dcff414c9e4ceb87ede3e4ac0ab3e8","collectionName":"notifications","type":"collection"}
</file>

<file path="database/database/offres.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["entreprise","intitule","statut"],"properties":{"entreprise":{"bsonType":"objectId"},"intitule":{"bsonType":"string","minLength":{"$numberInt":"2"}},"statut":{"enum":["OUVERTE","CLOTUREE","EN_RECRUTEMENT"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"entreprise":{"$numberInt":"1"},"statut":{"$numberInt":"1"},"_id":{"$numberInt":"-1"}},"name":"entreprise_1_statut_1__id_-1"}],"uuid":"f1daf243c58e417f9a1ce9e53fb9923e","collectionName":"offres","type":"collection"}
</file>

<file path="database/database/prelude.json">
{"ServerVersion":"8.2.1","ToolVersion":"100.13.0"}
</file>

<file path="database/database/promotions.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["annee"],"properties":{"annee":{"bsonType":"string","pattern":"^[0-9]{4}-[0-9]{4}$"}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"annee":{"$numberInt":"1"}},"name":"annee_1"}],"uuid":"36f3b08cea1140a2aa7a85b3f720a611","collectionName":"promotions","type":"collection"}
</file>

<file path="database/database/rapports.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["apprenti","titre","fichier"],"properties":{"apprenti":{"bsonType":"objectId"},"titre":{"bsonType":"string","minLength":{"$numberInt":"2"}},"fichier":{"bsonType":"string","minLength":{"$numberInt":"5"}},"soutenance":{"bsonType":["objectId","null"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"}],"uuid":"4677402cd1064c1aaede253a44c50b85","collectionName":"rapports","type":"collection"}
</file>

<file path="database/database/soutenances.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["apprenti","jury","dateHeure","etat"],"properties":{"apprenti":{"bsonType":"objectId"},"jury":{"bsonType":"objectId"},"salle":{"bsonType":["string","null"]},"dateHeure":{"bsonType":"date"},"etat":{"enum":["PLANIFIEE","VALIDEE","TERMINEE","ANNULEE"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"apprenti":{"$numberInt":"1"}},"name":"apprenti_1","unique":true},{"v":{"$numberInt":"2"},"key":{"dateHeure":{"$numberInt":"1"}},"name":"dateHeure_1"}],"uuid":"8496d90313a64eb0bfe0fa7dc2289cc4","collectionName":"soutenances","type":"collection"}
</file>

<file path="package.json">
{
  "dependencies": {
    "repomix": "^1.9.1"
  }
}
</file>

<file path="sigl_backend/.gitignore">
/.idea/
/node_modules/
/repomix-output.xml
</file>

<file path="sigl_backend/app/auth/auth.service.js">
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const jwtConfig = require('../config/jwt.config');
const Auth = require('./auth.model');

/**
 * Authentication Service
 * Handles password hashing, JWT operations, and authentication business logic
 */
class AuthService {
    /**
     * Hash a plain text password using bcrypt
     * @param {string} password - Plain text password to hash
     * @returns {Promise<string>} Hashed password
     * @throws {Error} If password is invalid or hashing fails
     */
    async hashPassword(password) {
        try {
            // Validate password input
            if (!password || typeof password !== 'string') {
                throw new Error('Password must be a non-empty string');
            }

            if (password.length < 8) {
                throw new Error('Password must be at least 8 characters long');
            }

            const saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS) || 10;
            const hashedPassword = await bcrypt.hash(password, saltRounds);
            
            return hashedPassword;
        } catch (error) {
            console.error('Password hashing failed:', error.message);
            throw new Error('Failed to hash password');
        }
    }

    /**
     * Compare a plain text password with a hashed password
     * @param {string} plainPassword - Plain text password
     * @param {string} hashedPassword - Hashed password to compare against
     * @returns {Promise<boolean>} True if passwords match, false otherwise
     * @throws {Error} If comparison fails
     */
    async comparePassword(plainPassword, hashedPassword) {
        try {
            // Validate inputs
            if (!plainPassword || typeof plainPassword !== 'string') {
                throw new Error('Plain password must be a non-empty string');
            }

            if (!hashedPassword || typeof hashedPassword !== 'string') {
                throw new Error('Hashed password must be a non-empty string');
            }

            const isMatch = await bcrypt.compare(plainPassword, hashedPassword);
            return isMatch;
        } catch (error) {
            console.error('Password comparison failed:', error.message);
            throw new Error('Failed to compare passwords');
        }
    }

    /**
     * Generate an access token for a user
     * @param {string} userId - User's unique identifier
     * @param {string} email - User's email address
     * @param {string} role - User's role
     * @returns {string} JWT access token
     * @throws {Error} If token generation fails
     */
    generateAccessToken(userId, email, role) {
        try {
            // Validate required parameters
            if (!userId || !email || !role) {
                throw new Error('userId, email, and role are required for access token generation');
            }

            const payload = {
                userId,
                email: email.toLowerCase(),
                role,
                type: 'access'
            };

            const config = jwtConfig.getAccessTokenConfig();
            
            const token = jwt.sign(payload, config.secret, {
                expiresIn: config.expiresIn,
                issuer: config.issuer,
                audience: config.audience,
                algorithm: config.algorithm
            });

            return token;
        } catch (error) {
            console.error('Access token generation failed:', error.message);
            throw new Error('Failed to generate access token');
        }
    }

    /**
     * Generate a refresh token for a user
     * @param {string} userId - User's unique identifier
     * @returns {string} JWT refresh token
     * @throws {Error} If token generation fails
     */
    generateRefreshToken(userId) {
        try {
            // Validate required parameter
            if (!userId) {
                throw new Error('userId is required for refresh token generation');
            }

            const payload = {
                userId,
                type: 'refresh'
            };

            const config = jwtConfig.getRefreshTokenConfig();
            
            const token = jwt.sign(payload, config.secret, {
                expiresIn: config.expiresIn,
                issuer: config.issuer,
                audience: config.audience,
                algorithm: config.algorithm
            });

            return token;
        } catch (error) {
            console.error('Refresh token generation failed:', error.message);
            throw new Error('Failed to generate refresh token');
        }
    }

    /**
     * Verify and decode a JWT token
     * @param {string} token - JWT token to verify
     * @param {string} tokenType - Type of token ('access' or 'refresh')
     * @returns {Object} Decoded token payload
     * @throws {Error} If token is invalid or verification fails
     */
    verifyToken(token, tokenType = 'access') {
        try {
            // Validate inputs
            if (!token || typeof token !== 'string') {
                throw new Error('Token must be a non-empty string');
            }

            if (!['access', 'refresh'].includes(tokenType)) {
                throw new Error('Token type must be either "access" or "refresh"');
            }

            const secret = tokenType === 'access' 
                ? jwtConfig.JWT_SECRET 
                : jwtConfig.JWT_REFRESH_SECRET;

            const verifyOptions = jwtConfig.getVerifyOptions();
            
            const decoded = jwt.verify(token, secret, verifyOptions);

            // Verify token type matches expected type
            if (decoded.type !== tokenType) {
                throw new Error(`Invalid token type. Expected ${tokenType}, got ${decoded.type}`);
            }

            return decoded;
        } catch (error) {
            if (error.name === 'TokenExpiredError') {
                throw new Error('Token has expired');
            } else if (error.name === 'JsonWebTokenError') {
                throw new Error('Invalid token');
            } else if (error.name === 'NotBeforeError') {
                throw new Error('Token not active yet');
            } else {
                console.error('Token verification failed:', error.message);
                throw new Error('Token verification failed');
            }
        }
    }

    /**
     * Store a refresh token for a user
     * @param {string} userId - User's unique identifier
     * @param {string} refreshToken - Refresh token to store
     * @returns {Promise<Object>} Updated auth record
     * @throws {Error} If storage fails
     */
    async storeRefreshToken(userId, refreshToken) {
        try {
            // Validate inputs
            if (!userId) {
                throw new Error('userId is required');
            }

            if (!refreshToken || typeof refreshToken !== 'string') {
                throw new Error('refreshToken must be a non-empty string');
            }

            // Verify the refresh token is valid before storing
            this.verifyToken(refreshToken, 'refresh');

            const authRecord = await Auth.findOneAndUpdate(
                { userId, isActive: true },
                { 
                    refreshToken,
                    $unset: { accountLockedUntil: 1 } // Clear any account lock
                },
                { new: true }
            );

            if (!authRecord) {
                throw new Error('Auth record not found for user');
            }

            return authRecord.toSafeObject();
        } catch (error) {
            console.error('Refresh token storage failed:', error.message);
            throw new Error('Failed to store refresh token');
        }
    }

    /**
     * Revoke a refresh token for a user
     * @param {string} userId - User's unique identifier
     * @returns {Promise<Object>} Updated auth record
     * @throws {Error} If revocation fails
     */
    async revokeRefreshToken(userId) {
        try {
            // Validate input
            if (!userId) {
                throw new Error('userId is required');
            }

            const authRecord = await Auth.findOneAndUpdate(
                { userId, isActive: true },
                { 
                    $unset: { refreshToken: 1 } // Remove refresh token
                },
                { new: true }
            );

            if (!authRecord) {
                throw new Error('Auth record not found for user');
            }

            return authRecord.toSafeObject();
        } catch (error) {
            console.error('Refresh token revocation failed:', error.message);
            throw new Error('Failed to revoke refresh token');
        }
    }

    /**
     * Generate both access and refresh tokens for a user
     * @param {string} userId - User's unique identifier
     * @param {string} email - User's email address
     * @param {string} role - User's role
     * @returns {Object} Object containing both tokens
     * @throws {Error} If token generation fails
     */
    generateTokenPair(userId, email, role) {
        try {
            const accessToken = this.generateAccessToken(userId, email, role);
            const refreshToken = this.generateRefreshToken(userId);

            return {
                accessToken,
                refreshToken,
                tokenType: 'Bearer',
                expiresIn: jwtConfig.ACCESS_TOKEN_EXPIRY
            };
        } catch (error) {
            console.error('Token pair generation failed:', error.message);
            throw new Error('Failed to generate token pair');
        }
    }

    /**
     * Validate token format and extract bearer token
     * @param {string} authHeader - Authorization header value
     * @returns {string} Extracted token
     * @throws {Error} If header format is invalid
     */
    extractBearerToken(authHeader) {
        if (!authHeader) {
            throw new Error('Authorization header is required');
        }

        const parts = authHeader.split(' ');
        
        if (parts.length !== 2 || parts[0] !== 'Bearer') {
            throw new Error('Invalid authorization header format. Expected: Bearer <token>');
        }

        return parts[1];
    }

    /**
     * Check if a token is expired without throwing an error
     * @param {string} token - JWT token to check
     * @param {string} tokenType - Type of token ('access' or 'refresh')
     * @returns {boolean} True if token is expired, false otherwise
     */
    isTokenExpired(token, tokenType = 'access') {
        try {
            this.verifyToken(token, tokenType);
            return false;
        } catch (error) {
            return error.message === 'Token has expired';
        }
    }
}

// Export singleton instance
module.exports = new AuthService();
</file>

<file path="sigl_backend/app/auth/mfa.service.js">
// sigl_backend/app/auth/mfa.service.js
const MfaToken = require("./mfaToken.model");
const nodemailer = require("nodemailer");

function generateCode() {
  // Code à 6 chiffres
  return String(Math.floor(100000 + Math.random() * 900000));
}

function isSmtpConfigured() {
  return (
    process.env.SMTP_HOST &&
    process.env.SMTP_USER &&
    process.env.SMTP_PASS
  );
}

async function sendEmailCode(user, code) {
  // --- MODE DEV : SMTP non configuré -> on log seulement ---
  if (!isSmtpConfigured()) {
    console.warn(
      "[MFA EMAIL] SMTP non configuré (.env). Code simulé pour %s : %s",
      user.email,
      code
    );
    return;
  }

  const transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: Number(process.env.SMTP_PORT || 587),
    secure: false,
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASS,
    },
  });

  try {
    await transporter.sendMail({
      from: process.env.SMTP_FROM || '"IZIA" <no-reply@izia.local>',
      to: user.email,
      subject: "Votre code de connexion IZIA",
      text: `Votre code de connexion est : ${code}`,
    });

    console.log(
      "[MFA EMAIL] Code envoyé à %s (méthode email)",
      user.email
    );
  } catch (err) {
    // On ne veut PAS empêcher la connexion MFA en dev si le SMTP bug
    console.error(
      "[MFA EMAIL] Erreur lors de l'envoi du mail, fallback console :",
      err
    );
    console.log(
      "[MFA EMAIL] Code pour %s (non envoyé par mail) : %s",
      user.email,
      code
    );
  }
}

async function sendSmsCode(user, code) {
  // Pour l’instant on simule le SMS
  console.log(
    `[MFA SMS] Code pour ${user.telephone || "numéro inconnu"} : ${code}`
  );
  // Si tu ajoutes Twilio / OVH plus tard, ce sera ici.
}

/**
 * Crée un code MFA, le stocke, et l'envoie via email ou SMS.
 * @param {Object} user - document Utilisateur mongoose
 * @returns {"email" | "sms"} méthode utilisée
 */
async function createAndSendMfaCode(user) {
  const code = generateCode();
  const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

  // On supprime les anciens codes non consommés pour cet utilisateur
  await MfaToken.deleteMany({
    user: user._id,
    consumedAt: null,
  });

  // On crée le nouveau token
  await MfaToken.create({
    user: user._id,
    code: String(code).trim(),
    expiresAt,
  });

  // Choix du canal
  if (user.mfaMethod === "sms" && user.telephone) {
    await sendSmsCode(user, code);
    return "sms";
  } else {
    await sendEmailCode(user, code);
    return "email";
  }
}

/**
 * Vérifie un code MFA.
 * IMPORTANT : on s'appuie UNIQUEMENT sur le code pour retrouver le token,
 * puis on récupère le userId depuis ce token.
 *
 * @param {string} rawCode - code saisi par l'utilisateur
 * @returns {Promise<MfaToken|null>} token MFA consommé ou null
 */
async function verifyMfaCode(rawCode) {
  const normalizedCode = String(rawCode || "").trim();

  if (!normalizedCode) {
    return null;
  }

  // On récupère le dernier token non consommé avec ce code
  const token = await MfaToken.findOne({
    code: normalizedCode,
    consumedAt: null,
    expiresAt: { $gt: new Date() },
  }).sort({ createdAt: -1 });

  if (!token) {
    return null;
  }

  token.consumedAt = new Date();
  await token.save();

  return token;
}

module.exports = {
  createAndSendMfaCode,
  verifyMfaCode,
};
</file>

<file path="sigl_backend/app/auth/mfaToken.model.js">
const mongoose = require("mongoose");

const mfaTokenSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    code: {
      type: String,
      required: true,
    },
    expiresAt: {
      type: Date,
      required: true,
    },
    consumedAt: {
      type: Date,
      default: null,
    },
  },
  { timestamps: true }
);

// TTL automatique après expiration
mfaTokenSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

module.exports = mongoose.model("MfaToken", mfaTokenSchema);
</file>

<file path="sigl_backend/app/config/jwt.config.js">
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

/**
 * JWT Configuration
 * Centralized configuration for JWT tokens with proper validation
 */
class JWTConfig {
    constructor() {
        this.validateEnvironmentVariables();
        
        this.JWT_SECRET = process.env.JWT_SECRET;
        this.JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET;
        this.ACCESS_TOKEN_EXPIRY = '15m';
        this.REFRESH_TOKEN_EXPIRY = '7d';
        this.ISSUER = 'learning-management-system';
        this.AUDIENCE = 'lms-users';
        this.ALGORITHM = 'HS256';
    }

    /**
     * Validate that all required environment variables are present
     * @throws {Error} If any required environment variable is missing
     */
    validateEnvironmentVariables() {
        const requiredVars = [
            'JWT_SECRET',
            'JWT_REFRESH_SECRET'
        ];

        const missingVars = requiredVars.filter(varName => !process.env[varName]);

        if (missingVars.length > 0) {
            throw new Error(
                `Missing required environment variables: ${missingVars.join(', ')}. ` +
                'Please check your .env file and ensure all JWT configuration variables are set.'
            );
        }

        // Validate JWT secret strength
        if (process.env.JWT_SECRET.length < 32) {
            throw new Error('JWT_SECRET must be at least 32 characters long for security.');
        }

        if (process.env.JWT_REFRESH_SECRET.length < 32) {
            throw new Error('JWT_REFRESH_SECRET must be at least 32 characters long for security.');
        }

        // Ensure secrets are different
        if (process.env.JWT_SECRET === process.env.JWT_REFRESH_SECRET) {
            throw new Error('JWT_SECRET and JWT_REFRESH_SECRET must be different for security.');
        }
    }

    /**
     * Get access token configuration
     * @returns {Object} Access token configuration
     */
    getAccessTokenConfig() {
        return {
            secret: this.JWT_SECRET,
            expiresIn: this.ACCESS_TOKEN_EXPIRY,
            issuer: this.ISSUER,
            audience: this.AUDIENCE,
            algorithm: this.ALGORITHM
        };
    }

    /**
     * Get refresh token configuration
     * @returns {Object} Refresh token configuration
     */
    getRefreshTokenConfig() {
        return {
            secret: this.JWT_REFRESH_SECRET,
            expiresIn: this.REFRESH_TOKEN_EXPIRY,
            issuer: this.ISSUER,
            audience: this.AUDIENCE,
            algorithm: this.ALGORITHM
        };
    }

    /**
     * Get verification options for JWT tokens
     * @returns {Object} Verification options
     */
    getVerifyOptions() {
        return {
            issuer: this.ISSUER,
            audience: this.AUDIENCE,
            algorithms: [this.ALGORITHM]
        };
    }
}

// Create and export singleton instance
const jwtConfig = new JWTConfig();

module.exports = {
    JWT_SECRET: jwtConfig.JWT_SECRET,
    JWT_REFRESH_SECRET: jwtConfig.JWT_REFRESH_SECRET,
    ACCESS_TOKEN_EXPIRY: jwtConfig.ACCESS_TOKEN_EXPIRY,
    REFRESH_TOKEN_EXPIRY: jwtConfig.REFRESH_TOKEN_EXPIRY,
    ISSUER: jwtConfig.ISSUER,
    AUDIENCE: jwtConfig.AUDIENCE,
    ALGORITHM: jwtConfig.ALGORITHM,
    getAccessTokenConfig: () => jwtConfig.getAccessTokenConfig(),
    getRefreshTokenConfig: () => jwtConfig.getRefreshTokenConfig(),
    getVerifyOptions: () => jwtConfig.getVerifyOptions()
};
</file>

<file path="sigl_backend/app/creneau/creneau.model.js">
const mongoose = require('mongoose');

const creneauSchema = new mongoose.Schema({
    debut: {
        type: Date,
        required: true
    },
    fin: {
        type: Date,
        required: true,
        validate: {
            validator: function(v) {
                return v > this.debut;
            },
            message: 'La fin doit être après le début'
        }
    }
}, {
    timestamps: true,
    collection: 'creneaux'
});

creneauSchema.index({ debut: 1, fin: 1 });

module.exports = mongoose.model('Creneau', creneauSchema);
</file>

<file path="sigl_backend/app/entretien/entretien.controller.js">
const entretienService = require('./entretien.service');

const demanderEntretien = async (req, res) => {
    try {
        const { objet, debut, fin, participantIds } = req.body;

        if (!objet || !debut || !fin || !participantIds || participantIds.length < 2) {
            return res.status(400).json({
                success: false,
                error: 'Données manquantes: objet, debut, fin et au moins 2 participants requis'
            });
        }

        const result = await entretienService.demanderEntretien(objet, debut, fin, participantIds);

        if (result.success) {
            res.status(201).json(result);
        } else {
            res.status(400).json(result);
        }
    } catch (error) {
        res.status(500).json({ success: false, error: 'Erreur serveur' });
    }
};

const confirmerEntretien = async (req, res) => {
    try {
        const { id } = req.params;
        const result = await entretienService.confirmerEntretien(id);

        if (result.success) {
            res.status(200).json(result);
        } else {
            res.status(404).json(result);
        }
    } catch (error) {
        res.status(500).json({ success: false, error: 'Erreur serveur' });
    }
};

const annulerEntretien = async (req, res) => {
    try {
        const { id } = req.params;
        const result = await entretienService.annulerEntretien(id);

        if (result.success) {
            res.status(200).json(result);
        } else {
            res.status(404).json(result);
        }
    } catch (error) {
        res.status(500).json({ success: false, error: 'Erreur serveur' });
    }
};

const getMesEntretiens = async (req, res) => {
    try {
        const userId = req.user.userId;
        const result = await entretienService.getEntretiensUtilisateur(userId);
        res.status(200).json(result);
    } catch (error) {
        res.status(500).json({ success: false, error: 'Erreur serveur' });
    }
};

module.exports = {
    demanderEntretien,
    confirmerEntretien,
    annulerEntretien,
    getMesEntretiens
};
</file>

<file path="sigl_backend/app/entretien/entretien.model.js">
const mongoose = require('mongoose');

const entretienSchema = new mongoose.Schema({
    objet: {
        type: String,
        required: true,
        minlength: 2
    },
    creneau: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Creneau',
        required: true
    },
    participants: {
        type: [{
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Utilisateur'
        }],
        validate: {
            validator: function(v) {
                return v.length >= 2;
            },
            message: 'Un entretien doit avoir au moins 2 participants'
        },
        required: true
    },
    statut: {
        type: String,
        enum: ['DEMANDE', 'CONFIRME', 'ANNULE', 'TERMINE'],
        default: 'DEMANDE'
    }
}, {
    timestamps: true,
    collection: 'entretiens'
});

entretienSchema.index({ creneau: 1 });

module.exports = mongoose.model('Entretien', entretienSchema);
</file>

<file path="sigl_backend/app/entretien/entretien.repository.js">
const Entretien = require('./entretien.model');
const Creneau = require('../creneau/creneau.model');

const createCreneau = async (debut, fin) => {
    const creneau = new Creneau({ debut, fin });
    return await creneau.save();
};

const createEntretien = async (entretienData) => {
    const entretien = new Entretien(entretienData);
    return await entretien.save();
};

const findEntretienById = async (id) => {
    return await Entretien.findById(id)
        .populate('creneau')
        .populate('participants', 'nom email role');
};

const findEntretiensByParticipant = async (userId) => {
    return await Entretien.find({ participants: userId })
        .populate('creneau')
        .populate('participants', 'nom email role')
        .sort({ 'creneau.debut': 1 });
};

const updateEntretienStatut = async (id, statut) => {
    return await Entretien.findByIdAndUpdate(
        id,
        { statut },
        { new: true }
    ).populate('creneau').populate('participants', 'nom email role');
};

const deleteEntretien = async (id) => {
    return await Entretien.findByIdAndDelete(id);
};

module.exports = {
    createCreneau,
    createEntretien,
    findEntretienById,
    findEntretiensByParticipant,
    updateEntretienStatut,
    deleteEntretien
};
</file>

<file path="sigl_backend/app/entretien/entretien.routes.js">
const express = require('express');
const router = express.Router();
const entretienController = require('./entretien.controller');
const { authenticate } = require('../middleware/authenticate');

// POST /api/entretiens - Demander un entretien
router.post('/', authenticate, entretienController.demanderEntretien);

// GET /api/entretiens/mes-entretiens - Obtenir mes entretiens
router.get('/mes-entretiens', authenticate, entretienController.getMesEntretiens);

// PUT /api/entretiens/:id/confirmer - Confirmer un entretien
router.put('/:id/confirmer', authenticate, entretienController.confirmerEntretien);

// PUT /api/entretiens/:id/annuler - Annuler un entretien
router.put('/:id/annuler', authenticate, entretienController.annulerEntretien);

module.exports = router;
</file>

<file path="sigl_backend/app/entretien/entretien.service.js">
const entretienRepository = require('./entretien.repository');

// Pour intégration future avec notifications
const notifyParticipants = async (entretien, message) => {
    // TODO: Implémenter quand le système de notifications sera prêt
    // Créer une notification pour chaque participant
    console.log(`📧 Notification à envoyer: ${message}`);
    console.log(`   Participants: ${entretien.participants.map(p => p.email || p).join(', ')}`);
};

const demanderEntretien = async (objet, debut, fin, participantIds) => {
    try {
        // Créer le créneau
        const creneau = await entretienRepository.createCreneau(new Date(debut), new Date(fin));

        // Créer l'entretien
        const entretien = await entretienRepository.createEntretien({
            objet,
            creneau: creneau._id,
            participants: participantIds,
            statut: 'DEMANDE'
        });

        const populatedEntretien = await entretienRepository.findEntretienById(entretien._id);

        // Notifier les participants (préparation pour système de notifications)
        await notifyParticipants(populatedEntretien, `Nouvelle demande d'entretien: ${objet}`);

        return { success: true, data: populatedEntretien };
    } catch (error) {
        console.error('Erreur création entretien:', error);
        return { success: false, error: error.message };
    }
};

const confirmerEntretien = async (entretienId) => {
    try {
        const entretien = await entretienRepository.updateEntretienStatut(entretienId, 'CONFIRME');
        if (!entretien) {
            return { success: false, error: 'Entretien non trouvé' };
        }
        await notifyParticipants(entretien, `Entretien confirmé: ${entretien.objet}`);
        return { success: true, data: entretien };
    } catch (error) {
        return { success: false, error: error.message };
    }
};

const annulerEntretien = async (entretienId) => {
    try {
        const entretien = await entretienRepository.updateEntretienStatut(entretienId, 'ANNULE');
        if (!entretien) {
            return { success: false, error: 'Entretien non trouvé' };
        }
        await notifyParticipants(entretien, `Entretien annulé: ${entretien.objet}`);
        return { success: true, data: entretien };
    } catch (error) {
        return { success: false, error: error.message };
    }
};

const getEntretiensUtilisateur = async (userId) => {
    try {
        const entretiens = await entretienRepository.findEntretiensByParticipant(userId);
        return { success: true, data: entretiens };
    } catch (error) {
        return { success: false, error: error.message };
    }
};

// Pour intégration future avec le calendrier
const getEntretiensForCalendar = async (userId, year, month) => {
    try {
        const entretiens = await entretienRepository.findEntretiensByParticipant(userId);
        // Filtrer par mois/année pour affichage calendrier
        const filtered = entretiens.filter(e => {
            const date = new Date(e.creneau.debut);
            return date.getFullYear() === year && date.getMonth() + 1 === month;
        });
        // Transformer en format calendrier
        return filtered.map(e => ({
            id: `entretien-${e._id}`,
            title: e.objet,
            date: e.creneau.debut.toISOString().split('T')[0],
            time: e.creneau.debut.toTimeString().slice(0, 5),
            category: 'rendez-vous',
            location: 'À définir',
            description: `Participants: ${e.participants.map(p => p.nom).join(', ')}`
        }));
    } catch (error) {
        return [];
    }
};

module.exports = {
    demanderEntretien,
    confirmerEntretien,
    annulerEntretien,
    getEntretiensUtilisateur,
    getEntretiensForCalendar
};
</file>

<file path="sigl_backend/app/journal/controller.js">
const journalService = require('./service');

/**
 * POST /api/journaux
 * Crée un journal mensuel pour l'apprenti connecté
 */
const createJournal = async (req, res, next) => {
  try {
    const userId = req.user.userId;

    const journal = await journalService.createJournalForUser(userId, req.body);

    return res.status(201).json({
      success: true,
      message: 'Journal créé avec succès',
      data: journal,
    });
  } catch (error) {
    console.error('createJournal error:', error);
    return res.status(500).json({
      success: false,
      error: 'INTERNAL_ERROR',
      message: 'Erreur lors de la création du journal',
    });
  }
};

/**
 * GET /api/journaux
 * Récupère tous les journaux de l'apprenti connecté
 */
const getMyJournaux = async (req, res, next) => {
  try {
    const userId = req.user.userId;

    const journaux = await journalService.getJournauxForUser(userId);

    return res.status(200).json({
      success: true,
      data: journaux,
    });
  } catch (error) {
    console.error('getMyJournaux error:', error);
    return res.status(500).json({
      success: false,
      error: 'INTERNAL_ERROR',
      message: 'Erreur lors de la récupération des journaux',
    });
  }
};

module.exports = {
  createJournal,
  getMyJournaux,
};
</file>

<file path="sigl_backend/app/journal/journalEntry.model.js">
const mongoose = require('mongoose');

const JournalEntrySchema = new mongoose.Schema(
  {
    // Référence vers l'utilisateur apprenti
    apprenti: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },

    // Date de la note (on utilisera la date de création)
    date: {
      type: Date,
      required: true,
    },

    // Contenu JSON stringifié (structure complète des périodes / missions)
    contenu: {
      type: String,
      required: true,
      minlength: 1,
      maxlength: 10000,
    },
  },
  {
    timestamps: true,
    collection: 'journal_entries', // colle à ta metadata existante
  }
);

module.exports = mongoose.model('JournalEntry', JournalEntrySchema);
</file>

<file path="sigl_backend/app/journal/repository.js">
const JournalEntry = require('./journalEntry.model');

const createJournal = async (data) => {
  const entry = new JournalEntry(data);
  return entry.save();
};

const findByApprenti = async (apprentiId) => {
  return JournalEntry.find({ apprenti: apprentiId }).sort({ date: -1 });
};

const findOneByIdAndApprenti = async (id, apprentiId) => {
  return JournalEntry.findOne({ _id: id, apprenti: apprentiId });
};

module.exports = {
  createJournal,
  findByApprenti,
  findOneByIdAndApprenti,
};
</file>

<file path="sigl_backend/app/journal/routes.js">
const express = require('express');
const { authenticate } = require('../middleware/authenticate');
const { authenticatedUsers } = require('../middleware/authorize');
const journalController = require('./controller');

const router = express.Router();

// Toutes les routes sont protégées : il faut être connecté
router.use(authenticate, authenticatedUsers());

router.post('/', journalController.createJournal);
router.get('/', journalController.getMyJournaux);

module.exports = router;
</file>

<file path="sigl_backend/app/journal/service.js">
const journalRepository = require('./repository');

/**
 * Transforme le payload du front en document MongoDB
 */
const createJournalForUser = async (userId, journalPayload) => {
  const {
    periodes = [],
    status = 'EN_COURS',
    createdAt,
  } = journalPayload || {};

  const date = createdAt ? new Date(createdAt) : new Date();

  const contenu = JSON.stringify({
    periodes,
    status,
  });

  const entry = await journalRepository.createJournal({
    apprenti: userId,
    date,
    contenu,
  });

  return mapJournalEntryToDto(entry);
};

/**
 * Récupère tous les journaux de l'utilisateur
 */
const getJournauxForUser = async (userId) => {
  const docs = await journalRepository.findByApprenti(userId);
  return docs.map(mapJournalEntryToDto);
};

/**
 * Mapping MongoDB -> objet que le front comprend
 */
const mapJournalEntryToDto = (doc) => {
  let parsed = {};
  try {
    parsed = JSON.parse(doc.contenu || '{}');
  } catch (e) {
    parsed = {};
  }

  return {
    id: doc._id.toString(),
    userId: doc.apprenti.toString(),
    createdAt: doc.date,
    updatedAt: doc.updatedAt,
    periodes: parsed.periodes || [],
    status: parsed.status || 'EN_COURS',
  };
};

module.exports = {
  createJournalForUser,
  getJournauxForUser,
};
</file>

<file path="sigl_backend/app/middleware/authorize.js">
/**
 * Role-based Authorization Middleware
 * Provides role-based access control for protected routes
 */

/**
 * Valid roles in the system based on UML diagram
 */
const VALID_ROLES = [
    'APPRENTI',
    'MA',
    'TP', 
    'CA',
    'RC',
    'PROF',
    'ADMIN'
];

/**
 * Role hierarchy for hierarchical access control
 * Higher index means higher privilege level
 */
const ROLE_HIERARCHY = [
    'APPRENTI',  // 0 - Lowest privilege
    'MA',        // 1 - Maitre d'Apprentissage
    'TP',        // 2 - Tuteur Pedagogique
    'PROF',      // 3 - Professeur
    'CA',        // 4 - Coordinatrice Alternance
    'RC',        // 5 - Responsable Cursus
    'ADMIN'      // 6 - Highest privilege
];

/**
 * Factory function to create role-based authorization middleware
 * 
 * @param {...string} allowedRoles - Roles that are allowed to access the route
 * @returns {Function} Express middleware function
 * 
 * @example
 * // Allow only admins
 * router.get('/admin-only', authenticate, authorizeRoles('ADMIN'), handler);
 * 
 * @example
 * // Allow multiple roles
 * router.get('/staff-only', authenticate, authorizeRoles('CA', 'RC', 'PROF', 'ADMIN'), handler);
 */
const authorizeRoles = (...allowedRoles) => {
    return (req, res, next) => {
        try {
            // Check if user is authenticated (should be set by authenticate middleware)
            if (!req.user) {
                return res.status(401).json({
                    success: false,
                    message: 'Authentication required. Please login first.',
                    error: 'AUTHENTICATION_REQUIRED'
                });
            }

            // Validate that user has a role
            if (!req.user.role) {
                return res.status(403).json({
                    success: false,
                    message: 'User role not found. Access denied.',
                    error: 'ROLE_NOT_FOUND'
                });
            }

            // Validate allowed roles parameter
            if (!allowedRoles || allowedRoles.length === 0) {
                console.error('Authorization middleware error: No allowed roles specified');
                return res.status(500).json({
                    success: false,
                    message: 'Server configuration error.',
                    error: 'NO_ROLES_SPECIFIED'
                });
            }

            // Validate that all specified roles are valid
            const invalidRoles = allowedRoles.filter(role => !VALID_ROLES.includes(role));
            if (invalidRoles.length > 0) {
                console.error(`Authorization middleware error: Invalid roles specified: ${invalidRoles.join(', ')}`);
                return res.status(500).json({
                    success: false,
                    message: 'Server configuration error.',
                    error: 'INVALID_ROLES_SPECIFIED'
                });
            }

            // Check if user's role is in allowed roles
            if (!allowedRoles.includes(req.user.role)) {
                // Log authorization failure for monitoring
                console.log(`Authorization denied: User ${req.user.email} (${req.user.role}) attempted to access route requiring roles: ${allowedRoles.join(', ')} - ${new Date().toISOString()}`);
                
                return res.status(403).json({
                    success: false,
                    message: 'Access denied. Insufficient privileges.',
                    error: 'INSUFFICIENT_PRIVILEGES',
                    requiredRoles: allowedRoles,
                    userRole: req.user.role
                });
            }

            // Log successful authorization
            console.log(`Authorization granted: User ${req.user.email} (${req.user.role}) accessing route - ${new Date().toISOString()}`);

            next();
        } catch (error) {
            console.error('Authorization middleware error:', error.message);
            return res.status(500).json({
                success: false,
                message: 'Internal server error during authorization.',
                error: 'AUTHORIZATION_ERROR'
            });
        }
    };
};

/**
 * Hierarchical authorization middleware
 * Allows access if user's role is at or above the minimum required level
 * 
 * @param {string} minimumRole - Minimum role required to access the route
 * @returns {Function} Express middleware function
 * 
 * @example
 * // Allow CA and above (CA, RC, ADMIN)
 * router.get('/coordinator-level', authenticate, authorizeMinimumRole('CA'), handler);
 */
const authorizeMinimumRole = (minimumRole) => {
    return (req, res, next) => {
        try {
            // Check if user is authenticated
            if (!req.user) {
                return res.status(401).json({
                    success: false,
                    message: 'Authentication required. Please login first.',
                    error: 'AUTHENTICATION_REQUIRED'
                });
            }

            // Validate that user has a role
            if (!req.user.role) {
                return res.status(403).json({
                    success: false,
                    message: 'User role not found. Access denied.',
                    error: 'ROLE_NOT_FOUND'
                });
            }

            // Validate minimum role parameter
            if (!minimumRole || !VALID_ROLES.includes(minimumRole)) {
                console.error(`Authorization middleware error: Invalid minimum role specified: ${minimumRole}`);
                return res.status(500).json({
                    success: false,
                    message: 'Server configuration error.',
                    error: 'INVALID_MINIMUM_ROLE'
                });
            }

            // Get role hierarchy levels
            const userRoleLevel = ROLE_HIERARCHY.indexOf(req.user.role);
            const minimumRoleLevel = ROLE_HIERARCHY.indexOf(minimumRole);

            // Check if user's role level meets minimum requirement
            if (userRoleLevel < minimumRoleLevel) {
                console.log(`Hierarchical authorization denied: User ${req.user.email} (${req.user.role}, level ${userRoleLevel}) attempted to access route requiring minimum role: ${minimumRole} (level ${minimumRoleLevel}) - ${new Date().toISOString()}`);
                
                return res.status(403).json({
                    success: false,
                    message: 'Access denied. Insufficient role level.',
                    error: 'INSUFFICIENT_ROLE_LEVEL',
                    minimumRole: minimumRole,
                    userRole: req.user.role
                });
            }

            console.log(`Hierarchical authorization granted: User ${req.user.email} (${req.user.role}, level ${userRoleLevel}) accessing route requiring minimum: ${minimumRole} (level ${minimumRoleLevel}) - ${new Date().toISOString()}`);

            next();
        } catch (error) {
            console.error('Hierarchical authorization middleware error:', error.message);
            return res.status(500).json({
                success: false,
                message: 'Internal server error during authorization.',
                error: 'AUTHORIZATION_ERROR'
            });
        }
    };
};

/**
 * Self-access authorization middleware
 * Allows users to access their own resources or admins to access any resource
 * 
 * @param {string} userIdParam - Name of the route parameter containing the user ID (default: 'userId')
 * @returns {Function} Express middleware function
 * 
 * @example
 * // Allow users to access their own profile or admins to access any profile
 * router.get('/users/:userId/profile', authenticate, authorizeSelfOrAdmin(), handler);
 * 
 * @example
 * // Custom parameter name
 * router.get('/profiles/:id', authenticate, authorizeSelfOrAdmin('id'), handler);
 */
const authorizeSelfOrAdmin = (userIdParam = 'userId') => {
    return (req, res, next) => {
        try {
            // Check if user is authenticated
            if (!req.user) {
                return res.status(401).json({
                    success: false,
                    message: 'Authentication required. Please login first.',
                    error: 'AUTHENTICATION_REQUIRED'
                });
            }

            // Get the target user ID from route parameters
            const targetUserId = req.params[userIdParam];
            
            if (!targetUserId) {
                return res.status(400).json({
                    success: false,
                    message: `Missing required parameter: ${userIdParam}`,
                    error: 'MISSING_USER_ID_PARAMETER'
                });
            }

            // Allow if user is admin
            if (req.user.role === 'ADMIN') {
                console.log(`Admin access granted: ${req.user.email} accessing resource for user ${targetUserId} - ${new Date().toISOString()}`);
                return next();
            }

            // Allow if user is accessing their own resource
            if (req.user.userId === targetUserId) {
                console.log(`Self access granted: ${req.user.email} accessing own resource - ${new Date().toISOString()}`);
                return next();
            }

            // Deny access
            console.log(`Self/Admin authorization denied: User ${req.user.email} (${req.user.role}) attempted to access resource for user ${targetUserId} - ${new Date().toISOString()}`);
            
            return res.status(403).json({
                success: false,
                message: 'Access denied. You can only access your own resources.',
                error: 'SELF_ACCESS_ONLY'
            });

        } catch (error) {
            console.error('Self/Admin authorization middleware error:', error.message);
            return res.status(500).json({
                success: false,
                message: 'Internal server error during authorization.',
                error: 'AUTHORIZATION_ERROR'
            });
        }
    };
};

/**
 * Helper functions for common role combinations
 */

/**
 * Admin-only access
 * @returns {Function} Express middleware function
 */
const adminOnly = () => authorizeRoles('ADMIN');

/**
 * Staff access (CA, RC, TP, PROF, ADMIN)
 * @returns {Function} Express middleware function
 */
const staffOnly = () => authorizeRoles('CA', 'RC', 'TP', 'PROF', 'ADMIN');

/**
 * Coordinator and above access (CA, RC, ADMIN)
 * @returns {Function} Express middleware function
 */
const coordinatorAndAbove = () => authorizeRoles('CA', 'RC', 'ADMIN');

/**
 * Professor and above access (PROF, CA, RC, ADMIN)
 * @returns {Function} Express middleware function
 */
const professorAndAbove = () => authorizeRoles('PROF', 'CA', 'RC', 'ADMIN');

/**
 * Educational staff access (TP, PROF, CA, RC, ADMIN)
 * @returns {Function} Express middleware function
 */
const educationalStaff = () => authorizeRoles('TP', 'PROF', 'CA', 'RC', 'ADMIN');

/**
 * All authenticated users
 * @returns {Function} Express middleware function
 */
const authenticatedUsers = () => authorizeRoles(...VALID_ROLES);

module.exports = {
    // Main authorization functions
    authorizeRoles,
    authorizeMinimumRole,
    authorizeSelfOrAdmin,
    
    // Helper functions for common role combinations
    adminOnly,
    staffOnly,
    coordinatorAndAbove,
    professorAndAbove,
    educationalStaff,
    authenticatedUsers,
    
    // Constants for external use
    VALID_ROLES,
    ROLE_HIERARCHY
};
</file>

<file path="sigl_backend/app/soutenance/jury.model.js">
const mongoose = require('mongoose');

const jurySchema = new mongoose.Schema({
    professeurs: {
        type: [{
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Utilisateur'
        }],
        validate: {
            validator: function(v) {
                return v.length >= 3 && v.length <= 5;
            },
            message: 'Un jury doit contenir entre 3 et 5 professeurs'
        },
        required: true
    }
}, {
    timestamps: true,
    collection: 'jurys'
});

module.exports = mongoose.model('Jury', jurySchema);
</file>

<file path="sigl_backend/app/soutenance/soutenance.controller.js">
const soutenanceService = require('./soutenance.service');

const planifierSoutenance = async (req, res) => {
    try {
        const { apprentiId, dateHeure, salle, professeurIds } = req.body;

        if (!apprentiId || !dateHeure || !professeurIds) {
            return res.status(400).json({
                success: false,
                error: 'Données manquantes: apprentiId, dateHeure et professeurIds requis'
            });
        }

        const result = await soutenanceService.planifierSoutenance(
            apprentiId, dateHeure, salle, professeurIds
        );

        if (result.success) {
            res.status(201).json(result);
        } else {
            res.status(400).json(result);
        }
    } catch (error) {
        res.status(500).json({ success: false, error: 'Erreur serveur' });
    }
};

const validerSoutenance = async (req, res) => {
    try {
        const { id } = req.params;
        const result = await soutenanceService.validerSoutenance(id);

        if (result.success) {
            res.status(200).json(result);
        } else {
            res.status(404).json(result);
        }
    } catch (error) {
        res.status(500).json({ success: false, error: 'Erreur serveur' });
    }
};

const getMaSoutenance = async (req, res) => {
    try {
        const userId = req.user.userId;
        const result = await soutenanceService.getSoutenanceApprenti(userId);
        res.status(200).json(result);
    } catch (error) {
        res.status(500).json({ success: false, error: 'Erreur serveur' });
    }
};

const getAllSoutenances = async (req, res) => {
    try {
        const result = await soutenanceService.getAllSoutenances();
        res.status(200).json(result);
    } catch (error) {
        res.status(500).json({ success: false, error: 'Erreur serveur' });
    }
};

module.exports = {
    planifierSoutenance,
    validerSoutenance,
    getMaSoutenance,
    getAllSoutenances
};
</file>

<file path="sigl_backend/app/soutenance/soutenance.model.js">
const mongoose = require('mongoose');

const soutenanceSchema = new mongoose.Schema({
    apprenti: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Utilisateur',
        required: true
    },
    jury: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Jury',
        required: true
    },
    salle: {
        type: String,
        default: null
    },
    dateHeure: {
        type: Date,
        required: true
    },
    etat: {
        type: String,
        enum: ['PLANIFIEE', 'VALIDEE', 'TERMINEE', 'ANNULEE'],
        default: 'PLANIFIEE'
    }
}, {
    timestamps: true,
    collection: 'soutenances'
});

soutenanceSchema.index({ apprenti: 1 });
soutenanceSchema.index({ dateHeure: 1 });

module.exports = mongoose.model('Soutenance', soutenanceSchema);
</file>

<file path="sigl_backend/app/soutenance/soutenance.repository.js">
const Soutenance = require('./soutenance.model');
const Jury = require('./jury.model');

const createJury = async (professeurIds) => {
    const jury = new Jury({ professeurs: professeurIds });
    return await jury.save();
};

const createSoutenance = async (soutenanceData) => {
    const soutenance = new Soutenance(soutenanceData);
    return await soutenance.save();
};

const findSoutenanceById = async (id) => {
    return await Soutenance.findById(id)
        .populate('apprenti', 'nom email')
        .populate({
            path: 'jury',
            populate: { path: 'professeurs', select: 'nom email' }
        });
};

const findSoutenanceByApprenti = async (apprentiId) => {
    return await Soutenance.findOne({ apprenti: apprentiId })
        .populate('apprenti', 'nom email')
        .populate({
            path: 'jury',
            populate: { path: 'professeurs', select: 'nom email' }
        });
};

const findAllSoutenances = async (filters = {}) => {
    return await Soutenance.find(filters)
        .populate('apprenti', 'nom email')
        .populate({
            path: 'jury',
            populate: { path: 'professeurs', select: 'nom email' }
        })
        .sort({ dateHeure: 1 });
};

const updateSoutenanceEtat = async (id, etat) => {
    return await Soutenance.findByIdAndUpdate(
        id,
        { etat },
        { new: true }
    );
};

module.exports = {
    createJury,
    createSoutenance,
    findSoutenanceById,
    findSoutenanceByApprenti,
    findAllSoutenances,
    updateSoutenanceEtat
};
</file>

<file path="sigl_backend/app/soutenance/soutenance.routes.js">
const express = require('express');
const router = express.Router();
const soutenanceController = require('./soutenance.controller');
const { authenticate } = require('../middleware/authenticate');
const { authorizeRoles } = require('../middleware/authorize');

// POST /api/soutenances - Planifier une soutenance (CA, RC, ADMIN)
router.post('/',
    authenticate,
    authorizeRoles('CA', 'RC', 'ADMIN'),
    soutenanceController.planifierSoutenance
);

// GET /api/soutenances - Obtenir toutes les soutenances (staff)
router.get('/',
    authenticate,
    authorizeRoles('CA', 'RC', 'PROF', 'ADMIN'),
    soutenanceController.getAllSoutenances
);

// GET /api/soutenances/ma-soutenance - Obtenir ma soutenance (apprenti)
router.get('/ma-soutenance', authenticate, soutenanceController.getMaSoutenance);

// PUT /api/soutenances/:id/valider - Valider une soutenance (RC, ADMIN)
router.put('/:id/valider',
    authenticate,
    authorizeRoles('RC', 'ADMIN'),
    soutenanceController.validerSoutenance
);

module.exports = router;
</file>

<file path="sigl_backend/app/soutenance/soutenance.service.js">
const soutenanceRepository = require('./soutenance.repository');

// Pour intégration future avec notifications
const notifyAboutSoutenance = async (soutenance, message) => {
    console.log(`📧 Notification soutenance: ${message}`);
    // TODO: Notifier l'apprenti et les membres du jury
};

const planifierSoutenance = async (apprentiId, dateHeure, salle, professeurIds) => {
    try {
        // Vérifier que l'apprenti n'a pas déjà une soutenance
        const existingSoutenance = await soutenanceRepository.findSoutenanceByApprenti(apprentiId);
        if (existingSoutenance) {
            return { success: false, error: 'L\'apprenti a déjà une soutenance planifiée' };
        }

        // Créer le jury (3-5 professeurs requis)
        if (professeurIds.length < 3 || professeurIds.length > 5) {
            return { success: false, error: 'Un jury doit contenir entre 3 et 5 professeurs' };
        }
        const jury = await soutenanceRepository.createJury(professeurIds);

        // Créer la soutenance
        const soutenance = await soutenanceRepository.createSoutenance({
            apprenti: apprentiId,
            jury: jury._id,
            dateHeure: new Date(dateHeure),
            salle,
            etat: 'PLANIFIEE'
        });

        const populatedSoutenance = await soutenanceRepository.findSoutenanceById(soutenance._id);
        await notifyAboutSoutenance(populatedSoutenance, 'Nouvelle soutenance planifiée');

        return { success: true, data: populatedSoutenance };
    } catch (error) {
        console.error('Erreur planification soutenance:', error);
        return { success: false, error: error.message };
    }
};

const validerSoutenance = async (soutenanceId) => {
    try {
        const soutenance = await soutenanceRepository.updateSoutenanceEtat(soutenanceId, 'VALIDEE');
        if (!soutenance) {
            return { success: false, error: 'Soutenance non trouvée' };
        }
        const populated = await soutenanceRepository.findSoutenanceById(soutenanceId);
        await notifyAboutSoutenance(populated, 'Soutenance validée');
        return { success: true, data: populated };
    } catch (error) {
        return { success: false, error: error.message };
    }
};

const getSoutenanceApprenti = async (apprentiId) => {
    try {
        const soutenance = await soutenanceRepository.findSoutenanceByApprenti(apprentiId);
        return { success: true, data: soutenance };
    } catch (error) {
        return { success: false, error: error.message };
    }
};

const getAllSoutenances = async () => {
    try {
        const soutenances = await soutenanceRepository.findAllSoutenances();
        return { success: true, data: soutenances };
    } catch (error) {
        return { success: false, error: error.message };
    }
};

// Pour intégration future avec le calendrier
const getSoutenancesForCalendar = async (year, month) => {
    try {
        const soutenances = await soutenanceRepository.findAllSoutenances();
        const filtered = soutenances.filter(s => {
            const date = new Date(s.dateHeure);
            return date.getFullYear() === year && date.getMonth() + 1 === month;
        });
        return filtered.map(s => ({
            id: `soutenance-${s._id}`,
            title: `Soutenance - ${s.apprenti?.nom || 'Apprenti'}`,
            date: s.dateHeure.toISOString().split('T')[0],
            time: s.dateHeure.toTimeString().slice(0, 5),
            category: 'rendez-vous',
            location: s.salle || 'Salle à définir',
            description: `Jury: ${s.jury?.professeurs?.map(p => p.nom).join(', ') || 'Non défini'}`
        }));
    } catch (error) {
        return [];
    }
};

module.exports = {
    planifierSoutenance,
    validerSoutenance,
    getSoutenanceApprenti,
    getAllSoutenances,
    getSoutenancesForCalendar
};
</file>

<file path="sigl_backend/app/test/controller.js">
const getTest = (req, res) => {
    res.json({
        message: 'La route de test fonctionne !',
        method: req.method,
        timestamp: new Date().toISOString()
    });
};

const postTest = (req, res) => {
    res.json({
        message: 'La route POST de test fonctionne !',
        receivedData: req.body,
        timestamp: new Date().toISOString()
    });
};

module.exports = {
    getTest,
    postTest
};
</file>

<file path="sigl_backend/app/test/routes.js">
const express = require('express');
const router = express.Router();
const testController = require('./controller');

// GET /api/test
router.get('/', testController.getTest);

// POST /api/test
router.post('/', testController.postTest);

module.exports = router;
</file>

<file path="sigl_backend/Dockerfile">
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "start"]
</file>

<file path="sigl_backend/README.md">
# Learning Management System Backend API

A robust Node.js/Express backend API for a Learning Management System with JWT-based authentication, role-based authorization, and comprehensive user management.

## 🚀 Quick Start

### Prerequisites
- Node.js (v14 or higher)
- MongoDB (local or remote instance)
- npm or yarn

### Installation
```bash
# Clone the repository
git clone <repository-url>
cd backend

# Install dependencies
npm install

# Set up environment variables
cp .env.example .env
# Edit .env with your configuration

# Start the server
npm start
```

The server will start on `http://localhost:3000` by default.

## 📋 Table of Contents

- [Authentication & Authorization](#authentication--authorization)
- [Role System](#role-system)
- [API Endpoints](#api-endpoints)
- [Error Handling](#error-handling)
- [Security Features](#security-features)
- [Testing](#testing)

## 🔐 Authentication & Authorization

### Overview
The system uses JWT (JSON Web Tokens) for authentication with a dual-token approach:
- **Access Token**: Short-lived (15 minutes) for API access
- **Refresh Token**: Long-lived for obtaining new access tokens

### Authentication Flow
1. **Registration**: Create user account with atomic user+auth record creation
2. **Login**: Authenticate and receive JWT tokens
3. **API Access**: Use access token in Authorization header
4. **Token Refresh**: Use refresh token to get new access tokens
5. **Logout**: Invalidate tokens (optional)

### Security Features
- ✅ **Password Hashing**: bcrypt with salt rounds
- ✅ **Rate Limiting**: 5 requests per 15 minutes for auth endpoints
- ✅ **Token Expiration**: Short-lived access tokens
- ✅ **Role-Based Access Control**: Granular permissions
- ✅ **Input Validation**: Comprehensive request validation
- ✅ **Error Sanitization**: No sensitive data in error responses

## 👥 Role System

### Standardized English Role Codes

The system uses **English role codes only** for consistency across all components:

| Role Code | Description | Access Level |
|-----------|-------------|--------------|
| `APPRENTI` | Apprentice/Student | Basic user access |
| `MA` | Maître d'Apprentissage (Mentor) | Mentor-level access |
| `TP` | Tuteur Pédagogique (Educational Tutor) | Educational oversight |
| `CA` | Chargé d'Affaires (Account Manager) | Business management |
| `RC` | Responsable de Centre (Center Manager) | Center administration |
| `PROF` | Professor/Instructor | Teaching and content management |
| `ADMIN` | System Administrator | Full system access |

### Role Hierarchy (Authorization Levels)
```
ADMIN > PROF > RC > CA > TP > MA > APPRENTI
```

### Important Notes
- ⚠️ **French role names are NO LONGER SUPPORTED**
- ✅ All API endpoints accept and return English role codes only
- ✅ JWT tokens contain English role codes
- ✅ Database stores English role codes
- ✅ Authorization middleware uses English role codes

## 🛠 API Endpoints

### Base URL
```
http://localhost:3000/api
```

### Authentication Endpoints

#### Register User
```http
POST /api/users/register
```

**Request Body:**
```json
{
  "username": "johndoe",
  "email": "john@example.com",
  "password": "SecurePass123!",
  "role": "APPRENTI"
}
```

**Response (201 Created):**
```json
{
  "message": "Utilisateur enregistré avec succès",
  "user": {
    "_id": "64f8a1b2c3d4e5f6a7b8c9d0",
    "nom": "johndoe",
    "email": "john@example.com",
    "role": "APPRENTI"
  }
}
```

**Validation Rules:**
- `username`: 3-50 characters, alphanumeric + underscore
- `email`: Valid email format
- `password`: Minimum 8 characters, must include uppercase, lowercase, number, and special character
- `role`: Must be one of the 7 valid English role codes

#### Login
```http
POST /api/auth/login
```

**Request Body:**
```json
{
  "email": "john@example.com",
  "password": "SecurePass123!"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Login successful",
  "data": {
    "user": {
      "id": "64f8a1b2c3d4e5f6a7b8c9d0",
      "nom": "johndoe",
      "email": "john@example.com",
      "role": "APPRENTI"
    },
    "tokens": {
      "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "tokenType": "Bearer",
      "expiresIn": "15m"
    }
  }
}
```

#### Refresh Token
```http
POST /api/auth/refresh
Authorization: Bearer <refresh_token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Token refreshed successfully",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": "15m"
  }
}
```

#### Change Password
```http
POST /api/auth/change-password
Authorization: Bearer <access_token>
```

**Request Body:**
```json
{
  "currentPassword": "OldPass123!",
  "newPassword": "NewSecurePass456!"
}
```

#### Logout
```http
POST /api/auth/logout
Authorization: Bearer <access_token>
```

### User Management Endpoints

#### Get User Profile
```http
GET /api/users/:id
Authorization: Bearer <access_token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "user": {
      "_id": "64f8a1b2c3d4e5f6a7b8c9d0",
      "nom": "johndoe",
      "email": "john@example.com",
      "role": "APPRENTI",
      "createdAt": "2023-09-06T10:30:00.000Z"
    }
  }
}
```

#### List All Users
```http
GET /api/users
Authorization: Bearer <access_token>
```
*Requires ADMIN or PROF role*

#### Update User
```http
PUT /api/users/:id
Authorization: Bearer <access_token>
```

**Request Body:**
```json
{
  "nom": "newusername",
  "email": "newemail@example.com",
  "role": "MA"
}
```

#### Delete User
```http
DELETE /api/users/:id
Authorization: Bearer <access_token>
```
*Requires ADMIN role*

### Protected Routes

All protected routes require a valid access token in the Authorization header:
```http
Authorization: Bearer <access_token>
```

## ⚠️ Error Handling

### Standard Error Response Format
```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message"
  }
}
```

### Common Error Codes

| Status Code | Error Code | Description |
|-------------|------------|-------------|
| 400 | `VALIDATION_ERROR` | Invalid request data |
| 400 | `INVALID_ROLE` | Role not in allowed list |
| 401 | `UNAUTHORIZED` | Missing or invalid token |
| 401 | `INVALID_CREDENTIALS` | Wrong email/password |
| 403 | `FORBIDDEN` | Insufficient permissions |
| 409 | `DUPLICATE_EMAIL` | Email already exists |
| 409 | `DUPLICATE_USERNAME` | Username already exists |
| 429 | `RATE_LIMIT_EXCEEDED` | Too many requests |
| 500 | `INTERNAL_ERROR` | Server error |

### Role Validation Errors

**Invalid Role Example:**
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Le rôle doit être l'un des suivants: APPRENTI, MA, TP, CA, RC, PROF, ADMIN"
  }
}
```

## 🔒 Security Features

### Rate Limiting
- **Authentication endpoints**: 5 requests per 15 minutes per IP
- **General API**: Standard rate limiting applied
- **Bypass**: Successful requests don't count against limit

### Password Security
- **Hashing**: bcrypt with salt rounds
- **Requirements**: 8+ characters, mixed case, numbers, special characters
- **Storage**: Only hashed passwords stored, never plaintext

### JWT Security
- **Access Token**: 15-minute expiration
- **Refresh Token**: Longer-lived for token renewal
- **Signing**: HMAC SHA256 with secure secret
- **Validation**: Comprehensive token validation on all protected routes

### Input Validation
- **Email**: RFC-compliant email validation
- **Username**: Alphanumeric + underscore, 3-50 characters
- **Role**: Strict validation against allowed English codes
- **Sanitization**: All inputs sanitized to prevent injection

## 🧪 Testing

### Test Suite
The API includes comprehensive test coverage:

- **Bruno API Tests**: Located in `API_test/` directory
- **Unit Tests**: Individual component testing
- **Integration Tests**: End-to-end workflow testing
- **Security Tests**: Authentication and authorization validation

### Running Tests

#### Bruno API Tests
```bash
# Install Bruno CLI
npm install -g @usebruno/cli

# Run all tests
bru run API_test/ --env local

# Run specific test collection
bru run API_test/Auth/ --env local
bru run API_test/User/ --env local
```

#### Test Categories
- ✅ **Authentication Flow**: Registration, login, token refresh
- ✅ **Role Validation**: English role acceptance, French role rejection
- ✅ **Authorization**: Role-based access control
- ✅ **Error Handling**: Invalid inputs, unauthorized access
- ✅ **Security**: Rate limiting, password validation
- ✅ **Data Integrity**: Duplicate prevention, transaction safety

### Test Results
- **Overall Success Rate**: 95%
- **Core Authentication**: 100% success rate
- **Role System**: 100% success rate
- **Registration Flow**: 100% success rate

## 📊 System Status

### ✅ Production Ready Features
- **Authentication System**: Fully functional JWT implementation
- **Role-Based Authorization**: Complete English role system
- **User Registration**: Atomic user+auth record creation
- **Security Measures**: Rate limiting, password hashing, input validation
- **Error Handling**: Comprehensive error responses
- **API Documentation**: Complete endpoint documentation

### 🔧 Recent Fixes (November 2025)
1. **✅ Role System Standardization**: Migrated from mixed French/English to English-only role codes
2. **✅ Registration Flow**: Implemented atomic user+auth record creation
3. **✅ Transaction Integrity**: Ensured no orphaned records on failures
4. **✅ Comprehensive Testing**: 95% test coverage with detailed verification

### 📈 Performance Metrics
- **Registration Response Time**: < 100ms average
- **Login Response Time**: < 80ms average
- **Database Operations**: Optimized queries with proper indexing
- **Memory Usage**: No memory leaks detected

## 🔗 Related Documentation

- [AUTHENTICATION_TEST_REPORT.md](AUTHENTICATION_TEST_REPORT.md) - Detailed authentication testing results
- [COMPREHENSIVE_FIX_VERIFICATION_REPORT.md](COMPREHENSIVE_FIX_VERIFICATION_REPORT.md) - Critical issues resolution verification
- [API_test/SETUP.md](API_test/SETUP.md) - Bruno test setup instructions

## 🤝 Contributing

1. Follow the established role system (English codes only)
2. Maintain comprehensive test coverage
3. Update documentation for any API changes
4. Ensure all security measures remain intact

## 📝 License

This project is private and proprietary.

---

**System Status**: ✅ **PRODUCTION READY**  
**Last Updated**: November 19, 2025  
**Version**: 1.0.0
</file>

<file path="sigl_frontend/.env">
VITE_API_URL=http://localhost:3000/api
</file>

<file path="sigl_frontend/.gitignore">
/.idea/
/.vscode/
/node_modules/
/repomix-output.xml
</file>

<file path="sigl_frontend/index.html">
<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IZIA - Plateforme de gestion des apprentis</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="sigl_frontend/package.json">
{
  "name": "izia-app",
  "version": "1.0.0",
  "description": "Plateforme IZIA pour la gestion des apprentis",
  "scripts": {
    "dev": "vite --port 5173",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.30.2"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.2.0",
    "autoprefixer": "^10.4.22",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.18",
    "vite": "^5.0.0"
  }
}
</file>

<file path="sigl_frontend/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="sigl_frontend/src/components/Header.jsx">
import React from 'react';

const Header = () => {
  return (
    <header className="bg-white shadow-sm border-b border-gray-200">
      <div className="container mx-auto px-4 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-primary-600 rounded-lg flex items-center justify-center">
              <span className="text-white font-bold text-xl">I</span>
            </div>
            <h1 className="text-2xl font-bold text-gray-800">IZIA</h1>
          </div>
          <nav className="hidden md:flex space-x-6">
            <a href="#" className="text-gray-600 hover:text-primary-600 transition">Accueil</a>
            <a href="#" className="text-gray-600 hover:text-primary-600 transition">À propos</a>
            <a href="#" className="text-gray-600 hover:text-primary-600 transition">Contact</a>
          </nav>
        </div>
      </div>
    </header>
  );
};

export default Header;
</file>

<file path="sigl_frontend/src/components/TestConnection.jsx">
import React, { useState, useEffect } from 'react';
import axios from 'axios';

const TestConnection = () => {
  const [status, setStatus] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Test automatique au chargement
  useEffect(() => {
    testConnection();
  }, []);

  const testConnection = async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Appel à la route /status du backend
      const response = await axios.get('http://localhost:3000/status');
      console.log('✅ Réponse du backend:', response.data);
      setStatus(response.data);
      setLoading(false);
    } catch (err) {
      console.error('❌ Erreur de connexion:', err);
      setError(err.message);
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-100 flex items-center justify-center p-4">
      <div className="bg-white rounded-lg shadow-xl p-8 max-w-2xl w-full">
        <h1 className="text-3xl font-bold text-gray-800 mb-6">
          🔗 Test de connexion Frontend ↔ Backend
        </h1>

        {/* Statut du chargement */}
        {loading && (
          <div className="flex items-center justify-center py-8">
            <svg className="animate-spin h-10 w-10 text-primary-600" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
            <span className="ml-3 text-gray-600">Test en cours...</span>
          </div>
        )}

        {/* Affichage de l'erreur */}
        {error && (
          <div className="bg-red-50 border border-red-300 rounded-lg p-4 mb-4">
            <div className="flex items-start">
              <svg className="w-6 h-6 text-red-600 mr-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
              </svg>
              <div>
                <h3 className="text-red-800 font-semibold mb-1">❌ Échec de la connexion</h3>
                <p className="text-red-700 text-sm">{error}</p>
                <div className="mt-3 text-sm text-red-600">
                  <p className="font-semibold mb-1">Vérifiez que :</p>
                  <ul className="list-disc list-inside space-y-1 ml-2">
                    <li>Le backend est démarré sur le port 3000</li>
                    <li>MongoDB est en cours d'exécution</li>
                    <li>CORS est configuré dans App.js</li>
                    <li>La route /status existe</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Affichage du succès */}
        {status && !loading && (
          <div className="bg-green-50 border border-green-300 rounded-lg p-4 mb-4">
            <div className="flex items-start">
              <svg className="w-6 h-6 text-green-600 mr-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
              </svg>
              <div className="flex-1">
                <h3 className="text-green-800 font-semibold mb-2">✅ Connexion réussie !</h3>
                <div className="bg-white rounded border border-green-200 p-4">
                  <p className="text-sm text-gray-600 mb-2 font-semibold">Réponse du serveur :</p>
                  <pre className="text-xs bg-gray-50 p-3 rounded overflow-x-auto">
                    {JSON.stringify(status, null, 2)}
                  </pre>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Informations de configuration */}
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
          <h3 className="text-blue-800 font-semibold mb-2">ℹ️ Configuration</h3>
          <div className="text-sm text-blue-700 space-y-1">
            <p><span className="font-semibold">URL Backend:</span> http://localhost:3000</p>
            <p><span className="font-semibold">URL Frontend:</span> http://localhost:5173</p>
            <p><span className="font-semibold">Route testée:</span> /status</p>
          </div>
        </div>

        {/* Bouton pour retester */}
        <button
          onClick={testConnection}
          disabled={loading}
          className="w-full bg-primary-600 hover:bg-primary-700 text-white font-semibold py-3 px-6 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? 'Test en cours...' : '🔄 Retester la connexion'}
        </button>

        {/* Instructions */}
        <div className="mt-6 pt-6 border-t border-gray-200">
          <h4 className="font-semibold text-gray-800 mb-2">📝 Comment lancer les serveurs :</h4>
          <div className="space-y-3 text-sm text-gray-600">
            <div>
              <p className="font-semibold text-gray-700">Backend (Terminal 1) :</p>
              <code className="block bg-gray-100 p-2 rounded mt-1">
                cd backend && node App.js
              </code>
            </div>
            <div>
              <p className="font-semibold text-gray-700">Frontend (Terminal 2) :</p>
              <code className="block bg-gray-100 p-2 rounded mt-1">
                cd frontend && npm run dev
              </code>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TestConnection;
</file>

<file path="sigl_frontend/src/components/ToggleSwitch.jsx">
// sigl_frontend/src/components/ToggleSwitch.jsx
import React from "react";

const ToggleSwitch = ({ checked, onChange, disabled = false }) => {
  const baseClasses =
    "relative inline-flex h-6 w-11 items-center rounded-full transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500";

  const enabledClasses = checked
    ? "bg-primary-600"
    : "bg-gray-200";

  const knobClasses =
    "inline-block h-5 w-5 transform rounded-full bg-white shadow transition-transform duration-200";

  return (
    <button
      type="button"
      role="switch"
      aria-checked={checked}
      disabled={disabled}
      onClick={() => {
        if (!disabled && typeof onChange === "function") {
          onChange();
        }
      }}
      className={`${baseClasses} ${enabledClasses} ${
        disabled ? "opacity-60 cursor-not-allowed" : "cursor-pointer"
      }`}
    >
      <span
        className={`${knobClasses} ${
          checked ? "translate-x-5" : "translate-x-1"
        }`}
      />
    </button>
  );
};

export default ToggleSwitch;
</file>

<file path="sigl_frontend/src/main.jsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './styles/index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="sigl_frontend/src/pages/entretien/DemandeEntretienPage.jsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import bookingService from '../../services/bookingService';
import authService from '../../services/authService';

const DemandeEntretienPage = () => {
    const navigate = useNavigate();
    const currentUser = authService.getCurrentUser();

    const [formData, setFormData] = useState({
        objet: '',
        date: '',
        heureDebut: '',
        heureFin: '',
        participantIds: [currentUser?.id]
    });
    const [errors, setErrors] = useState({});
    const [isLoading, setIsLoading] = useState(false);
    const [availableUsers, setAvailableUsers] = useState([]);
    const [loadingUsers, setLoadingUsers] = useState(true);

    useEffect(() => {
        loadUsers();
    }, []);

    const loadUsers = async () => {
        try {
            const result = await bookingService.getAvailableContacts();
            if (result.success) {
                const filtered = result.users.filter(u => u._id !== currentUser?.id);
                setAvailableUsers(filtered);
            }
        } catch (err) {
            console.error('Erreur:', err);
        } finally {
            setLoadingUsers(false);
        }
    };

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
        if (errors[name]) setErrors(prev => ({ ...prev, [name]: '' }));
    };

    const handleParticipantToggle = (userId) => {
        setFormData(prev => {
            const participants = prev.participantIds.includes(userId)
                ? prev.participantIds.filter(id => id !== userId)
                : [...prev.participantIds, userId];
            return { ...prev, participantIds: participants };
        });
    };

    const validateForm = () => {
        const newErrors = {};
        if (!formData.objet.trim()) newErrors.objet = 'L\'objet est requis';
        if (!formData.date) newErrors.date = 'La date est requise';
        if (!formData.heureDebut) newErrors.heureDebut = 'L\'heure de début est requise';
        if (!formData.heureFin) newErrors.heureFin = 'L\'heure de fin est requise';
        if (formData.heureDebut >= formData.heureFin) {
            newErrors.heureFin = 'L\'heure de fin doit être après l\'heure de début';
        }
        if (formData.participantIds.length < 2) {
            newErrors.participants = 'Sélectionnez au moins un autre participant';
        }
        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!validateForm()) return;

        setIsLoading(true);
        try {
            const debut = `${formData.date}T${formData.heureDebut}:00`;
            const fin = `${formData.date}T${formData.heureFin}:00`;

            await bookingService.demanderEntretien(
                formData.objet,
                debut,
                fin,
                formData.participantIds
            );

            alert('Demande d\'entretien envoyée avec succès !');
            navigate('/entretien/liste');
        } catch (error) {
            setErrors({ submit: error.response?.data?.error || 'Erreur lors de la demande' });
        } finally {
            setIsLoading(false);
        }
    };

    const getRoleLabel = (role) => {
        const labels = {
            'TP': 'Tuteur Pédagogique',
            'MA': 'Maître d\'Apprentissage',
            'PROF': 'Professeur',
            'CA': 'Coordinatrice Alternance',
            'RC': 'Responsable Cursus'
        };
        return labels[role] || role;
    };

    return (
        <div className="min-h-screen bg-gray-50">
            {/* Header */}
            <header className="bg-white shadow-sm border-b border-gray-200">
                <div className="max-w-3xl mx-auto px-4 py-4 flex items-center space-x-3">
                    <button onClick={() => navigate('/dashboard')} className="text-gray-600 hover:text-gray-800">
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                        </svg>
                    </button>
                    <h1 className="text-xl font-bold text-gray-800">💬 Demander un Entretien</h1>
                </div>
            </header>

            {/* Formulaire */}
            <div className="max-w-3xl mx-auto px-4 py-8">
                <div className="bg-white rounded-lg shadow p-6">
                    <form onSubmit={handleSubmit} className="space-y-6">
                        {/* Objet */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1">
                                Objet de l'entretien <span className="text-red-500">*</span>
                            </label>
                            <input
                                type="text"
                                name="objet"
                                value={formData.objet}
                                onChange={handleChange}
                                className={`input-field ${errors.objet ? 'border-red-500' : ''}`}
                                placeholder="Ex: Point semestriel, Suivi de projet, Bilan de compétences..."
                            />
                            {errors.objet && <p className="mt-1 text-xs text-red-600">{errors.objet}</p>}
                        </div>

                        {/* Date et heures */}
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-1">
                                    Date <span className="text-red-500">*</span>
                                </label>
                                <input
                                    type="date"
                                    name="date"
                                    value={formData.date}
                                    onChange={handleChange}
                                    className={`input-field ${errors.date ? 'border-red-500' : ''}`}
                                    min={new Date().toISOString().split('T')[0]}
                                />
                                {errors.date && <p className="mt-1 text-xs text-red-600">{errors.date}</p>}
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-1">
                                    Heure de début <span className="text-red-500">*</span>
                                </label>
                                <input
                                    type="time"
                                    name="heureDebut"
                                    value={formData.heureDebut}
                                    onChange={handleChange}
                                    className={`input-field ${errors.heureDebut ? 'border-red-500' : ''}`}
                                />
                                {errors.heureDebut && <p className="mt-1 text-xs text-red-600">{errors.heureDebut}</p>}
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-1">
                                    Heure de fin <span className="text-red-500">*</span>
                                </label>
                                <input
                                    type="time"
                                    name="heureFin"
                                    value={formData.heureFin}
                                    onChange={handleChange}
                                    className={`input-field ${errors.heureFin ? 'border-red-500' : ''}`}
                                />
                                {errors.heureFin && <p className="mt-1 text-xs text-red-600">{errors.heureFin}</p>}
                            </div>
                        </div>

                        {/* Participants */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">
                                Participants <span className="text-red-500">*</span>
                            </label>
                            {loadingUsers ? (
                                <div className="text-gray-500 text-sm">Chargement des utilisateurs...</div>
                            ) : availableUsers.length === 0 ? (
                                <div className="text-gray-500 text-sm">Aucun tuteur disponible</div>
                            ) : (
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                                    {availableUsers.map(user => (
                                        <label
                                            key={user._id}
                                            className={`flex items-center p-3 border-2 rounded-lg cursor-pointer transition ${
                                                formData.participantIds.includes(user._id)
                                                    ? 'border-primary-500 bg-primary-50'
                                                    : 'border-gray-200 hover:border-gray-300'
                                            }`}
                                        >
                                            <input
                                                type="checkbox"
                                                checked={formData.participantIds.includes(user._id)}
                                                onChange={() => handleParticipantToggle(user._id)}
                                                className="w-4 h-4 text-primary-600 mr-3"
                                            />
                                            <div>
                                                <div className="font-medium text-gray-800">{user.nom}</div>
                                                <div className="text-xs text-gray-500">{getRoleLabel(user.role)}</div>
                                            </div>
                                        </label>
                                    ))}
                                </div>
                            )}
                            {errors.participants && <p className="mt-1 text-xs text-red-600">{errors.participants}</p>}
                        </div>

                        {/* Erreur générale */}
                        {errors.submit && (
                            <div className="bg-red-50 border border-red-200 rounded-lg p-4 text-red-800">
                                {errors.submit}
                            </div>
                        )}

                        {/* Boutons */}
                        <div className="flex justify-between pt-4">
                            <button
                                type="button"
                                onClick={() => navigate('/dashboard')}
                                className="px-6 py-3 border border-gray-300 text-gray-700 rounded-lg font-medium hover:bg-gray-50"
                            >
                                Annuler
                            </button>
                            <button
                                type="submit"
                                disabled={isLoading}
                                className="btn-primary"
                            >
                                {isLoading ? 'Envoi en cours...' : 'Envoyer la demande'}
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    );
};

export default DemandeEntretienPage;
</file>

<file path="sigl_frontend/src/pages/entretien/MesEntretiensPage.jsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import bookingService from '../../services/bookingService';
import authService from '../../services/authService';

const MesEntretiensPage = () => {
    const navigate = useNavigate();
    const currentUser = authService.getCurrentUser();
    const [entretiens, setEntretiens] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        loadEntretiens();
    }, []);

    const loadEntretiens = async () => {
        try {
            setLoading(true);
            const result = await bookingService.getMesEntretiens();
            if (result.success) {
                setEntretiens(result.data || []);
            }
        } catch (err) {
            setError('Erreur lors du chargement des entretiens');
        } finally {
            setLoading(false);
        }
    };

    const handleConfirmer = async (id) => {
        try {
            await bookingService.confirmerEntretien(id);
            loadEntretiens();
        } catch (err) {
            alert('Erreur lors de la confirmation');
        }
    };

    const handleAnnuler = async (id) => {
        if (window.confirm('Voulez-vous vraiment annuler cet entretien ?')) {
            try {
                await bookingService.annulerEntretien(id);
                loadEntretiens();
            } catch (err) {
                alert('Erreur lors de l\'annulation');
            }
        }
    };

    const formatDate = (dateString) => {
        return new Date(dateString).toLocaleDateString('fr-FR', {
            weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
        });
    };

    const formatTime = (dateString) => {
        return new Date(dateString).toLocaleTimeString('fr-FR', {
            hour: '2-digit', minute: '2-digit'
        });
    };

    const getStatutBadge = (statut) => {
        const badges = {
            'DEMANDE': 'bg-yellow-100 text-yellow-800',
            'CONFIRME': 'bg-green-100 text-green-800',
            'ANNULE': 'bg-red-100 text-red-800',
            'TERMINE': 'bg-gray-100 text-gray-800'
        };
        return badges[statut] || 'bg-gray-100 text-gray-800';
    };

    if (loading) {
        return (
            <div className="min-h-screen bg-gray-50 flex items-center justify-center">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600"></div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gray-50">
            {/* Header */}
            <header className="bg-white shadow-sm border-b border-gray-200">
                <div className="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
                    <div className="flex items-center space-x-3">
                        <button onClick={() => navigate('/dashboard')} className="text-gray-600 hover:text-gray-800">
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                            </svg>
                        </button>
                        <h1 className="text-xl font-bold text-gray-800">💬 Mes Entretiens</h1>
                    </div>
                    <button
                        onClick={() => navigate('/entretien/demande')}
                        className="bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded-lg font-medium"
                    >
                        + Demander un entretien
                    </button>
                </div>
            </header>

            {/* Contenu */}
            <div className="max-w-7xl mx-auto px-4 py-8">
                {error && (
                    <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6 text-red-800">
                        {error}
                    </div>
                )}

                {entretiens.length === 0 ? (
                    <div className="bg-white rounded-lg shadow p-12 text-center">
                        <div className="text-6xl mb-4">💬</div>
                        <h3 className="text-lg font-semibold text-gray-700 mb-2">Aucun entretien</h3>
                        <p className="text-gray-600 mb-6">Vous n'avez pas encore d'entretien planifié</p>
                        <button
                            onClick={() => navigate('/entretien/demande')}
                            className="bg-primary-600 hover:bg-primary-700 text-white px-6 py-3 rounded-lg font-medium"
                        >
                            Demander un entretien
                        </button>
                    </div>
                ) : (
                    <div className="space-y-4">
                        {entretiens.map((entretien) => (
                            <div key={entretien._id} className="bg-white rounded-lg shadow p-6">
                                <div className="flex justify-between items-start">
                                    <div className="flex-1">
                                        <div className="flex items-center space-x-3 mb-2">
                                            <h3 className="text-lg font-semibold text-gray-800">
                                                {entretien.objet}
                                            </h3>
                                            <span className={`px-3 py-1 rounded-full text-xs font-medium ${getStatutBadge(entretien.statut)}`}>
                                                {entretien.statut}
                                            </span>
                                        </div>

                                        <div className="space-y-1 text-sm text-gray-600">
                                            <p>📅 {formatDate(entretien.creneau?.debut)}</p>
                                            <p>🕐 {formatTime(entretien.creneau?.debut)} - {formatTime(entretien.creneau?.fin)}</p>
                                            <p>👥 Participants: {entretien.participants?.map(p => p.nom).join(', ')}</p>
                                        </div>
                                    </div>

                                    {/* Actions */}
                                    <div className="flex space-x-2">
                                        {entretien.statut === 'DEMANDE' && (
                                            <>
                                                <button
                                                    onClick={() => handleConfirmer(entretien._id)}
                                                    className="px-4 py-2 bg-green-600 text-white rounded-lg text-sm hover:bg-green-700"
                                                >
                                                    Confirmer
                                                </button>
                                                <button
                                                    onClick={() => handleAnnuler(entretien._id)}
                                                    className="px-4 py-2 bg-red-600 text-white rounded-lg text-sm hover:bg-red-700"
                                                >
                                                    Annuler
                                                </button>
                                            </>
                                        )}
                                        {entretien.statut === 'CONFIRME' && (
                                            <button
                                                onClick={() => handleAnnuler(entretien._id)}
                                                className="px-4 py-2 border border-red-300 text-red-600 rounded-lg text-sm hover:bg-red-50"
                                            >
                                                Annuler
                                            </button>
                                        )}
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>
        </div>
    );
};

export default MesEntretiensPage;
</file>

<file path="sigl_frontend/src/pages/soutenance/GestionSoutenancesPage.jsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import bookingService from '../../services/bookingService';

const GestionSoutenancesPage = () => {
    const navigate = useNavigate();
    const [soutenances, setSoutenances] = useState([]);
    const [loading, setLoading] = useState(true);
    const [showModal, setShowModal] = useState(false);

    useEffect(() => {
        loadSoutenances();
    }, []);

    const loadSoutenances = async () => {
        try {
            setLoading(true);
            const result = await bookingService.getAllSoutenances();
            if (result.success) {
                setSoutenances(result.data || []);
            }
        } catch (err) {
            console.error('Erreur:', err);
        } finally {
            setLoading(false);
        }
    };

    const handleValider = async (id) => {
        try {
            await bookingService.validerSoutenance(id);
            loadSoutenances();
        } catch (err) {
            alert('Erreur lors de la validation');
        }
    };

    const formatDate = (dateString) => {
        return new Date(dateString).toLocaleDateString('fr-FR', {
            day: '2-digit', month: '2-digit', year: 'numeric'
        });
    };

    const formatTime = (dateString) => {
        return new Date(dateString).toLocaleTimeString('fr-FR', {
            hour: '2-digit', minute: '2-digit'
        });
    };

    const getEtatBadge = (etat) => {
        const badges = {
            'PLANIFIEE': 'bg-blue-100 text-blue-800',
            'VALIDEE': 'bg-green-100 text-green-800',
            'TERMINEE': 'bg-gray-100 text-gray-800',
            'ANNULEE': 'bg-red-100 text-red-800'
        };
        return badges[etat] || 'bg-gray-100 text-gray-800';
    };

    if (loading) {
        return (
            <div className="min-h-screen bg-gray-50 flex items-center justify-center">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600"></div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gray-50">
            {/* Header */}
            <header className="bg-white shadow-sm border-b border-gray-200">
                <div className="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
                    <div className="flex items-center space-x-3">
                        <button onClick={() => navigate('/dashboard')} className="text-gray-600 hover:text-gray-800">
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                            </svg>
                        </button>
                        <h1 className="text-xl font-bold text-gray-800">🎓 Gestion des Soutenances</h1>
                    </div>
                    <button
                        onClick={() => navigate('/soutenance/planifier')}
                        className="bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded-lg font-medium"
                    >
                        + Planifier une soutenance
                    </button>
                </div>
            </header>

            {/* Contenu */}
            <div className="max-w-7xl mx-auto px-4 py-8">
                {soutenances.length === 0 ? (
                    <div className="bg-white rounded-lg shadow p-12 text-center">
                        <div className="text-6xl mb-4">🎓</div>
                        <h3 className="text-lg font-semibold text-gray-700 mb-2">Aucune soutenance</h3>
                        <p className="text-gray-600 mb-6">Aucune soutenance n'a été planifiée pour le moment</p>
                        <button
                            onClick={() => navigate('/soutenance/planifier')}
                            className="bg-primary-600 hover:bg-primary-700 text-white px-6 py-3 rounded-lg font-medium"
                        >
                            Planifier une soutenance
                        </button>
                    </div>
                ) : (
                    <div className="bg-white rounded-lg shadow overflow-hidden">
                        <table className="min-w-full divide-y divide-gray-200">
                            <thead className="bg-gray-50">
                            <tr>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Apprenti</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Date</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Heure</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Salle</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">État</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Actions</th>
                            </tr>
                            </thead>
                            <tbody className="bg-white divide-y divide-gray-200">
                            {soutenances.map((soutenance) => (
                                <tr key={soutenance._id} className="hover:bg-gray-50">
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        <div className="font-medium text-gray-900">{soutenance.apprenti?.nom}</div>
                                        <div className="text-sm text-gray-500">{soutenance.apprenti?.email}</div>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-gray-700">
                                        {formatDate(soutenance.dateHeure)}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-gray-700">
                                        {formatTime(soutenance.dateHeure)}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-gray-700">
                                        {soutenance.salle || '-'}
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                            <span className={`px-3 py-1 rounded-full text-xs font-medium ${getEtatBadge(soutenance.etat)}`}>
                                                {soutenance.etat}
                                            </span>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap">
                                        {soutenance.etat === 'PLANIFIEE' && (
                                            <button
                                                onClick={() => handleValider(soutenance._id)}
                                                className="text-green-600 hover:text-green-800 font-medium text-sm"
                                            >
                                                Valider
                                            </button>
                                        )}
                                    </td>
                                </tr>
                            ))}
                            </tbody>
                        </table>
                    </div>
                )}
            </div>
        </div>
    );
};

export default GestionSoutenancesPage;
</file>

<file path="sigl_frontend/src/pages/soutenance/MaSoutenancePage.jsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import bookingService from '../../services/bookingService';

const MaSoutenancePage = () => {
    const navigate = useNavigate();
    const [soutenance, setSoutenance] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        loadSoutenance();
    }, []);

    const loadSoutenance = async () => {
        try {
            setLoading(true);
            const result = await bookingService.getMaSoutenance();
            if (result.success) {
                setSoutenance(result.data);
            }
        } catch (err) {
            setError('Erreur lors du chargement de la soutenance');
        } finally {
            setLoading(false);
        }
    };

    const formatDate = (dateString) => {
        if (!dateString) return '-';
        return new Date(dateString).toLocaleDateString('fr-FR', {
            weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
        });
    };

    const formatTime = (dateString) => {
        if (!dateString) return '-';
        return new Date(dateString).toLocaleTimeString('fr-FR', {
            hour: '2-digit', minute: '2-digit'
        });
    };

    const getEtatBadge = (etat) => {
        const badges = {
            'PLANIFIEE': 'bg-blue-100 text-blue-800',
            'VALIDEE': 'bg-green-100 text-green-800',
            'TERMINEE': 'bg-gray-100 text-gray-800',
            'ANNULEE': 'bg-red-100 text-red-800'
        };
        return badges[etat] || 'bg-gray-100 text-gray-800';
    };

    if (loading) {
        return (
            <div className="min-h-screen bg-gray-50 flex items-center justify-center">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600"></div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gray-50">
            {/* Header */}
            <header className="bg-white shadow-sm border-b border-gray-200">
                <div className="max-w-4xl mx-auto px-4 py-4 flex items-center space-x-3">
                    <button onClick={() => navigate('/dashboard')} className="text-gray-600 hover:text-gray-800">
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                        </svg>
                    </button>
                    <h1 className="text-xl font-bold text-gray-800">🎓 Ma Soutenance</h1>
                </div>
            </header>

            {/* Contenu */}
            <div className="max-w-4xl mx-auto px-4 py-8">
                {error && (
                    <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6 text-red-800">
                        {error}
                    </div>
                )}

                {!soutenance ? (
                    <div className="bg-white rounded-lg shadow p-12 text-center">
                        <div className="text-6xl mb-4">🎓</div>
                        <h3 className="text-lg font-semibold text-gray-700 mb-2">Pas de soutenance planifiée</h3>
                        <p className="text-gray-600">
                            Votre soutenance n'a pas encore été planifiée par la coordination.
                        </p>
                    </div>
                ) : (
                    <div className="bg-white rounded-lg shadow overflow-hidden">
                        {/* En-tête */}
                        <div className="bg-gradient-to-r from-primary-600 to-primary-800 text-white p-6">
                            <div className="flex justify-between items-start">
                                <div>
                                    <h2 className="text-2xl font-bold mb-2">Soutenance de fin d'études</h2>
                                    <p className="text-primary-100">
                                        {formatDate(soutenance.dateHeure)}
                                    </p>
                                </div>
                                <span className={`px-4 py-2 rounded-full text-sm font-medium ${getEtatBadge(soutenance.etat)}`}>
                                    {soutenance.etat}
                                </span>
                            </div>
                        </div>

                        {/* Détails */}
                        <div className="p-6 space-y-6">
                            {/* Date et lieu */}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div className="flex items-start space-x-4">
                                    <div className="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center flex-shrink-0">
                                        <svg className="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                        </svg>
                                    </div>
                                    <div>
                                        <h3 className="font-semibold text-gray-800">Date et heure</h3>
                                        <p className="text-gray-600">{formatDate(soutenance.dateHeure)}</p>
                                        <p className="text-gray-500">{formatTime(soutenance.dateHeure)}</p>
                                    </div>
                                </div>

                                <div className="flex items-start space-x-4">
                                    <div className="w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center flex-shrink-0">
                                        <svg className="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                                        </svg>
                                    </div>
                                    <div>
                                        <h3 className="font-semibold text-gray-800">Salle</h3>
                                        <p className="text-gray-600">{soutenance.salle || 'À définir'}</p>
                                    </div>
                                </div>
                            </div>

                            {/* Jury */}
                            <div>
                                <h3 className="font-semibold text-gray-800 mb-3">👥 Composition du jury</h3>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                    {soutenance.jury?.professeurs?.map((prof, index) => (
                                        <div key={prof._id || index} className="bg-gray-50 rounded-lg p-3 flex items-center space-x-3">
                                            <div className="w-10 h-10 bg-primary-100 rounded-full flex items-center justify-center">
                                                <span className="text-primary-600 font-semibold">
                                                    {prof.nom?.charAt(0) || 'P'}
                                                </span>
                                            </div>
                                            <div>
                                                <p className="font-medium text-gray-800">{prof.nom}</p>
                                                <p className="text-xs text-gray-500">{prof.email}</p>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
};

export default MaSoutenancePage;
</file>

<file path="sigl_frontend/src/services/bookingService.js">
import api from './Api';

const bookingService = {
    // === ENTRETIENS ===
    demanderEntretien: async (objet, debut, fin, participantIds) => {
        const response = await api.post('/entretiens', { objet, debut, fin, participantIds });
        return response.data;
    },
    getMesEntretiens: async () => {
        const response = await api.get('/entretiens/mes-entretiens');
        return response.data;
    },
    confirmerEntretien: async (entretienId) => {
        const response = await api.put(`/entretiens/${entretienId}/confirmer`);
        return response.data;
    },
    annulerEntretien: async (entretienId) => {
        const response = await api.put(`/entretiens/${entretienId}/annuler`);
        return response.data;
    },

    // === SOUTENANCES ===
    planifierSoutenance: async (apprentiId, dateHeure, salle, professeurIds) => {
        const response = await api.post('/soutenances', { apprentiId, dateHeure, salle, professeurIds });
        return response.data;
    },
    getMaSoutenance: async () => {
        const response = await api.get('/soutenances/ma-soutenance');
        return response.data;
    },
    getAllSoutenances: async () => {
        const response = await api.get('/soutenances');
        return response.data;
    },
    validerSoutenance: async (soutenanceId) => {
        const response = await api.put(`/soutenances/${soutenanceId}/valider`);
        return response.data;
    },

    // === UTILISATEURS (pour sélection participants) ===
    getAvailableContacts: async () => {
        const response = await api.get('/users/available-contacts');
        return response.data;
    }
};

export default bookingService;
</file>

<file path="sigl_frontend/src/styles/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-50 font-sans antialiased;
  }
}

@layer components {
  .input-field {
    @apply w-full bg-transparent placeholder:text-slate-400 text-slate-700 text-sm border border-slate-300 rounded-md px-4 py-3 transition duration-300 focus:outline-none focus:border-primary-500 focus:ring-2 focus:ring-primary-500 focus:ring-opacity-50 hover:border-slate-400 shadow-sm;
  }
  
  .btn-primary {
    @apply w-full rounded-md bg-primary-600 py-3 px-4 text-center text-sm font-semibold text-white transition-all shadow-md hover:shadow-lg hover:bg-primary-700 focus:bg-primary-700 focus:shadow-none active:bg-primary-800 disabled:pointer-events-none disabled:opacity-50;
  }
}
</file>

<file path="sigl_frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
    "./public/index.html",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          100: '#dbeafe',
          200: '#bfdbfe',
          300: '#93c5fd',
          400: '#60a5fa',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
          800: '#1e40af',
          900: '#1e3a8a',
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path="sigl_frontend/vite.config.js">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    open: true
  }
});
</file>

<file path="API_test/Booking/Demander un entretien.bru">
meta {
  name: Demander un entretien
  type: http
  seq: 1
}

post {
  url: http://localhost:3000/api/entretiens
  body: json
  auth: inherit
}

headers {
  Content-Type: application/json
  Authorization: Bearer TOKEN
}

body:json {
  {
    "objet": "Point semestriel",
    "debut": "2025-12-20T14:00:00",
    "fin": "2025-12-20T15:00:00",
    "participantIds": [
      "691ed0cc5f7590986191b244",
      "6964af53ba7f2d8c6fa2afa8"
    ]
  }
}

settings {
  encodeUrl: false
  timeout: 0
}
</file>

<file path="API_test/User/Get User Profile - Valid ID.bru">
meta {
  name: Get User Profile - Valid ID
  type: http
  seq: 6
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{testUserId}}
  body: none
  auth: inherit
}
</file>

<file path="database/database/utilisateurs.metadata.json">
{
  "options": {
    "validator": {
      "$jsonSchema": {
        "bsonType": "object",
        "required": ["nom", "email", "role"],
        "properties": {
          "_id": { "bsonType": "objectId" },

          "nom": {
            "bsonType": "string",
            "minLength": { "$numberInt": "2" }
          },
          "email": {
            "bsonType": "string",
            "pattern": "^.+@.+\\.+$"
          },

          "role": {
            "enum": ["APPRENTI", "MA", "TP", "CA", "RC", "PROF", "ADMIN"]
          },

          
          "firstName": { "bsonType": ["string", "null"] },
          "lastName": { "bsonType": ["string", "null"] },
          "avatar": { "bsonType": ["string", "null"] },

          
          "mfaEnabled": { "bsonType": ["bool", "null"] },
          "mfaMethod": { "bsonType": ["string", "null"] },
          "mfaCode": { "bsonType": ["string", "null"] },
          "mfaCodeExpiresAt": { "bsonType": ["date", "null"] },
          "phone": { "bsonType": ["string", "null"] },
          "isEmailVerified": { "bsonType": ["bool", "null"] },

          
          "idApprenti": { "bsonType": ["objectId", "null"] },
          "numero": { "bsonType": ["string", "null"] },
          "promotion": { "bsonType": ["objectId", "null"] },
          "entreprise": { "bsonType": ["objectId", "null"] },

          "fonction": { "bsonType": ["string", "null"] },
          "specialite": { "bsonType": ["string", "null"] },
          "service": { "bsonType": ["string", "null"] },
          "departement": { "bsonType": ["string", "null"] },
          "grade": { "bsonType": ["string", "null"] },
          "habilitations": { "bsonType": ["string", "null"] },

          
          "createdAt": { "bsonType": ["date", "null"] },
          "updatedAt": { "bsonType": ["date", "null"] }
        },
        "additionalProperties": false
      }
    },
    "validationLevel": "moderate",
    "validationAction": "error"
  },
  "indexes": [
    {
      "v": { "$numberInt": "2" },
      "key": { "_id": { "$numberInt": "1" } },
      "name": "_id_"
    },
    {
      "v": { "$numberInt": "2" },
      "key": { "email": { "$numberInt": "1" } },
      "name": "email_1",
      "unique": true
    },
    {
      "v": { "$numberInt": "2" },
      "key": { "role": { "$numberInt": "1" } },
      "name": "role_1"
    }
  ],
  "uuid": "2279db17d9b64097aedeb1a410814a6b",
  "collectionName": "utilisateurs",
  "type": "collection"
}
</file>

<file path="sigl_backend/.env">
# JWT Configuration
JWT_SECRET=your-very-strong-secret-key-min-32-chars-for-access-tokens-2024
JWT_REFRESH_SECRET=another-strong-secret-for-refresh-tokens-must-be-different-2024

# Bcrypt Configuration
BCRYPT_SALT_ROUNDS=10

# Application Configuration
NODE_ENV=development
PORT=3000

# Database Configuration
MONGODB_URI=mongodb://localhost:27017/database

# Security Configuration
MAX_LOGIN_ATTEMPTS=5
ACCOUNT_LOCK_TIME=900000

# SMTP pour l'envoi des codes MFA
SMTP_HOST=sandbox.smtp.mailtrap.io   # ou ton host SMTP
SMTP_PORT=2525                      # ou 587 / 465 selon le provider
SMTP_USER=cc40f8c68deca9
SMTP_PASS=bb9da2e2951b72
SMTP_FROM="SKILIO" <no-reply@skilio.local>

FRONTEND_URL=http://localhost:5173
</file>

<file path="sigl_backend/app/auth/auth.controller.js">
// sigl_backend/app/auth/auth.controller.js
const authService = require('./auth.service');
const authRepository = require('./auth.repository');
const MfaService = require('./mfa.service');

class AuthController {
  // ------------------ REGISTER ------------------
  async register(req, res) {
    try {
      const { email, password, role } = req.body;

      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: 'Email and password are required',
          error: 'MISSING_FIELDS',
        });
      }

      const existing = await authRepository.findAuthByEmail(email);
      if (existing) {
        return res.status(409).json({
          success: false,
          message: 'User already exists with this email',
          error: 'USER_ALREADY_EXISTS',
        });
      }

      const user = await authService.createUserWithCredentials(
        email,
        password,
        role
      );
      console.log(`User registered: ${email} - ${new Date().toISOString()}`);

      res.status(201).json({
        success: true,
        message: 'User registered successfully',
        data: {
          user: {
            id: user._id,
            email: user.email,
            role: user.role,
          },
        },
      });
    } catch (error) {
      console.error('Register error:', error.message);
      res.status(500).json({
        success: false,
        message: 'Internal server error during registration',
        error: 'REGISTER_ERROR',
      });
    }
  }

  // ------------------ LOGIN + MFA (étape 1) ------------------
  async login(req, res) {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: 'Email and password are required',
          error: 'MISSING_FIELDS',
        });
      }

      const authRecord = await authRepository.findAuthByEmail(email);
      if (!authRecord || !authRecord.user) {
        console.log(
          `Failed login attempt for email: ${email} - User not found - ${new Date().toISOString()}`
        );
        return res.status(401).json({
          success: false,
          message: 'Invalid email or password',
          error: 'INVALID_CREDENTIALS',
        });
      }

      // Vérif lock
      let accountLocked = false;
      try {
        if (authRepository.isAccountLocked) {
          accountLocked = await authRepository.isAccountLocked(
            authRecord.userId
          );
        }
      } catch (lockErr) {
        console.error(
          'Check account lock failed:',
          lockErr.message || lockErr
        );
      }

      if (accountLocked) {
        console.log(
          `Login blocked: account locked for user ${authRecord.user.email} - ${new Date().toISOString()}`
        );
        return res.status(403).json({
          success: false,
          message:
            'Votre compte est temporairement verrouillé suite à plusieurs tentatives de connexion échouées.',
          error: 'ACCOUNT_LOCKED',
        });
      }

      // Vérif mot de passe
      const isPasswordValid = await authService.comparePassword(
        password,
        authRecord.passwordHash
      );

      if (!isPasswordValid) {
        await authRepository.incrementFailedAttempts(authRecord.userId);

        console.log(
          `Failed login attempt for email: ${email} - Invalid password - ${new Date().toISOString()}`
        );

        return res.status(401).json({
          success: false,
          message: 'Invalid email or password',
          error: 'INVALID_CREDENTIALS',
        });
      }

      // Reset tentatives
      await authRepository.resetFailedAttempts(authRecord.userId);

      // MFA activé ?
      if (authRecord.user.mfaEnabled) {
        try {
          const delivery = await MfaService.createAndSendMfaCode(
            authRecord.user
          );

          console.log(
            `MFA code sent via ${delivery} for user ${authRecord.user.email} - ${new Date().toISOString()}`
          );

          return res.status(200).json({
            success: true,
            message: 'MFA code sent',
            mfaRequired: true,
            data: {
              userId: authRecord.user._id,
              deliveryMethod: delivery,
              email: authRecord.user.email,
            },
          });
        } catch (mfaError) {
          console.error('MFA send code error:', mfaError);
          return res.status(500).json({
            success: false,
            message: 'Unable to send MFA code',
            error: 'MFA_SEND_ERROR',
          });
        }
      }

      // MFA désactivé → login normal
      const tokens = authService.generateTokenPair(
        authRecord.userId.toString(),
        authRecord.user.email,
        authRecord.user.role
      );

      await authService.storeRefreshToken(
        authRecord.userId,
        tokens.refreshToken
      );

      console.log(
        `Successful login: ${email} (${authRecord.user.role}) - ${new Date().toISOString()}`
      );

      res.status(200).json({
        success: true,
        message: 'Login successful',
        data: {
          user: {
            id: authRecord.user._id,
            nom: authRecord.user.nom,
            email: authRecord.user.email,
            role: authRecord.user.role,
          },
          tokens: {
            accessToken: tokens.accessToken,
            refreshToken: tokens.refreshToken,
            tokenType: tokens.tokenType,
            expiresIn: tokens.expiresIn,
          },
        },
      });
    } catch (error) {
      console.error('Login error:', error.message);
      res.status(500).json({
        success: false,
        message: 'Internal server error during login',
        error: 'LOGIN_ERROR',
      });
    }
  }

  // ------------------ MFA (étape 2) ------------------
  async verifyMfaCode(req, res) {
    try {
      const { userId, code } = req.body;

      if (!code) {
        return res.status(400).json({
          success: false,
          message: 'Code is required',
          error: 'MFA_MISSING_CODE',
        });
      }

      // Vérification du code (on ne se fie qu’au code, pas à userId)
      const token = await MfaService.verifyMfaCode(code);
      if (!token) {
        console.log(
          `Invalid MFA code "${code}" (userId reçu: ${userId || 'null'}) - ${new Date().toISOString()}`
        );
        return res.status(400).json({
          success: false,
          message: 'Invalid or expired MFA code',
          error: 'MFA_INVALID_CODE',
        });
      }

      const effectiveUserId = token.user.toString();

      // ⚠️ findAuthByUserId renvoie un doc avec userId *peuplé*,
      // donc la structure est : { userId: { _id, nom, email, role }, ... }
      const authRecord = await authRepository.findAuthByUserId(
        effectiveUserId
      );

      if (!authRecord || !authRecord.userId) {
        return res.status(404).json({
          success: false,
          message: 'User authentication record not found',
          error: 'AUTH_RECORD_NOT_FOUND',
        });
      }

      const user = authRecord.userId; // doc Utilisateur populé

      const tokens = authService.generateTokenPair(
        user._id.toString(),
        user.email,
        user.role
      );

      await authService.storeRefreshToken(
        authRecord.userId,
        tokens.refreshToken
      );

      console.log(
        `MFA verified and login completed for user ${user.email} - ${new Date().toISOString()}`
      );

      return res.status(200).json({
        success: true,
        message: 'MFA verification successful',
        data: {
          user: {
            id: user._id,
            nom: user.nom,
            email: user.email,
            role: user.role,
          },
          tokens: {
            accessToken: tokens.accessToken,
            refreshToken: tokens.refreshToken,
            tokenType: tokens.tokenType,
            expiresIn: tokens.expiresIn,
          },
        },
      });
    } catch (error) {
      console.error('MFA verify error:', error.message);
      return res.status(500).json({
        success: false,
        message: 'Internal server error during MFA verification',
        error: 'MFA_VERIFY_ERROR',
      });
    }
  }

  // ------------------ LOGOUT ------------------
  async logout(req, res) {
    try {
      const { userId } = req.user;
      await authService.revokeRefreshToken(userId);

      console.log(
        `User logout: ${req.user.email} - ${new Date().toISOString()}`
      );

      res.status(200).json({
        success: true,
        message: 'Logout successful',
      });
    } catch (error) {
      console.error('Logout error:', error.message);
      res.status(500).json({
        success: false,
        message: 'Internal server error during logout',
        error: 'LOGOUT_ERROR',
      });
    }
  }

  // ------------------ REFRESH TOKEN ------------------
  async refreshAccessToken(req, res) {
    try {
      const authHeader = req.headers.authorization;

      if (!authHeader) {
        return res.status(401).json({
          success: false,
          message: 'Refresh token is required',
          error: 'MISSING_REFRESH_TOKEN',
        });
      }

      let refreshToken;
      try {
        refreshToken = authService.extractBearerToken(authHeader);
      } catch (error) {
        return res.status(401).json({
          success: false,
          message: 'Invalid authorization header format',
          error: 'INVALID_HEADER_FORMAT',
        });
      }

      let decoded;
      try {
        decoded = authService.verifyToken(refreshToken, 'refresh');
      } catch (error) {
        return res.status(401).json({
          success: false,
          message: 'Invalid or expired refresh token',
          error: 'INVALID_REFRESH_TOKEN',
        });
      }

      const authRecord = await authRepository.findAuthByRefreshToken(
        refreshToken
      );
      if (!authRecord || !authRecord.userId) {
        return res.status(401).json({
          success: false,
          message: 'Refresh token not found or revoked',
          error: 'REFRESH_TOKEN_REVOKED',
        });
      }

      const user = authRecord.userId;

      const newAccessToken = authService.generateAccessToken(
        user._id.toString(),
        user.email,
        user.role
      );

      res.status(200).json({
        success: true,
        message: 'Access token refreshed successfully',
        data: {
          accessToken: newAccessToken,
          tokenType: 'Bearer',
          expiresIn: 3600,
        },
      });
    } catch (error) {
      console.error('Refresh token error:', error.message);
      res.status(500).json({
        success: false,
        message: 'Internal server error during token refresh',
        error: 'REFRESH_TOKEN_ERROR',
      });
    }
  }
}

module.exports = new AuthController();
</file>

<file path="sigl_backend/app/auth/auth.model.js">
const mongoose = require('mongoose');

/**
 * Authentication Schema
 * Stores authentication credentials separately from user profiles
 * Includes security features like account locking and failed attempt tracking
 */
const authSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Utilisateur',
        required: true,
        unique: true,
        index: true
    },
    passwordHash: {
        type: String,
        required: true,
        minlength: 60 // bcrypt hash length
    },
    refreshToken: {
        type: String,
        default: null,
    },
    isActive: {
        type: Boolean,
        default: true,
        required: true
    },
    lastLogin: {
        type: Date,
        default: null
    },
    failedLoginAttempts: {
        type: Number,
        default: 0,
        min: 0
    },
    accountLockedUntil: {
        type: Date,
        default: null
    }
}, {
    timestamps: true,
    collection: 'auth_credentials'
});

// Compound index for performance optimization
authSchema.index({ userId: 1, isActive: 1 });
authSchema.index({ refreshToken: 1 }, { sparse: true });

/**
 * Virtual property to check if account is currently locked
 */
authSchema.virtual('isLocked').get(function() {
    return !!(this.accountLockedUntil && this.accountLockedUntil > Date.now());
});

/**
 * Method to check if account should be locked based on failed attempts
 * @returns {boolean} True if account should be locked
 */
authSchema.methods.shouldLockAccount = function() {
    const maxAttempts = parseInt(process.env.MAX_LOGIN_ATTEMPTS) || 5;
    return this.failedLoginAttempts >= maxAttempts;
};

/**
 * Method to lock the account for a specified duration
 */
authSchema.methods.lockAccount = function() {
    const lockTime = parseInt(process.env.ACCOUNT_LOCK_TIME) || 900000; // 15 minutes default
    this.accountLockedUntil = Date.now() + lockTime;
    this.failedLoginAttempts = 0; // Reset attempts after locking
};

/**
 * Method to increment failed login attempts
 */
authSchema.methods.incrementFailedAttempts = function() {
    // If account was previously locked and lock time has expired, reset attempts
    if (this.accountLockedUntil && this.accountLockedUntil < Date.now()) {
        this.failedLoginAttempts = 1;
        this.accountLockedUntil = null;
    } else {
        this.failedLoginAttempts += 1;
    }
    
    // Lock account if max attempts reached
    if (this.shouldLockAccount()) {
        this.lockAccount();
    }
};

/**
 * Method to reset failed login attempts after successful login
 */
authSchema.methods.resetFailedAttempts = function() {
    this.failedLoginAttempts = 0;
    this.accountLockedUntil = null;
    this.lastLogin = new Date();
};

/**
 * Method to safely return auth data without sensitive information
 */
authSchema.methods.toSafeObject = function() {
    const authObj = this.toObject();
    delete authObj.passwordHash;
    delete authObj.refreshToken;
    return authObj;
};

/**
 * Pre-save middleware to ensure security constraints
 */
authSchema.pre('save', function(next) {
    // Ensure passwordHash is never empty
    if (!this.passwordHash || this.passwordHash.length < 60) {
        return next(new Error('Invalid password hash format'));
    }
    
    // Validate userId is a valid ObjectId
    if (!mongoose.Types.ObjectId.isValid(this.userId)) {
        return next(new Error('Invalid userId format'));
    }
    
    next();
});

/**
 * Static method to find auth record by user ID with user details
 * @param {string} userId - The user ID to search for
 * @returns {Promise} Auth record with populated user data
 */
authSchema.statics.findByUserIdWithUser = function(userId) {
    return this.findOne({ userId, isActive: true })
        .populate('userId', 'nom email role')
        .exec();
};

/**
 * Static method to find auth record by email (requires join with user collection)
 * @param {string} email - The email to search for
 * @returns {Promise} Auth record with user data
 */
authSchema.statics.findByEmail = function(email) {
    return this.aggregate([
        {
            $lookup: {
                from: 'utilisateurs',
                localField: 'userId',
                foreignField: '_id',
                as: 'user'
            }
        },
        {
            $unwind: '$user'
        },
        {
            $match: {
                'user.email': email.toLowerCase(),
                isActive: true
            }
        }
    ]);
};

const Auth = mongoose.model('Auth', authSchema);

module.exports = Auth;
</file>

<file path="sigl_backend/app/auth/auth.repository.js">
const mongoose = require('mongoose');
const Auth = require('./auth.model');
const Utilisateur = require('../common/models/user.model');

/**
 * Authentication Repository
 * Handles all database operations for authentication credentials
 */
class AuthRepository {
  /**
   * Create a new authentication record for a user
   * @param {string} userId - User's unique identifier
   * @param {string} hashedPassword - Bcrypt hashed password
   * @returns {Promise<Object>} Created auth record (safe object without sensitive data)
   * @throws {Error} If creation fails
   */
  async createAuthRecord(userId, hashedPassword) {
    try {
      // Validate inputs
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        throw new Error('Valid userId is required');
      }

      if (
        !hashedPassword ||
        typeof hashedPassword !== 'string' ||
        hashedPassword.length < 60
      ) {
        throw new Error('Valid hashed password is required');
      }

      // Check if user exists
      const userExists = await Utilisateur.findById(userId);
      if (!userExists) {
        throw new Error('User not found');
      }

      // Check if auth record already exists
      const existingAuth = await Auth.findOne({ userId });
      if (existingAuth) {
        throw new Error(
          'Authentication record already exists for this user'
        );
      }

      const authRecord = new Auth({
        userId,
        passwordHash: hashedPassword,
        isActive: true,
        failedLoginAttempts: 0,
      });

      const savedAuth = await authRecord.save();
      return savedAuth.toSafeObject();
    } catch (error) {
      console.error('Create auth record failed:', error.message);
      throw new Error(
        `Failed to create authentication record: ${error.message}`
      );
    }
  }

  /**
   * Find authentication record by user ID
   * @param {string} userId - User's unique identifier
   * @returns {Promise<Object|null>} Auth record or null if not found
   * @throws {Error} If query fails
   */
  async findAuthByUserId(userId) {
    try {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        throw new Error('Valid userId is required');
      }

      const authRecord = await Auth.findOne({
        userId,
        isActive: true,
      }).populate('userId', 'nom email role');

      return authRecord;
    } catch (error) {
      console.error('Find auth by userId failed:', error.message);
      throw new Error('Failed to find authentication record by userId');
    }
  }

  /**
   * Find authentication record by email (requires join with user collection)
   * @param {string} email - User's email address
   * @returns {Promise<Object|null>} Auth record with user data or null if not found
   * @throws {Error} If query fails
   */
  async findAuthByEmail(email) {
    try {
      if (!email || typeof email !== 'string') {
        throw new Error('Valid email is required');
      }

      const results = await Auth.aggregate([
        {
          $lookup: {
            from: 'utilisateurs',
            localField: 'userId',
            foreignField: '_id',
            as: 'user',
          },
        },
        { $unwind: '$user' },
        {
          $match: {
            'user.email': email.toLowerCase(),
            isActive: true,
          },
        },
        {
          $limit: 1,
        },
      ]);

      return results[0] || null;
    } catch (error) {
      console.error('Find auth by email failed:', error.message);
      throw new Error('Failed to find authentication record by email');
    }
  }

  /**
   * Update password for a user
   * @param {string} userId - User's unique identifier
   * @param {string} newHashedPassword - New bcrypt hashed password
   * @returns {Promise<Object>} Updated auth record (safe object)
   * @throws {Error} If update fails
   */
  async updatePassword(userId, newHashedPassword) {
    try {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        throw new Error('Valid userId is required');
      }

      if (
        !newHashedPassword ||
        typeof newHashedPassword !== 'string' ||
        newHashedPassword.length < 60
      ) {
        throw new Error('Valid hashed password is required');
      }

      const authRecord = await Auth.findOneAndUpdate(
        { userId, isActive: true },
        {
          passwordHash: newHashedPassword,
          $unset: {
            refreshToken: 1, // Clear refresh token on password change
            accountLockedUntil: 1, // Clear any account lock
          },
          failedLoginAttempts: 0, // Reset failed attempts
        },
        { new: true }
      );

      if (!authRecord) {
        throw new Error('Authentication record not found');
      }

      return authRecord.toSafeObject();
    } catch (error) {
      console.error('Update password failed:', error.message);
      throw new Error(`Failed to update password: ${error.message}`);
    }
  }

  /**
   * Update refresh token for a user
   * @param {string} userId - User's unique identifier
   * @param {string} refreshToken - New refresh token (or null/undefined to clear)
   * @returns {Promise<Object>} Updated auth record (safe object)
   * @throws {Error} If update fails
   */
  async updateRefreshToken(userId, refreshToken) {
    try {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        throw new Error('Valid userId is required');
      }

      const updateData = refreshToken
        ? { refreshToken }
        : { $unset: { refreshToken: 1 } };

      const authRecord = await Auth.findOneAndUpdate(
        { userId, isActive: true },
        updateData,
        { new: true }
      );

      if (!authRecord) {
        throw new Error('Authentication record not found');
      }

      return authRecord.toSafeObject();
    } catch (error) {
      console.error('Update refresh token failed:', error.message);
      throw new Error('Failed to update refresh token');
    }
  }

  /**
   * Increment failed login attempts for a user
   * @param {string} userId - User's unique identifier
   * @returns {Promise<Object>} Updated auth record with incremented attempts
   * @throws {Error} If update fails
   */
  async incrementFailedAttempts(userId) {
    try {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        throw new Error('Valid userId is required');
      }

      const authRecord = await Auth.findOne({ userId, isActive: true });

      if (!authRecord) {
        throw new Error('Authentication record not found');
      }

      // Use the model method to handle the logic
      authRecord.incrementFailedAttempts();
      const updatedRecord = await authRecord.save();

      return updatedRecord.toSafeObject();
    } catch (error) {
      console.error('Increment failed attempts failed:', error.message);
      throw new Error('Failed to increment failed login attempts');
    }
  }

  /**
   * Reset failed login attempts after successful login
   * @param {string} userId - User's unique identifier
   * @returns {Promise<Object>} Updated auth record with reset attempts
   * @throws {Error} If update fails
   */
  async resetFailedAttempts(userId) {
    try {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        throw new Error('Valid userId is required');
      }

      const authRecord = await Auth.findOne({ userId, isActive: true });

      if (!authRecord) {
        throw new Error('Authentication record not found');
      }

      // Use the model method to handle the logic
      authRecord.resetFailedAttempts();
      const updatedRecord = await authRecord.save();

      return updatedRecord.toSafeObject();
    } catch (error) {
      console.error('Reset failed attempts failed:', error.message);
      throw new Error('Failed to reset failed login attempts');
    }
  }

  /**
   * Lock user account until specified time
   * @param {string} userId - User's unique identifier
   * @param {Date} lockUntilTime - Time until which account should be locked
   * @returns {Promise<Object>} Updated auth record with lock information
   * @throws {Error} If update fails
   */
  async lockAccount(userId, lockUntilTime) {
    try {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        throw new Error('Valid userId is required');
      }

      if (!lockUntilTime || !(lockUntilTime instanceof Date)) {
        throw new Error('Valid lock until time is required');
      }

      const authRecord = await Auth.findOneAndUpdate(
        { userId, isActive: true },
        {
          accountLockedUntil: lockUntilTime,
          failedLoginAttempts: 0, // Reset attempts when locking
        },
        { new: true }
      );

      if (!authRecord) {
        throw new Error('Authentication record not found');
      }

      return authRecord.toSafeObject();
    } catch (error) {
      console.error('Lock account failed:', error.message);
      throw new Error('Failed to lock user account');
    }
  }

  /**
   * Check if user account is currently locked
   * ⚠ IMPORTANT : ne doit jamais faire crasher le serveur
   * @param {string|Object} userIdOrAuth - User's id OR un authRecord
   * @returns {Promise<boolean>} True if account is locked, false otherwise
   */
  async isAccountLocked(userIdOrAuth) {
    try {
      let userId = null;

      // On accepte soit un string, soit un document Auth
      if (typeof userIdOrAuth === 'string') {
        userId = userIdOrAuth;
      } else if (userIdOrAuth && typeof userIdOrAuth === 'object') {
        if (userIdOrAuth.userId) {
          userId = userIdOrAuth.userId.toString();
        } else if (userIdOrAuth._id) {
          userId = userIdOrAuth._id.toString();
        }
      }

      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        console.warn(
          '[AuthRepository.isAccountLocked] called with invalid userId, returning false'
        );
        return false;
      }

      const authRecord = await Auth.findOne({ userId, isActive: true });

      if (!authRecord) {
        // Pas d’enregistrement => on considère non verrouillé
        return false;
      }

      return !!authRecord.isLocked;
    } catch (error) {
      console.error(
        '[AuthRepository.isAccountLocked] Check account lock failed:',
        error.message
      );
      // On ne jette plus d'erreur ici pour éviter les UNHANDLED_REJECTION
      return false;
    }
  }

  /**
   * Deactivate authentication record (soft delete)
   * @param {string} userId - User's unique identifier
   * @returns {Promise<Object>} Deactivated auth record
   * @throws {Error} If deactivation fails
   */
  async deactivateAuth(userId) {
    try {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        throw new Error('Valid userId is required');
      }

      const authRecord = await Auth.findOneAndUpdate(
        { userId, isActive: true },
        {
          isActive: false,
          $unset: { refreshToken: 1 }, // Clear refresh token on deactivation
        },
        { new: true }
      );

      if (!authRecord) {
        throw new Error('Authentication record not found');
      }

      return authRecord.toSafeObject();
    } catch (error) {
      console.error('Deactivate auth failed:', error.message);
      throw new Error('Failed to deactivate authentication record');
    }
  }

  /**
   * Find authentication record by refresh token
   * @param {string} refreshToken - Refresh token to search for
   * @returns {Promise<Object|null>} Auth record or null if not found
   * @throws {Error} If query fails
   */
  async findAuthByRefreshToken(refreshToken) {
    try {
      if (!refreshToken || typeof refreshToken !== 'string') {
        throw new Error('Valid refresh token is required');
      }

      const authRecord = await Auth.findOne({
        refreshToken,
        isActive: true,
      }).populate('userId', 'nom email role');

      return authRecord;
    } catch (error) {
      console.error('Find auth by refresh token failed:', error.message);
      throw new Error('Failed to find authentication record by refresh token');
    }
  }
}

module.exports = new AuthRepository();
</file>

<file path="sigl_backend/app/auth/auth.routes.js">
// sigl_backend/app/auth/auth.routes.js

const express = require('express');
const router = express.Router();

const authController = require('./auth.controller');
const { authenticate } = require('../middleware/authenticate');

// ---------------------------------------------------------------------------
// AUTH DE BASE + MFA (login)
// ---------------------------------------------------------------------------

/**
 * POST /api/auth/login
 * Étape 1 : login (peut retourner mfaRequired = true)
 */
router.post('/login', (req, res) => authController.login(req, res));

/**
 * POST /api/auth/mfa/verify
 * Étape 2 : vérification du code MFA
 */
router.post('/mfa/verify', (req, res) => authController.verifyMfaCode(req, res));

// ---------------------------------------------------------------------------
// SESSION (logout, refresh)
// ---------------------------------------------------------------------------

/**
 * POST /api/auth/logout
 * Nécessite un access token
 */
router.post('/logout', authenticate, (req, res) => authController.logout(req, res));

/**
 * POST /api/auth/refresh
 * Utilise le refresh token dans l’Authorization header
 */
router.post('/refresh', (req, res) => authController.refreshAccessToken(req, res));

// ---------------------------------------------------------------------------
// MOT DE PASSE
// ---------------------------------------------------------------------------

/**
 * POST /api/auth/change-password
 */
router.post('/change-password', authenticate, (req, res) =>
  authController.changePassword(req, res)
);

/**
 * POST /api/auth/request-reset
 */
router.post('/request-reset', (req, res) =>
  authController.requestPasswordReset(req, res)
);

/**
 * POST /api/auth/reset-password
 */
router.post('/reset-password', (req, res) =>
  authController.resetPassword(req, res)
);

// ---------------------------------------------------------------------------
// PARAMÈTRES MFA POUR LA PAGE PROFIL (optionnel mais prévu dans ton code)
// ---------------------------------------------------------------------------

/**
 * GET /api/auth/mfa/status
 * Retourne le statut MFA + méthode préférée de l’utilisateur connecté
 */
router.get('/mfa/status', authenticate, (req, res) =>
  authController.getMfaStatus(req, res)
);

/**
 * PUT /api/auth/mfa/settings
 * Met à jour la méthode MFA préférée (email / sms / etc.)
 */
router.put('/mfa/settings', authenticate, (req, res) =>
  authController.updateMfaSettings(req, res)
);

module.exports = router;
</file>

<file path="sigl_backend/app/calendar/controller.js">
const events = require('./data');

/**
 * Contrôleur pour les événements du calendrier
 * Gère la logique métier pour l'API calendrier
 */

/**
 * GET /api/calendar/events
 * Récupère tous les événements du calendrier
 */
const getAllEvents = (req, res) => {
    try {
        console.log(`📅 Récupération de tous les événements - IP: ${req.ip}`);
        
        // Optionnel: filtrage par catégorie si fourni en query parameter
        const { category } = req.query;
        
        let filteredEvents = events;
        
        if (category) {
            filteredEvents = events.filter(event => 
                event.category.toLowerCase() === category.toLowerCase()
            );
            console.log(`🔍 Filtrage par catégorie: ${category} - ${filteredEvents.length} événements trouvés`);
        }
        
        // Tri par date croissante
        filteredEvents.sort((a, b) => {
            const dateA = new Date(`${a.date}T${a.time}`);
            const dateB = new Date(`${b.date}T${b.time}`);
            return dateA - dateB;
        });
        
        res.status(200).json({
            success: true,
            message: 'Événements récupérés avec succès',
            count: filteredEvents.length,
            data: filteredEvents
        });
        
    } catch (error) {
        console.error('❌ Erreur lors de la récupération des événements:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur',
            message: 'Impossible de récupérer les événements'
        });
    }
};

/**
 * GET /api/calendar/events/:id
 * Récupère un événement spécifique par son ID
 */
const getEventById = (req, res) => {
    try {
        const eventId = parseInt(req.params.id);
        
        console.log(`📅 Récupération événement ID: ${eventId} - IP: ${req.ip}`);
        
        // Validation de l'ID
        if (isNaN(eventId) || eventId <= 0) {
            return res.status(400).json({
                success: false,
                error: 'ID invalide',
                message: 'L\'ID de l\'événement doit être un nombre positif'
            });
        }
        
        // Recherche de l'événement
        const event = events.find(e => e.id === eventId);
        
        if (!event) {
            console.log(`🔍 Événement non trouvé - ID: ${eventId}`);
            return res.status(404).json({
                success: false,
                error: 'Événement non trouvé',
                message: `Aucun événement trouvé avec l'ID ${eventId}`
            });
        }
        
        console.log(`✅ Événement trouvé: ${event.title}`);
        res.status(200).json({
            success: true,
            message: 'Événement récupéré avec succès',
            data: event
        });
        
    } catch (error) {
        console.error('❌ Erreur lors de la récupération de l\'événement:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur',
            message: 'Impossible de récupérer l\'événement'
        });
    }
};

/**
 * GET /api/calendar/categories
 * Récupère toutes les catégories d'événements disponibles
 */
const getCategories = (req, res) => {
    try {
        console.log(`📋 Récupération des catégories - IP: ${req.ip}`);
        
        // Extraction des catégories uniques
        const categories = [...new Set(events.map(event => event.category))];
        
        res.status(200).json({
            success: true,
            message: 'Catégories récupérées avec succès',
            count: categories.length,
            data: categories
        });
        
    } catch (error) {
        console.error('❌ Erreur lors de la récupération des catégories:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur',
            message: 'Impossible de récupérer les catégories'
        });
    }
};

/**
 * GET /api/calendar/events/month/:year/:month
 * Récupère les événements d'un mois spécifique
 */
const getEventsByMonth = (req, res) => {
    try {
        const { year, month } = req.params;
        
        console.log(`📅 Récupération événements pour ${month}/${year} - IP: ${req.ip}`);
        
        // Validation des paramètres
        const yearNum = parseInt(year);
        const monthNum = parseInt(month);
        
        if (isNaN(yearNum) || isNaN(monthNum) || monthNum < 1 || monthNum > 12) {
            return res.status(400).json({
                success: false,
                error: 'Paramètres invalides',
                message: 'L\'année et le mois doivent être des nombres valides (mois: 1-12)'
            });
        }
        
        // Filtrage par mois et année
        const monthEvents = events.filter(event => {
            const eventDate = new Date(event.date);
            return eventDate.getFullYear() === yearNum && 
                   eventDate.getMonth() + 1 === monthNum;
        });
        
        // Tri par date
        monthEvents.sort((a, b) => {
            const dateA = new Date(`${a.date}T${a.time}`);
            const dateB = new Date(`${b.date}T${b.time}`);
            return dateA - dateB;
        });
        
        console.log(`✅ ${monthEvents.length} événements trouvés pour ${month}/${year}`);
        
        res.status(200).json({
            success: true,
            message: `Événements de ${month}/${year} récupérés avec succès`,
            month: monthNum,
            year: yearNum,
            count: monthEvents.length,
            data: monthEvents
        });
        
    } catch (error) {
        console.error('❌ Erreur lors de la récupération des événements du mois:', error);
        res.status(500).json({
            success: false,
            error: 'Erreur interne du serveur',
            message: 'Impossible de récupérer les événements du mois'
        });
    }
};

module.exports = {
    getAllEvents,
    getEventById,
    getCategories,
    getEventsByMonth
};
</file>

<file path="sigl_backend/app/calendar/data.js">
/**
 * Données d'événements français hardcodées pour l'API Calendrier
 * Contient des événements réalistes pour étudiants en apprentissage
 */

const events = [
    // Événements pour novembre 2025 (mois actuel)
    {
        id: 21,
        title: "Entretien tuteur entreprise",
        description: "Point mensuel avec le maître d'apprentissage sur l'avancement des missions",
        date: "2025-11-22",
        time: "14:00",
        location: "Entreprise d'accueil, Salle de réunion 3",
        category: "rendez-vous"
    },
    {
        id: 22,
        title: "Formation React avancé",
        description: "Atelier sur les hooks personnalisés et l'optimisation des performances",
        date: "2025-11-25",
        time: "09:00",
        location: "ESEO Angers, Amphithéâtre A",
        category: "formation"
    },
    {
        id: 23,
        title: "Soutenance projet semestre",
        description: "Présentation du projet développé en entreprise devant le jury",
        date: "2025-11-28",
        time: "10:30",
        location: "ESEO Angers, Salle de soutenance 2",
        category: "rendez-vous"
    },
    {
        id: 24,
        title: "Remise rapport d'activité",
        description: "Date limite pour remettre le rapport mensuel d'activités en entreprise",
        date: "2025-11-30",
        time: "23:59",
        location: "Plateforme numérique ESEO",
        category: "formation"
    },
    // Événements pour décembre 2025
    {
        id: 1,
        title: "Réunion équipe projet",
        description: "Sprint planning et répartition des tâches pour le développement de l'application mobile",
        date: "2025-12-02",
        time: "09:00",
        location: "Entreprise d'accueil, Open Space",
        category: "réunion"
    },
    {
        id: 2,
        title: "Entretien évaluation compétences",
        description: "Bilan semestriel avec le tuteur pédagogique et le maître d'apprentissage",
        date: "2025-12-05",
        time: "14:30",
        location: "ESEO Angers, Bureau des relations entreprises",
        category: "rendez-vous"
    },
    {
        id: 3,
        title: "Conférence IA et développement",
        description: "Intervention d'experts sur l'intelligence artificielle dans le développement logiciel",
        date: "2025-12-10",
        time: "16:00",
        location: "ESEO Angers, Grand Amphithéâtre",
        category: "culturel"
    },
    {
        id: 4,
        title: "Workshop DevOps",
        description: "Formation pratique sur Docker, Kubernetes et CI/CD",
        date: "2025-12-12",
        time: "10:00",
        location: "ESEO Angers, Laboratoire informatique",
        category: "formation"
    },
    {
        id: 5,
        title: "Présentation projet client",
        description: "Démonstration de l'avancement du projet devant le client final",
        date: "2025-12-15",
        time: "15:00",
        location: "Entreprise d'accueil, Salle de présentation",
        category: "réunion"
    },
    {
        id: 6,
        title: "Forum entreprises ESEO",
        description: "Rencontre avec les entreprises partenaires et présentation des projets étudiants",
        date: "2025-12-18",
        time: "09:00",
        location: "ESEO Angers, Hall principal",
        category: "culturel"
    },
    {
        id: 7,
        title: "Entretien suivi pédagogique",
        description: "Point individuel avec le responsable pédagogique sur le parcours d'apprentissage",
        date: "2025-12-20",
        time: "11:00",
        location: "ESEO Angers, Bureau pédagogique",
        category: "rendez-vous"
    },
    // Événements pour janvier 2026
    {
        id: 8,
        title: "Séminaire cybersécurité",
        description: "Formation obligatoire sur la sécurité informatique en entreprise",
        date: "2026-01-08",
        time: "09:30",
        location: "ESEO Angers, Salle de conférence",
        category: "formation"
    },
    {
        id: 9,
        title: "Réunion de service",
        description: "Participation à la réunion hebdomadaire de l'équipe de développement",
        date: "2026-01-10",
        time: "14:00",
        location: "Entreprise d'accueil, Salle de réunion principale",
        category: "réunion"
    },
    {
        id: 10,
        title: "Hackathon étudiant",
        description: "Compétition de développement sur 48h avec les autres apprentis",
        date: "2026-01-15",
        time: "18:00",
        location: "ESEO Angers, FabLab",
        category: "culturel"
    },
    {
        id: 11,
        title: "Entretien annuel apprenti",
        description: "Évaluation annuelle des compétences et définition des objectifs",
        date: "2026-01-20",
        time: "10:30",
        location: "Entreprise d'accueil, Bureau RH",
        category: "rendez-vous"
    },
    {
        id: 12,
        title: "Journée portes ouvertes",
        description: "Présentation du cursus apprentissage aux futurs étudiants",
        date: "2026-01-25",
        time: "14:00",
        location: "ESEO Angers, Campus principal",
        category: "culturel"
    },
    {
        id: 13,
        title: "Code review collectif",
        description: "Session de revue de code avec l'équipe senior de développement",
        date: "2026-01-28",
        time: "11:00",
        location: "Entreprise d'accueil, Salle de développement",
        category: "réunion"
    },
    // Événements pour février 2026
    {
        id: 14,
        title: "Soutenance mémoire technique",
        description: "Présentation du mémoire de fin d'études devant le jury",
        date: "2026-02-05",
        time: "14:30",
        location: "ESEO Angers, Salle de soutenance 1",
        category: "rendez-vous"
    },
    {
        id: 15,
        title: "Formation gestion de projet",
        description: "Méthodologies Agile et Scrum pour la gestion de projets informatiques",
        date: "2026-02-08",
        time: "09:00",
        location: "ESEO Angers, Salle de formation",
        category: "formation"
    },
    {
        id: 16,
        title: "Meetup développeurs",
        description: "Rencontre avec la communauté locale des développeurs web",
        date: "2026-02-12",
        time: "19:00",
        location: "La Cantine Numérique, Angers",
        category: "culturel"
    },
    {
        id: 17,
        title: "Bilan mi-parcours",
        description: "Évaluation intermédiaire du parcours d'apprentissage",
        date: "2026-02-15",
        time: "15:00",
        location: "ESEO Angers, Bureau des études",
        category: "rendez-vous"
    },
    {
        id: 18,
        title: "Sprint review",
        description: "Présentation des fonctionnalités développées lors du sprint",
        date: "2026-02-18",
        time: "16:30",
        location: "Entreprise d'accueil, Salle de démonstration",
        category: "réunion"
    },
    {
        id: 19,
        title: "Atelier soft skills",
        description: "Développement des compétences relationnelles et communication",
        date: "2026-02-22",
        time: "10:00",
        location: "ESEO Angers, Salle polyvalente",
        category: "formation"
    },
    {
        id: 20,
        title: "Entretien de fin de contrat",
        description: "Bilan final du contrat d'apprentissage et perspectives d'avenir",
        date: "2026-02-28",
        time: "14:00",
        location: "Entreprise d'accueil, Bureau direction",
        category: "rendez-vous"
    }
];

module.exports = events;
</file>

<file path="sigl_backend/app/calendar/routes.js">
const express = require('express');
const router = express.Router();
const calendarController = require('./controller');

/**
 * Routes pour l'API Calendrier
 * Aucune authentification requise selon les spécifications
 */

// GET /api/calendar/events - Récupérer tous les événements
// Supporte le filtrage par catégorie via query parameter: ?category=réunion
router.get('/events', calendarController.getAllEvents);

// GET /api/calendar/events/:id - Récupérer un événement spécifique par ID
router.get('/events/:id', calendarController.getEventById);

// GET /api/calendar/categories - Récupérer toutes les catégories disponibles
router.get('/categories', calendarController.getCategories);

// GET /api/calendar/events/month/:year/:month - Récupérer les événements d'un mois spécifique
router.get('/events/month/:year/:month', calendarController.getEventsByMonth);

module.exports = router;
</file>

<file path="sigl_backend/app/common/models/user.model.js">
// sigl_backend/app/common/models/user.model.js
const mongoose = require('mongoose');

const VALID_ROLES = ['APPRENTI', 'MA', 'TP', 'CA', 'RC', 'PROF', 'ADMIN'];

const utilisateurSchema = new mongoose.Schema(
  {
    nom: {
      type: String,
      required: true,
      trim: true,
    },

    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      match: [/^[^\s@]+@[^\s@]+\.[^\s@]+$/, "Format d'email invalide"],
    },

    // Nouveau : prénom / nom de famille décomposés
    firstName: {
      type: String,
      trim: true,
    },
    lastName: {
      type: String,
      trim: true,
    },

    // Avatar (data URL ou URL)
    avatar: {
      type: String,
      default: null,
    },

    // MFA
    mfaEnabled: {
      type: Boolean,
      default: false,
    },
    mfaMethod: {
      type: String,
      enum: ['sms', 'email', null],
      default: null,
    },
    mfaCode: {
      type: String,
      default: null,
    },
    mfaCodeExpiresAt: {
      type: Date,
      default: null,
    },
    phone: {
      type: String,
      sparse: true,
    },

    // Email vérifié
    isEmailVerified: {
      type: Boolean,
      default: false,
    },

    // Rôle métier
    role: {
      type: String,
      required: true,
      enum: VALID_ROLES,
      default: 'APPRENTI',
    },

    // Champs spécifiques / legacy
    idApprenti: {
      type: mongoose.Schema.Types.ObjectId,
      sparse: true,
    },
    numero: {
      type: String,
      sparse: true,
    },
    promotion: {
      type: mongoose.Schema.Types.ObjectId,
      sparse: true,
    },
    entreprise: {
      type: mongoose.Schema.Types.ObjectId,
      sparse: true,
    },
    fonction: {
      type: String,
      sparse: true,
    },
    specialite: {
      type: String,
      sparse: true,
    },
    service: {
      type: String,
      sparse: true,
    },
    departement: {
      type: String,
      sparse: true,
    },
    grade: {
      type: String,
      sparse: true,
    },
    habilitations: {
      type: String,
      sparse: true,
    },
  },
  {
    timestamps: true,
    collection: 'utilisateurs',
  }
);

utilisateurSchema.index({ role: 1 });

// Retirer les champs sensibles / inutiles côté front
utilisateurSchema.methods.toSafeObject = function () {
  const obj = this.toObject();
  delete obj.mfaCode;
  delete obj.mfaCodeExpiresAt;
  return obj;
};

module.exports = mongoose.model('Utilisateur', utilisateurSchema);
</file>

<file path="sigl_backend/app/middleware/authenticate.js">
// sigl_backend/app/middleware/authenticate.js

/**
 * Middlewares d’authentification (access / refresh tokens)
 * -> Utilise les helpers déjà présents dans auth.service
 */

const authService = require('../auth/auth.service');

/**
 * Middleware pour vérifier un access token (Bearer <token>)
 */
const authenticate = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization || req.headers.Authorization;

    if (!authHeader) {
      return res.status(401).json({
        success: false,
        message: 'Access denied. No token provided.',
        error: 'MISSING_TOKEN',
      });
    }

    let token;
    try {
      token = authService.extractBearerToken(authHeader);
    } catch (err) {
      return res.status(401).json({
        success: false,
        message: 'Invalid authorization header format. Expected: Bearer <token>',
        error: 'INVALID_HEADER_FORMAT',
      });
    }

    let decoded;
    try {
      decoded = authService.verifyToken(token, 'access');
    } catch (err) {
      if (err.message === 'Token has expired') {
        return res.status(401).json({
          success: false,
          message: 'Token has expired. Please refresh your token.',
          error: 'TOKEN_EXPIRED',
        });
      } else if (err.message === 'Invalid token') {
        return res.status(401).json({
          success: false,
          message: 'Invalid token provided.',
          error: 'INVALID_TOKEN',
        });
      } else if (err.message === 'Token not active yet') {
        return res.status(401).json({
          success: false,
          message: 'Token is not yet active.',
          error: 'TOKEN_NOT_ACTIVE',
        });
      }

      return res.status(401).json({
        success: false,
        message: 'Token verification failed.',
        error: 'TOKEN_VERIFICATION_FAILED',
      });
    }

    if (!decoded.userId || !decoded.email || !decoded.role) {
      return res.status(401).json({
        success: false,
        message: 'Invalid token payload.',
        error: 'INVALID_TOKEN_PAYLOAD',
      });
    }

    req.user = {
      userId: decoded.userId,
      email: decoded.email,
      role: decoded.role,
      tokenType: decoded.type,
    };

    console.log(
      `User authenticated: ${decoded.email} (${decoded.role}) - ${new Date().toISOString()}`
    );

    next();
  } catch (error) {
    console.error('Authentication middleware error:', error.message);
    return res.status(500).json({
      success: false,
      message: 'Internal server error during authentication.',
      error: 'AUTHENTICATION_ERROR',
    });
  }
};

/**
 * Middleware pour vérifier un refresh token (Bearer <token>)
 */
const authenticateRefreshToken = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization || req.headers.Authorization;

    if (!authHeader) {
      return res.status(401).json({
        success: false,
        message: 'Access denied. No refresh token provided.',
        error: 'MISSING_REFRESH_TOKEN',
      });
    }

    let token;
    try {
      token = authService.extractBearerToken(authHeader);
    } catch (err) {
      return res.status(401).json({
        success: false,
        message: 'Invalid authorization header format. Expected: Bearer <token>',
        error: 'INVALID_HEADER_FORMAT',
      });
    }

    let decoded;
    try {
      decoded = authService.verifyToken(token, 'refresh');
    } catch (err) {
      if (err.message === 'Token has expired') {
        return res.status(401).json({
          success: false,
          message: 'Refresh token has expired. Please login again.',
          error: 'REFRESH_TOKEN_EXPIRED',
        });
      } else if (err.message === 'Invalid token') {
        return res.status(401).json({
          success: false,
          message: 'Invalid refresh token provided.',
          error: 'INVALID_REFRESH_TOKEN',
        });
      }

      return res.status(401).json({
        success: false,
        message: 'Refresh token verification failed.',
        error: 'REFRESH_TOKEN_VERIFICATION_FAILED',
      });
    }

    if (!decoded.userId) {
      return res.status(401).json({
        success: false,
        message: 'Invalid refresh token payload.',
        error: 'INVALID_REFRESH_TOKEN_PAYLOAD',
      });
    }

    req.user = {
      userId: decoded.userId,
      tokenType: decoded.type,
    };

    console.log(
      `Refresh token authenticated: ${decoded.userId} - ${new Date().toISOString()}`
    );

    next();
  } catch (error) {
    console.error('Refresh token authentication middleware error:', error.message);
    return res.status(500).json({
      success: false,
      message: 'Internal server error during refresh token authentication.',
      error: 'REFRESH_AUTHENTICATION_ERROR',
    });
  }
};

module.exports = {
  authenticate,
  authenticateRefreshToken,
};
</file>

<file path="sigl_backend/app/user/repository.js">
const Utilisateur = require('../common/models/user.model');

const VALID_ROLES = ['APPRENTI', 'MA', 'TP', 'CA', 'RC', 'PROF', 'ADMIN'];

/**
 * Créer un nouvel utilisateur (sans mot de passe).
 */
const createUser = async (userData) => {
  try {
    console.log('Repository createUser - Input data:', userData);

    if (userData.password) {
      throw new Error(
        'Password should not be included in user data. Use auth system for password management.'
      );
    }

    const dbRole = userData.role || 'APPRENTI';
    if (!VALID_ROLES.includes(dbRole)) {
      throw new Error(`Invalid role: ${dbRole}. Must be one of: ${VALID_ROLES.join(', ')}`);
    }

    const userDoc = {
      nom: userData.username,
      email: userData.email.toLowerCase(),
      role: dbRole,
    };

    if (userData.firstName) {
      userDoc.firstName = userData.firstName;
    }
    if (userData.lastName) {
      userDoc.lastName = userData.lastName;
    }
    if (userData.telephone) {
      userDoc.phone = userData.telephone;
    }
    if (typeof userData.mfaEnabled === 'boolean') {
      userDoc.mfaEnabled = userData.mfaEnabled;
    }
    if (userData.mfaMethod) {
      userDoc.mfaMethod = userData.mfaMethod;
    }
    if (userData.avatar) {
      userDoc.avatar = userData.avatar;
    }

    console.log('Repository createUser - User object before save:', userDoc);

    const user = new Utilisateur(userDoc);
    const savedUser = await user.save();
    return savedUser.toSafeObject();
  } catch (error) {
    console.error('Repository createUser - Database error:', error);
    throw new Error(`Échec de la création de l'utilisateur : ${error.message}`);
  }
};

const findUserById = async (userId) => {
  try {
    const user = await Utilisateur.findById(userId);
    return user ? user.toSafeObject() : null;
  } catch (error) {
    throw new Error(`Échec de la récupération de l'utilisateur : ${error.message}`);
  }
};

const findUserByEmail = async (email) => {
  try {
    const user = await Utilisateur.findOne({ email: email.toLowerCase() });
    return user ? user.toSafeObject() : null;
  } catch (error) {
    throw new Error(`Échec de la récupération par email : ${error.message}`);
  }
};

const findUserByUsername = async (username) => {
  try {
    const user = await Utilisateur.findOne({ nom: username });
    return user ? user.toSafeObject() : null;
  } catch (error) {
    throw new Error(`Échec de la récupération par username : ${error.message}`);
  }
};

/**
 * Mettre à jour un utilisateur.
 */
const updateUser = async (userId, updateData) => {
  try {
    console.log('Repository updateUser - Input data:', updateData);

    if (updateData.password || updateData.newPassword || updateData.currentPassword) {
      throw new Error(
        'Password updates are not allowed via user.updateUser. Use auth system for password changes.'
      );
    }

    const mappedData = { ...updateData };

    // username → nom
    if (mappedData.username) {
      mappedData.nom = mappedData.username;
      delete mappedData.username;
    }

    // telephone → phone
    if (mappedData.telephone) {
      mappedData.phone = mappedData.telephone;
      delete mappedData.telephone;
    }

    // role
    if (mappedData.role) {
      if (!VALID_ROLES.includes(mappedData.role)) {
        throw new Error(`Invalid role: ${mappedData.role}. Must be one of: ${VALID_ROLES.join(', ')}`);
      }
    }

    // email lowercase
    if (mappedData.email) {
      mappedData.email = mappedData.email.toLowerCase();
    }

    console.log('Repository updateUser - Final update data:', mappedData);

    const updatedUser = await Utilisateur.findByIdAndUpdate(
      userId,
      { $set: mappedData },
      { new: true, runValidators: true }
    );

    if (!updatedUser) {
      throw new Error('Utilisateur non trouvé');
    }

    console.log('Repository updateUser - User updated successfully:', updatedUser._id);
    return updatedUser.toSafeObject();
  } catch (error) {
    console.error('Repository updateUser - Database error:', error);
    throw new Error(`Échec de la mise à jour de l'utilisateur : ${error.message}`);
  }
};

const deleteUser = async (userId) => {
  try {
    const result = await Utilisateur.findByIdAndDelete(userId);
    return result !== null;
  } catch (error) {
    throw new Error(`Échec de la suppression de l'utilisateur : ${error.message}`);
  }
};

const listAllUsers = async () => {
  try {
    const users = await Utilisateur.find();
    return users.map((u) => u.toSafeObject());
  } catch (error) {
    throw new Error(`Échec de la liste des utilisateurs : ${error.message}`);
  }
};

module.exports = {
  createUser,
  findUserById,
  findUserByEmail,
  findUserByUsername,
  updateUser,
  deleteUser,
  listAllUsers,
};
</file>

<file path="sigl_backend/app/user/service.js">
// sigl_backend/app/user/service.js
const userRepository = require('./repository');

/**
 * Create a new user (without password).
 */
const createUser = async (userData) => {
  try {
    if (!userData.username || !userData.email) {
      return {
        success: false,
        error: "Le nom d'utilisateur et l'email sont obligatoires",
      };
    }

    const newUser = await userRepository.createUser(userData);

    return {
      success: true,
      data: newUser,
    };
  } catch (error) {
    console.error('Service createUser error:', error);
    return {
      success: false,
      error: "Échec de la création de l'utilisateur",
      details: error.message,
    };
  }
};

const getUserProfile = async (userId) => {
  try {
    const user = await userRepository.findUserById(userId);
    if (!user) {
      return {
        success: false,
        error: 'Utilisateur non trouvé',
      };
    }

    return {
      success: true,
      data: user,
    };
  } catch (error) {
    console.error('Service getUserProfile error:', error);
    return {
      success: false,
      error: 'Échec de la récupération du profil',
      details: error.message,
    };
  }
};

/**
 * Mise à jour des infos utilisateur (profil).
 */
const updateUserInfo = async (userId, updateData) => {
  try {
    const updatedUser = await userRepository.updateUser(userId, updateData);
    return {
      success: true,
      data: updatedUser,
    };
  } catch (error) {
    console.error('Service updateUserInfo error:', error);
    return {
      success: false,
      error: "Échec de la mise à jour de l'utilisateur",
      details: error.message,
    };
  }
};

const deleteUserAccount = async (userId) => {
  try {
    const deleted = await userRepository.deleteUser(userId);
    if (!deleted) {
      return {
        success: false,
        error: 'Utilisateur non trouvé',
      };
    }

    return {
      success: true,
      message: 'Utilisateur supprimé avec succès',
    };
  } catch (error) {
    console.error('Service deleteUserAccount error:', error);
    return {
      success: false,
      error: "Échec de la suppression de l'utilisateur",
      details: error.message,
    };
  }
};

const listAllUsers = async () => {
  try {
    const users = await userRepository.listAllUsers();
    return {
      success: true,
      data: users,
    };
  } catch (error) {
    console.error('Service listAllUsers error:', error);
    return {
      success: false,
      error: 'Échec de la récupération de la liste des utilisateurs',
      details: error.message,
    };
  }
};

module.exports = {
  createUser,
  getUserProfile,
  updateUserInfo,
  deleteUserAccount,
  listAllUsers,
};
</file>

<file path="sigl_frontend/src/components/calendar/CalendarGrid.jsx">
import React, { useState, useEffect } from 'react';
import EventCard from './EventCard';
import CalendarService from '../../services/calendarService';

/**
 * Composant CalendarGrid - Grille mensuelle du calendrier
 * @param {Date} currentDate - Date actuellement affichée
 * @param {Array} events - Liste des événements du mois
 * @param {boolean} loading - État de chargement
 */
const CalendarGrid = ({ currentDate, events = [], loading = false }) => {
  const [hoveredEvent, setHoveredEvent] = useState(null);
  const [hoveredPosition, setHoveredPosition] = useState({ x: 0, y: 0 });

  // Noms des jours de la semaine en français (lundi en premier)
  const dayNames = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim'];
  const dayNamesFull = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];

  // Génération des jours du mois
  const generateCalendarDays = () => {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    
    // Premier jour du mois
    const firstDay = new Date(year, month, 1);
    // Dernier jour du mois
    const lastDay = new Date(year, month + 1, 0);
    
    // Jour de la semaine du premier jour (0 = dimanche, 1 = lundi, etc.)
    // Ajustement pour que lundi soit 0
    let firstDayOfWeek = firstDay.getDay();
    firstDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
    
    const daysInMonth = lastDay.getDate();
    const days = [];
    
    // Jours du mois précédent pour compléter la première semaine
    const prevMonth = new Date(year, month - 1, 0);
    const daysInPrevMonth = prevMonth.getDate();
    
    for (let i = firstDayOfWeek - 1; i >= 0; i--) {
      days.push({
        date: daysInPrevMonth - i,
        isCurrentMonth: false,
        isPrevMonth: true,
        fullDate: new Date(year, month - 1, daysInPrevMonth - i)
      });
    }
    
    // Jours du mois actuel
    for (let day = 1; day <= daysInMonth; day++) {
      days.push({
        date: day,
        isCurrentMonth: true,
        isPrevMonth: false,
        fullDate: new Date(year, month, day)
      });
    }
    
    // Jours du mois suivant pour compléter la dernière semaine
    const totalCells = Math.ceil(days.length / 7) * 7;
    let nextMonthDay = 1;
    
    for (let i = days.length; i < totalCells; i++) {
      days.push({
        date: nextMonthDay,
        isCurrentMonth: false,
        isPrevMonth: false,
        fullDate: new Date(year, month + 1, nextMonthDay)
      });
      nextMonthDay++;
    }
    
    return days;
  };

  // Groupement des événements par date
  const eventsByDate = CalendarService.groupEventsByDate(events);

  // Obtenir les événements d'une date spécifique
  const getEventsForDate = (date) => {
    const dateString = date.toISOString().split('T')[0];
    return eventsByDate[dateString] || [];
  };

  // Vérifier si une date est aujourd'hui
  const isToday = (date) => {
    const today = new Date();
    return date.toDateString() === today.toDateString();
  };

  // Gestion du survol des événements
  const handleEventHover = (event, mouseEvent) => {
    setHoveredEvent(event);
    setHoveredPosition({
      x: mouseEvent.clientX,
      y: mouseEvent.clientY
    });
  };

  const handleEventLeave = () => {
    setHoveredEvent(null);
  };

  // Mise à jour de la position du tooltip lors du mouvement de la souris
  useEffect(() => {
    const handleMouseMove = (e) => {
      if (hoveredEvent) {
        setHoveredPosition({
          x: e.clientX,
          y: e.clientY
        });
      }
    };

    if (hoveredEvent) {
      document.addEventListener('mousemove', handleMouseMove);
    }

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
    };
  }, [hoveredEvent]);

  const calendarDays = generateCalendarDays();

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
        <div className="animate-pulse">
          {/* En-têtes des jours */}
          <div className="grid grid-cols-7 gap-1 mb-4">
            {dayNames.map((day, index) => (
              <div key={index} className="h-8 bg-gray-200 rounded"></div>
            ))}
          </div>
          
          {/* Grille des jours */}
          <div className="grid grid-cols-7 gap-1">
            {[...Array(35)].map((_, index) => (
              <div key={index} className="h-24 bg-gray-100 rounded"></div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
      {/* En-têtes des jours de la semaine */}
      <div className="grid grid-cols-7 bg-gray-50 border-b border-gray-200">
        {dayNames.map((day, index) => (
          <div
            key={index}
            className="p-3 text-center text-sm font-medium text-gray-700 border-r border-gray-200 last:border-r-0"
          >
            <span className="hidden sm:inline">{dayNamesFull[index]}</span>
            <span className="sm:hidden">{day}</span>
          </div>
        ))}
      </div>

      {/* Grille des jours */}
      <div className="grid grid-cols-7">
        {calendarDays.map((day, index) => {
          const dayEvents = getEventsForDate(day.fullDate);
          const isCurrentDay = isToday(day.fullDate);
          
          return (
            <div
              key={index}
              className={`
                min-h-24 sm:min-h-32 p-2 border-r border-b border-gray-200 
                last:border-r-0 relative
                ${day.isCurrentMonth ? 'bg-white' : 'bg-gray-50'}
                ${isCurrentDay ? 'bg-blue-50' : ''}
              `}
            >
              {/* Numéro du jour */}
              <div className="flex items-center justify-between mb-1">
                <span
                  className={`
                    text-sm font-medium
                    ${day.isCurrentMonth 
                      ? isCurrentDay 
                        ? 'text-blue-600 font-bold' 
                        : 'text-gray-900'
                      : 'text-gray-400'
                    }
                  `}
                >
                  {day.date}
                </span>
                
                {/* Indicateur du nombre d'événements */}
                {dayEvents.length > 0 && (
                  <span className="text-xs bg-primary-100 text-primary-800 px-1 rounded-full">
                    {dayEvents.length}
                  </span>
                )}
              </div>

              {/* Liste des événements */}
              <div className="space-y-1">
                {dayEvents.slice(0, 3).map((event) => (
                  <div
                    key={event.id}
                    className={`
                      text-xs p-1 rounded cursor-pointer
                      ${CalendarService.getCategoryColor(event.category).bg}
                      ${CalendarService.getCategoryColor(event.category).text}
                      border-l-2 ${CalendarService.getCategoryColor(event.category).border}
                      hover:shadow-sm transition-shadow duration-200
                    `}
                    onMouseEnter={(e) => handleEventHover(event, e)}
                    onMouseLeave={handleEventLeave}
                    onClick={() => {
                      // Navigation vers la page de détail de l'événement
                      window.location.href = `/calendar/event/${event.id}`;
                    }}
                  >
                    <div className="font-medium truncate">
                      {event.title}
                    </div>
                    {event.time && (
                      <div className="opacity-75">
                        {CalendarService.formatTime(event.time)}
                      </div>
                    )}
                  </div>
                ))}
                
                {/* Indicateur d'événements supplémentaires */}
                {dayEvents.length > 3 && (
                  <div className="text-xs text-gray-500 text-center py-1">
                    +{dayEvents.length - 3} autres
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>

      {/* Tooltip pour l'aperçu des événements */}
      {hoveredEvent && (
        <div
          className="fixed z-50 pointer-events-none"
          style={{
            left: hoveredPosition.x + 10,
            top: hoveredPosition.y - 10,
            transform: 'translateY(-100%)'
          }}
        >
          <div className="bg-white border border-gray-200 rounded-lg shadow-lg p-3 max-w-xs">
            <EventCard 
              event={hoveredEvent} 
              isPreview={true} 
              size="medium"
            />
          </div>
        </div>
      )}
    </div>
  );
};

/**
 * Composant CalendarGridMobile - Version mobile du calendrier
 */
export const CalendarGridMobile = ({ currentDate, events = [], loading = false }) => {
  const [selectedDate, setSelectedDate] = useState(null);

  // Génération des jours du mois pour mobile
  const generateMobileDays = () => {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const days = [];

    for (let day = 1; day <= daysInMonth; day++) {
      const fullDate = new Date(year, month, day);
      days.push({
        date: day,
        fullDate,
        events: CalendarService.groupEventsByDate(events)[fullDate.toISOString().split('T')[0]] || []
      });
    }

    return days;
  };

  const mobileDays = generateMobileDays();

  if (loading) {
    return (
      <div className="space-y-2">
        {[...Array(5)].map((_, index) => (
          <div key={index} className="bg-gray-100 h-16 rounded animate-pulse"></div>
        ))}
      </div>
    );
  }

  return (
    <div className="space-y-2">
      {mobileDays.map((day) => {
        const isToday = day.fullDate.toDateString() === new Date().toDateString();
        const hasEvents = day.events.length > 0;

        return (
          <div
            key={day.date}
            className={`
              bg-white rounded-lg border p-3
              ${isToday ? 'border-blue-300 bg-blue-50' : 'border-gray-200'}
              ${hasEvents ? 'shadow-sm' : ''}
            `}
          >
            <div className="flex items-center justify-between mb-2">
              <div className="flex items-center space-x-2">
                <span
                  className={`
                    text-lg font-bold
                    ${isToday ? 'text-blue-600' : 'text-gray-900'}
                  `}
                >
                  {day.date}
                </span>
                <span className="text-sm text-gray-500">
                  {day.fullDate.toLocaleDateString('fr-FR', { weekday: 'long' })}
                </span>
              </div>
              
              {hasEvents && (
                <span className="text-xs bg-primary-100 text-primary-800 px-2 py-1 rounded-full">
                  {day.events.length} événement{day.events.length > 1 ? 's' : ''}
                </span>
              )}
            </div>

            {hasEvents && (
              <div className="space-y-1">
                {day.events.map((event) => (
                  <EventCard
                    key={event.id}
                    event={event}
                    size="small"
                  />
                ))}
              </div>
            )}
          </div>
        );
      })}
    </div>
  );
};

export default CalendarGrid;
</file>

<file path="sigl_frontend/src/components/calendar/CalendarNavigation.jsx">
import React from 'react';

/**
 * Composant CalendarNavigation - Navigation pour le calendrier
 * @param {Date} currentDate - Date actuellement affichée
 * @param {Function} onDateChange - Callback appelé lors du changement de date
 * @param {boolean} loading - État de chargement
 */
const CalendarNavigation = ({ currentDate, onDateChange, loading = false }) => {
  
  // Noms des mois en français
  const monthNames = [
    'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
    'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'
  ];

  // Navigation vers le mois précédent
  const goToPreviousMonth = () => {
    if (loading) return;
    
    const newDate = new Date(currentDate);
    newDate.setMonth(newDate.getMonth() - 1);
    onDateChange(newDate);
  };

  // Navigation vers le mois suivant
  const goToNextMonth = () => {
    if (loading) return;
    
    const newDate = new Date(currentDate);
    newDate.setMonth(newDate.getMonth() + 1);
    onDateChange(newDate);
  };

  // Navigation vers le mois actuel
  const goToToday = () => {
    if (loading) return;
    onDateChange(new Date());
  };

  // Navigation vers une année spécifique
  const goToYear = (year) => {
    if (loading) return;
    
    const newDate = new Date(currentDate);
    newDate.setFullYear(year);
    onDateChange(newDate);
  };

  // Navigation vers un mois spécifique
  const goToMonth = (monthIndex) => {
    if (loading) return;
    
    const newDate = new Date(currentDate);
    newDate.setMonth(monthIndex);
    onDateChange(newDate);
  };

  const currentMonth = currentDate.getMonth();
  const currentYear = currentDate.getFullYear();
  const today = new Date();
  const isCurrentMonth = currentMonth === today.getMonth() && currentYear === today.getFullYear();

  // Génération des années (5 ans avant et après l'année courante)
  const currentYearNum = new Date().getFullYear();
  const years = [];
  for (let i = currentYearNum - 5; i <= currentYearNum + 5; i++) {
    years.push(i);
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4 mb-6">
      {/* Navigation principale */}
      <div className="flex items-center justify-between mb-4">
        {/* Bouton mois précédent */}
        <button
          onClick={goToPreviousMonth}
          disabled={loading}
          className={`
            flex items-center justify-center w-10 h-10 rounded-full
            transition-all duration-200
            ${loading 
              ? 'bg-gray-100 text-gray-400 cursor-not-allowed' 
              : 'bg-gray-100 hover:bg-gray-200 text-gray-700 hover:text-gray-900'
            }
            focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2
          `}
          aria-label="Mois précédent"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
          </svg>
        </button>

        {/* Affichage du mois et année actuels */}
        <div className="flex items-center space-x-4">
          <h2 className="text-2xl font-bold text-gray-900">
            {monthNames[currentMonth]} {currentYear}
          </h2>
          
          {/* Bouton "Aujourd'hui" */}
          {!isCurrentMonth && (
            <button
              onClick={goToToday}
              disabled={loading}
              className={`
                px-3 py-1 text-sm rounded-full border
                transition-all duration-200
                ${loading
                  ? 'bg-gray-100 text-gray-400 border-gray-200 cursor-not-allowed'
                  : 'bg-primary-50 text-primary-700 border-primary-200 hover:bg-primary-100'
                }
                focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2
              `}
            >
              Aujourd'hui
            </button>
          )}
        </div>

        {/* Bouton mois suivant */}
        <button
          onClick={goToNextMonth}
          disabled={loading}
          className={`
            flex items-center justify-center w-10 h-10 rounded-full
            transition-all duration-200
            ${loading 
              ? 'bg-gray-100 text-gray-400 cursor-not-allowed' 
              : 'bg-gray-100 hover:bg-gray-200 text-gray-700 hover:text-gray-900'
            }
            focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2
          `}
          aria-label="Mois suivant"
        >
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>

      {/* Navigation rapide par mois */}
      <div className="grid grid-cols-6 gap-2 mb-4">
        {monthNames.map((monthName, index) => (
          <button
            key={index}
            onClick={() => goToMonth(index)}
            disabled={loading}
            className={`
              px-2 py-1 text-xs rounded transition-all duration-200
              ${index === currentMonth
                ? 'bg-primary-500 text-white'
                : loading
                  ? 'bg-gray-50 text-gray-400 cursor-not-allowed'
                  : 'bg-gray-50 text-gray-700 hover:bg-gray-100'
              }
              focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-1
            `}
          >
            {monthName.substring(0, 3)}
          </button>
        ))}
      </div>

      {/* Navigation rapide par année */}
      <div className="flex items-center justify-center space-x-1">
        <span className="text-sm text-gray-500 mr-2">Année:</span>
        <div className="flex flex-wrap gap-1">
          {years.map((year) => (
            <button
              key={year}
              onClick={() => goToYear(year)}
              disabled={loading}
              className={`
                px-2 py-1 text-xs rounded transition-all duration-200
                ${year === currentYear
                  ? 'bg-primary-500 text-white'
                  : loading
                    ? 'bg-gray-50 text-gray-400 cursor-not-allowed'
                    : 'bg-gray-50 text-gray-700 hover:bg-gray-100'
                }
                focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-1
              `}
            >
              {year}
            </button>
          ))}
        </div>
      </div>

      {/* Indicateur de chargement */}
      {loading && (
        <div className="mt-4 flex items-center justify-center">
          <div className="flex items-center space-x-2 text-sm text-gray-500">
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-primary-500"></div>
            <span>Chargement des événements...</span>
          </div>
        </div>
      )}
    </div>
  );
};

/**
 * Composant CalendarNavigationMobile - Version mobile simplifiée
 */
export const CalendarNavigationMobile = ({ currentDate, onDateChange, loading = false }) => {
  const monthNames = [
    'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
    'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'
  ];

  const goToPreviousMonth = () => {
    if (loading) return;
    const newDate = new Date(currentDate);
    newDate.setMonth(newDate.getMonth() - 1);
    onDateChange(newDate);
  };

  const goToNextMonth = () => {
    if (loading) return;
    const newDate = new Date(currentDate);
    newDate.setMonth(newDate.getMonth() + 1);
    onDateChange(newDate);
  };

  const goToToday = () => {
    if (loading) return;
    onDateChange(new Date());
  };

  const currentMonth = currentDate.getMonth();
  const currentYear = currentDate.getFullYear();
  const today = new Date();
  const isCurrentMonth = currentMonth === today.getMonth() && currentYear === today.getFullYear();

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-3 mb-4">
      <div className="flex items-center justify-between">
        {/* Bouton précédent */}
        <button
          onClick={goToPreviousMonth}
          disabled={loading}
          className={`
            flex items-center justify-center w-8 h-8 rounded-full
            ${loading 
              ? 'bg-gray-100 text-gray-400' 
              : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
            }
          `}
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
          </svg>
        </button>

        {/* Titre et bouton aujourd'hui */}
        <div className="flex flex-col items-center">
          <h2 className="text-lg font-bold text-gray-900">
            {monthNames[currentMonth]} {currentYear}
          </h2>
          {!isCurrentMonth && (
            <button
              onClick={goToToday}
              disabled={loading}
              className={`
                text-xs px-2 py-1 rounded-full mt-1
                ${loading
                  ? 'bg-gray-100 text-gray-400'
                  : 'bg-primary-50 text-primary-700'
                }
              `}
            >
              Aujourd'hui
            </button>
          )}
        </div>

        {/* Bouton suivant */}
        <button
          onClick={goToNextMonth}
          disabled={loading}
          className={`
            flex items-center justify-center w-8 h-8 rounded-full
            ${loading 
              ? 'bg-gray-100 text-gray-400' 
              : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
            }
          `}
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>

      {loading && (
        <div className="mt-2 flex items-center justify-center">
          <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-primary-500"></div>
        </div>
      )}
    </div>
  );
};

export default CalendarNavigation;
</file>

<file path="sigl_frontend/src/components/calendar/EventCard.jsx">
import React from 'react';
import { useNavigate } from 'react-router-dom';
import CalendarService from '../../services/calendarService';

/**
 * Composant EventCard - Affiche un événement individuel
 * @param {Object} event - Données de l'événement
 * @param {boolean} isPreview - Mode aperçu (pour hover)
 * @param {string} size - Taille du composant ('small', 'medium', 'large')
 */
const EventCard = ({ event, isPreview = false, size = 'medium' }) => {
  const navigate = useNavigate();

  if (!event) return null;

  const colors = CalendarService.getCategoryColor(event.category);
  
  // Classes CSS selon la taille
  const sizeClasses = {
    small: {
      container: 'p-2 text-xs',
      title: 'font-medium truncate',
      time: 'text-xs',
      location: 'text-xs truncate'
    },
    medium: {
      container: 'p-3 text-sm',
      title: 'font-semibold',
      time: 'text-sm',
      location: 'text-sm'
    },
    large: {
      container: 'p-4 text-base',
      title: 'font-bold text-lg',
      time: 'text-base',
      location: 'text-base'
    }
  };

  const classes = sizeClasses[size];

  // Gestion du clic sur l'événement
  const handleClick = (e) => {
    e.stopPropagation();
    if (!isPreview) {
      navigate(`/calendar/event/${event.id}`);
    }
  };

  // Formatage de l'heure
  const formattedTime = CalendarService.formatTime(event.time);

  return (
    <div
      className={`
        ${colors.bg} ${colors.border} ${colors.text}
        border-l-4 rounded-r-md shadow-sm
        ${classes.container}
        ${isPreview ? 'cursor-default' : 'cursor-pointer hover:shadow-md'}
        transition-all duration-200
        ${!isPreview ? 'hover:scale-105' : ''}
      `}
      onClick={handleClick}
      role={isPreview ? 'tooltip' : 'button'}
      tabIndex={isPreview ? -1 : 0}
      onKeyDown={(e) => {
        if (!isPreview && (e.key === 'Enter' || e.key === ' ')) {
          e.preventDefault();
          handleClick(e);
        }
      }}
    >
      {/* Indicateur de catégorie */}
      <div className="flex items-start gap-2 mb-1">
        <div className={`w-2 h-2 rounded-full ${colors.dot} flex-shrink-0 mt-1`} />
        <div className="flex-1 min-w-0">
          {/* Titre de l'événement */}
          <h3 className={`${classes.title} leading-tight`}>
            {event.title}
          </h3>
        </div>
      </div>

      {/* Heure */}
      {event.time && (
        <div className={`${classes.time} opacity-80 mb-1 flex items-center gap-1`}>
          <svg className="w-3 h-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
          </svg>
          <span>{formattedTime}</span>
        </div>
      )}

      {/* Lieu (affiché selon la taille) */}
      {event.location && size !== 'small' && (
        <div className={`${classes.location} opacity-70 flex items-start gap-1`}>
          <svg className="w-3 h-3 flex-shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clipRule="evenodd" />
          </svg>
          <span className="leading-tight">{event.location}</span>
        </div>
      )}

      {/* Description (uniquement en mode large ou preview) */}
      {event.description && (size === 'large' || isPreview) && (
        <div className="mt-2 pt-2 border-t border-current border-opacity-20">
          <p className={`${classes.container} opacity-80 leading-relaxed`}>
            {event.description.length > 100 && size !== 'large' 
              ? `${event.description.substring(0, 100)}...`
              : event.description
            }
          </p>
        </div>
      )}

      {/* Badge catégorie (uniquement en mode large) */}
      {size === 'large' && (
        <div className="mt-3 flex justify-between items-center">
          <span className={`
            px-2 py-1 rounded-full text-xs font-medium
            ${colors.bg} ${colors.text} border ${colors.border}
          `}>
            {event.category}
          </span>
          
          {/* Date formatée */}
          <span className="text-xs opacity-60">
            {CalendarService.formatDate(event.date)}
          </span>
        </div>
      )}
    </div>
  );
};

/**
 * Composant EventCardSkeleton - Placeholder pendant le chargement
 */
export const EventCardSkeleton = ({ size = 'medium' }) => {
  const sizeClasses = {
    small: 'h-16',
    medium: 'h-20',
    large: 'h-32'
  };

  return (
    <div className={`
      ${sizeClasses[size]}
      bg-gray-100 border-l-4 border-gray-300 rounded-r-md
      p-3 animate-pulse
    `}>
      <div className="flex items-start gap-2 mb-2">
        <div className="w-2 h-2 bg-gray-300 rounded-full flex-shrink-0 mt-1" />
        <div className="flex-1">
          <div className="h-4 bg-gray-300 rounded w-3/4 mb-1" />
          <div className="h-3 bg-gray-300 rounded w-1/2" />
        </div>
      </div>
      {size !== 'small' && (
        <div className="h-3 bg-gray-300 rounded w-2/3" />
      )}
    </div>
  );
};

/**
 * Composant EventCardList - Liste d'événements
 */
export const EventCardList = ({ events, loading = false, size = 'medium', emptyMessage = "Aucun événement" }) => {
  if (loading) {
    return (
      <div className="space-y-2">
        {[...Array(3)].map((_, index) => (
          <EventCardSkeleton key={index} size={size} />
        ))}
      </div>
    );
  }

  if (!events || events.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500">
        <svg className="w-12 h-12 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
        </svg>
        <p>{emptyMessage}</p>
      </div>
    );
  }

  return (
    <div className="space-y-2">
      {events.map((event) => (
        <EventCard 
          key={event.id} 
          event={event} 
          size={size}
        />
      ))}
    </div>
  );
};

export default EventCard;
</file>

<file path="sigl_frontend/src/components/LoginForm.jsx">
// sigl_frontend/src/components/LoginForm.jsx
import React, { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import authService from '../services/authService';

const LoginForm = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    rememberMe: true,
  });
  const [errors, setErrors] = useState({});
  const [isLoading, setIsLoading] = useState(false);

  // MFA
  const [step, setStep] = useState('credentials'); // 'credentials' | 'mfa'
  const [pendingUserId, setPendingUserId] = useState(null);
  const [deliveryMethod, setDeliveryMethod] = useState(null); // 'email' | 'sms'
  const [mfaCode, setMfaCode] = useState('');

  const navigate = useNavigate();

  const handleChange = (e) => {
    const { name, type, value, checked } = e.target;
    const fieldValue = type === 'checkbox' ? checked : value;

    setFormData((prev) => ({
      ...prev,
      [name]: fieldValue,
    }));

    setErrors((prev) => ({
      ...prev,
      [name]: undefined,
      submit: undefined,
    }));
  };

  const validateCredentials = () => {
    const newErrors = {};

    if (!formData.email.trim()) {
      newErrors.email = "L'adresse email est obligatoire";
    }

    if (!formData.password) {
      newErrors.password = 'Le mot de passe est obligatoire';
    }

    return newErrors;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setErrors({});
    setIsLoading(true);

    try {
      if (step === 'credentials') {
        const validationErrors = validateCredentials();
        if (Object.keys(validationErrors).length > 0) {
          setErrors(validationErrors);
          setIsLoading(false);
          return;
        }

        const res = await authService.login(
          formData.email.trim(),
          formData.password,
          formData.rememberMe
        );

        if (res.mfaRequired) {
          const data = res.data || {};

          setStep('mfa');
          setPendingUserId(data.userId || data.user?.id || null);
          setDeliveryMethod(data.deliveryMethod || 'email');
          setMfaCode('');
          setErrors({});
          setIsLoading(false);
          return;
        }

        // Login sans MFA : tokens déjà stockés
        navigate('/dashboard');
      } else {
        // Étape MFA
        if (!mfaCode.trim()) {
          setErrors((prev) => ({
            ...prev,
            mfaCode: 'Le code MFA est requis',
          }));
          setIsLoading(false);
          return;
        }

        await authService.verifyMfaCode(
          pendingUserId,
          mfaCode.trim(),
          formData.rememberMe
        );

        navigate('/dashboard');
      }
    } catch (err) {
      console.error('Erreur de connexion :', err);
      const message =
        err?.message ||
        err?.error ||
        err?.response?.data?.message ||
        "Échec de la connexion, veuillez vérifier vos informations.";
      setErrors((prev) => ({
        ...prev,
        submit: message,
      }));
      setIsLoading(false);
    }
  };

  const isCredentialsStep = step === 'credentials';

  return (
    <div className="bg-white rounded-xl shadow-lg p-8">
      <form onSubmit={handleSubmit} className="space-y-6">
        {errors.submit && (
          <div className="rounded-md bg-red-50 p-4 text-sm text-red-700">
            {errors.submit}
          </div>
        )}

        {isCredentialsStep ? (
          <>
            {/* Email */}
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Adresse email
              </label>
              <input
                id="email"
                name="email"
                type="email"
                autoComplete="email"
                className={`block w-full rounded-md border px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-1 focus:ring-primary-500 ${
                  errors.email ? 'border-red-500' : 'border-gray-300'
                }`}
                value={formData.email}
                onChange={handleChange}
              />
              {errors.email && (
                <p className="mt-1 text-xs text-red-600">{errors.email}</p>
              )}
            </div>

            {/* Password */}
            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Mot de passe
              </label>
              <input
                id="password"
                name="password"
                type="password"
                autoComplete="current-password"
                className={`block w-full rounded-md border px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-1 focus:ring-primary-500 ${
                  errors.password ? 'border-red-500' : 'border-gray-300'
                }`}
                value={formData.password}
                onChange={handleChange}
              />
              {errors.password && (
                <p className="mt-1 text-xs text-red-600">{errors.password}</p>
              )}
            </div>

            {/* Remember me + forgot password */}
            <div className="flex items-center justify-between">
              <label className="flex items-center space-x-2 text-sm text-gray-700">
                <input
                  id="rememberMe"
                  name="rememberMe"
                  type="checkbox"
                  checked={formData.rememberMe}
                  onChange={handleChange}
                  className="h-4 w-4 rounded border-gray-300 text-primary-600 focus:ring-primary-500"
                />
                <span>Se souvenir de moi</span>
              </label>

              <Link
                to="/forgot-password"
                className="text-sm text-primary-600 hover:text-primary-700"
              >
                Mot de passe oublié ?
              </Link>
            </div>
          </>
        ) : (
          <>
            <p className="text-sm text-gray-700">
              Un code de vérification a été envoyé par{' '}
              <span className="font-semibold">
                {deliveryMethod === 'sms' ? 'SMS' : 'email'}
              </span>
              .
            </p>

            <div>
              <label
                htmlFor="mfaCode"
                className="block text-sm font-medium text-gray-700 mb-1"
              >
                Code de vérification
              </label>
              <input
                id="mfaCode"
                name="mfaCode"
                type="text"
                inputMode="numeric"
                className={`block w-full rounded-md border px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-1 focus:ring-primary-500 ${
                  errors.mfaCode ? 'border-red-500' : 'border-gray-300'
                }`}
                value={mfaCode}
                onChange={(e) => {
                  setMfaCode(e.target.value);
                  setErrors((prev) => ({
                    ...prev,
                    mfaCode: undefined,
                    submit: undefined,
                  }));
                }}
              />
              {errors.mfaCode && (
                <p className="mt-1 text-xs text-red-600">{errors.mfaCode}</p>
              )}
            </div>

            <button
              type="button"
              className="text-xs text-gray-500 underline"
              onClick={() => {
                setStep('credentials');
                setMfaCode('');
                setErrors({});
              }}
            >
              Retour aux identifiants
            </button>
          </>
        )}

        {/* Submit */}
        <div>
          <button
            type="submit"
            className="btn-primary"
            disabled={isLoading}
          >
            {isLoading ? 'Connexion...' : isCredentialsStep ? 'Se connecter' : 'Valider le code'}
          </button>
        </div>
      </form>

      <p className="mt-4 text-center text-sm text-gray-600">
        Pas encore de compte ?{' '}
        <Link to="/register" className="text-primary-600 hover:text-primary-700">
          Créer un compte
        </Link>
      </p>
    </div>
  );
};

export default LoginForm;
</file>

<file path="sigl_frontend/src/pages/calendar/CalendarPage.jsx">
import React, { useState, useEffect } from 'react';
import CalendarNavigation, { CalendarNavigationMobile } from '../../components/calendar/CalendarNavigation';
import CalendarGrid, { CalendarGridMobile } from '../../components/calendar/CalendarGrid';
import { EventCardList } from '../../components/calendar/EventCard';
import CalendarService from '../../services/calendarService';

/**
 * Page principale du calendrier
 */
const CalendarPage = () => {
  // États du composant
  const [currentDate, setCurrentDate] = useState(new Date());
  const [events, setEvents] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [viewMode, setViewMode] = useState('grid'); // 'grid' ou 'list'
  const [selectedCategory, setSelectedCategory] = useState('');
  const [categories, setCategories] = useState([]);
  const [isMobile, setIsMobile] = useState(false);

  // Détection de la taille d'écran
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };

    checkMobile();
    window.addEventListener('resize', checkMobile);
    
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  // Chargement des catégories au montage du composant
  useEffect(() => {
    const loadCategories = async () => {
      try {
        const categoriesData = await CalendarService.getCategories();
        setCategories(categoriesData);
      } catch (error) {
        console.error('Erreur lors du chargement des catégories:', error);
      }
    };

    loadCategories();
  }, []);

  // Chargement des événements lors du changement de date ou de catégorie
  useEffect(() => {
    const loadEvents = async () => {
      setLoading(true);
      setError(null);

      try {
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth() + 1;

        // Utilisation du cache pour optimiser les performances
        let eventsData = await CalendarService.getCachedEventsByMonth(year, month);

        // Filtrage par catégorie si sélectionnée
        if (selectedCategory) {
          eventsData = eventsData.filter(event => 
            event.category.toLowerCase() === selectedCategory.toLowerCase()
          );
        }

        setEvents(eventsData);
      } catch (error) {
        console.error('Erreur lors du chargement des événements:', error);
        setError(error.message);
        setEvents([]);
      } finally {
        setLoading(false);
      }
    };

    loadEvents();
  }, [currentDate, selectedCategory]);

  // Gestion du changement de date
  const handleDateChange = (newDate) => {
    setCurrentDate(newDate);
  };

  // Gestion du changement de catégorie
  const handleCategoryChange = (category) => {
    setSelectedCategory(category);
  };

  // Gestion du changement de mode d'affichage
  const handleViewModeChange = (mode) => {
    setViewMode(mode);
  };

  // Réinitialisation des filtres
  const resetFilters = () => {
    setSelectedCategory('');
    CalendarService.clearCache();
  };

  // Statistiques des événements
  const eventStats = {
    total: events.length,
    byCategory: categories.reduce((acc, category) => {
      acc[category] = events.filter(event => event.category === category).length;
      return acc;
    }, {})
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* En-tête de la page */}
      <div className="bg-white shadow-sm border-b border-gray-200">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between">
            <div>
              <h1 className="text-3xl font-bold text-gray-900">Calendrier</h1>
              <p className="mt-1 text-sm text-gray-500">
                Gérez et consultez vos événements
              </p>
            </div>

            {/* Contrôles de la page */}
            <div className="mt-4 sm:mt-0 flex flex-col sm:flex-row gap-3">
              {/* Sélecteur de catégorie */}
              <div className="flex items-center space-x-2">
                <label htmlFor="category-select" className="text-sm font-medium text-gray-700">
                  Catégorie:
                </label>
                <select
                  id="category-select"
                  value={selectedCategory}
                  onChange={(e) => handleCategoryChange(e.target.value)}
                  className="rounded-md border-gray-300 text-sm focus:border-primary-500 focus:ring-primary-500"
                  disabled={loading}
                >
                  <option value="">Toutes</option>
                  {categories.map((category) => (
                    <option key={category} value={category}>
                      {category} ({eventStats.byCategory[category] || 0})
                    </option>
                  ))}
                </select>
              </div>

              {/* Sélecteur de mode d'affichage (desktop uniquement) */}
              {!isMobile && (
                <div className="flex rounded-md shadow-sm">
                  <button
                    onClick={() => handleViewModeChange('grid')}
                    className={`
                      px-3 py-2 text-sm font-medium rounded-l-md border
                      ${viewMode === 'grid'
                        ? 'bg-primary-500 text-white border-primary-500'
                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                      }
                    `}
                    disabled={loading}
                  >
                    <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                    </svg>
                  </button>
                  <button
                    onClick={() => handleViewModeChange('list')}
                    className={`
                      px-3 py-2 text-sm font-medium rounded-r-md border-t border-r border-b
                      ${viewMode === 'list'
                        ? 'bg-primary-500 text-white border-primary-500'
                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                      }
                    `}
                    disabled={loading}
                  >
                    <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clipRule="evenodd" />
                    </svg>
                  </button>
                </div>
              )}

              {/* Bouton de réinitialisation */}
              {selectedCategory && (
                <button
                  onClick={resetFilters}
                  className="px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
                  disabled={loading}
                >
                  Réinitialiser
                </button>
              )}
            </div>
          </div>

          {/* Statistiques */}
          <div className="mt-4 flex flex-wrap gap-4 text-sm text-gray-600">
            <span>
              <strong>{eventStats.total}</strong> événement{eventStats.total > 1 ? 's' : ''} ce mois
            </span>
            {selectedCategory && (
              <span>
                Catégorie: <strong>{selectedCategory}</strong>
              </span>
            )}
          </div>
        </div>
      </div>

      {/* Contenu principal */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        {/* Message d'erreur */}
        {error && (
          <div className="mb-6 bg-red-50 border border-red-200 rounded-md p-4">
            <div className="flex">
              <svg className="w-5 h-5 text-red-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
              </svg>
              <div className="ml-3">
                <h3 className="text-sm font-medium text-red-800">
                  Erreur de chargement
                </h3>
                <p className="mt-1 text-sm text-red-700">{error}</p>
                <button
                  onClick={() => window.location.reload()}
                  className="mt-2 text-sm text-red-800 underline hover:text-red-900"
                >
                  Réessayer
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Navigation du calendrier */}
        {isMobile ? (
          <CalendarNavigationMobile
            currentDate={currentDate}
            onDateChange={handleDateChange}
            loading={loading}
          />
        ) : (
          <CalendarNavigation
            currentDate={currentDate}
            onDateChange={handleDateChange}
            loading={loading}
          />
        )}

        {/* Affichage du calendrier */}
        {isMobile ? (
          <CalendarGridMobile
            currentDate={currentDate}
            events={events}
            loading={loading}
          />
        ) : viewMode === 'grid' ? (
          <CalendarGrid
            currentDate={currentDate}
            events={events}
            loading={loading}
          />
        ) : (
          <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
            <h2 className="text-lg font-semibold text-gray-900 mb-4">
              Événements de {currentDate.toLocaleDateString('fr-FR', { month: 'long', year: 'numeric' })}
            </h2>
            <EventCardList
              events={events}
              loading={loading}
              size="large"
              emptyMessage={`Aucun événement${selectedCategory ? ` dans la catégorie "${selectedCategory}"` : ''} pour ce mois.`}
            />
          </div>
        )}
      </div>
    </div>
  );
};

export default CalendarPage;
</file>

<file path="sigl_frontend/src/pages/calendar/EventDetailPage.jsx">
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import CalendarService from '../../services/calendarService';

/**
 * Page de détail d'un événement
 * Affiche toutes les informations d'un événement spécifique
 */
const EventDetailPage = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  
  // États du composant
  const [event, setEvent] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);

  // Chargement de l'événement
  useEffect(() => {
    const loadEvent = async () => {
      if (!id) {
        setError('ID d\'événement manquant');
        setLoading(false);
        return;
      }

      setLoading(true);
      setError(null);

      try {
        const eventData = await CalendarService.getEventById(id);
        setEvent(eventData);
      } catch (error) {
        console.error('Erreur lors du chargement de l\'événement:', error);
        setError(error.message || 'Erreur lors du chargement de l\'événement');
      } finally {
        setLoading(false);
      }
    };

    loadEvent();
  }, [id, retryCount]);

  // Fonction de retry
  const handleRetry = () => {
    setRetryCount(prev => prev + 1);
  };

  // Fonction de retour
  const handleBack = () => {
    navigate('/calendar');
  };

  // Fonction de partage (placeholder)
  const handleShare = () => {
    if (navigator.share && event) {
      navigator.share({
        title: event.title,
        text: `${event.title} - ${CalendarService.formatDate(event.date)} à ${CalendarService.formatTime(event.time)}`,
        url: window.location.href
      }).catch(console.error);
    } else {
      // Fallback: copier l'URL
      navigator.clipboard.writeText(window.location.href).then(() => {
        alert('Lien copié dans le presse-papiers');
      }).catch(console.error);
    }
  };

  // Fonction d'impression
  const handlePrint = () => {
    window.print();
  };

  // Composant de chargement
  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50">
        {/* Header avec skeleton */}
        <div className="bg-white shadow-sm border-b border-gray-200">
          <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <div className="animate-pulse">
              <div className="h-4 bg-gray-300 rounded w-48 mb-2"></div>
              <div className="h-8 bg-gray-300 rounded w-64"></div>
            </div>
          </div>
        </div>

        {/* Contenu avec skeleton */}
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 animate-pulse">
            <div className="space-y-6">
              <div className="h-6 bg-gray-300 rounded w-3/4"></div>
              <div className="h-4 bg-gray-300 rounded w-1/2"></div>
              <div className="h-4 bg-gray-300 rounded w-2/3"></div>
              <div className="space-y-2">
                <div className="h-4 bg-gray-300 rounded"></div>
                <div className="h-4 bg-gray-300 rounded"></div>
                <div className="h-4 bg-gray-300 rounded w-5/6"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Gestion des erreurs
  if (error) {
    return (
      <div className="min-h-screen bg-gray-50">
        {/* Header */}
        <div className="bg-white shadow-sm border-b border-gray-200">
          <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
            <nav className="flex items-center space-x-2 text-sm text-gray-500 mb-4">
              <Link to="/calendar" className="hover:text-gray-700">Calendrier</Link>
              <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 111.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
              </svg>
              <span>Événement</span>
            </nav>
            <h1 className="text-3xl font-bold text-gray-900">Événement non trouvé</h1>
          </div>
        </div>

        {/* Message d'erreur */}
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-8 text-center">
            <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
              <svg className="h-6 w-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 19.5c-.77.833.192 2.5 1.732 2.5z" />
              </svg>
            </div>
            <h3 className="text-lg font-medium text-gray-900 mb-2">Erreur de chargement</h3>
            <p className="text-gray-600 mb-6">{error}</p>
            <div className="flex flex-col sm:flex-row gap-3 justify-center">
              <button
                onClick={handleRetry}
                className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                Réessayer
              </button>
              <button
                onClick={handleBack}
                className="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                </svg>
                Retour au calendrier
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Affichage de l'événement
  if (!event) {
    return null;
  }

  const colors = CalendarService.getCategoryColor(event.category);
  const formattedDate = CalendarService.formatDate(event.date);
  const formattedTime = CalendarService.formatTime(event.time);

  return (
    <div className="min-h-screen bg-gray-50 print:bg-white">
      {/* Header */}
      <div className="bg-white shadow-sm border-b border-gray-200 print:shadow-none print:border-b-2">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
          {/* Breadcrumb */}
          <nav className="flex items-center space-x-2 text-sm text-gray-500 mb-4 print:hidden">
            <Link to="/calendar" className="hover:text-gray-700 transition-colors">
              Calendrier
            </Link>
            <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 111.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
            </svg>
            <span className="text-gray-900">Détails de l'événement</span>
          </nav>

          {/* Titre et actions */}
          <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between">
            <div className="flex-1">
              <div className="flex items-center gap-3 mb-2">
                <div className={`w-3 h-3 rounded-full ${colors.dot} flex-shrink-0`}></div>
                <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${colors.bg} ${colors.text} border ${colors.border}`}>
                  {event.category}
                </span>
              </div>
              <h1 className="text-3xl font-bold text-gray-900 leading-tight">
                {event.title}
              </h1>
            </div>

            {/* Actions */}
            <div className="mt-4 sm:mt-0 flex flex-col sm:flex-row gap-2 print:hidden">
              <button
                onClick={handleShare}
                className="inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
              >
                <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z" />
                </svg>
                Partager
              </button>
              <button
                onClick={handlePrint}
                className="inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
              >
                <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z" />
                </svg>
                Imprimer
              </button>
              <button
                onClick={handleBack}
                className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
              >
                <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                </svg>
                Retour
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Contenu principal */}
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden print:shadow-none print:border">
          {/* Informations principales */}
          <div className="p-6 sm:p-8">
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
              {/* Colonne principale */}
              <div className="lg:col-span-2 space-y-6">
                {/* Date et heure */}
                <div className="flex items-start space-x-4">
                  <div className="flex-shrink-0">
                    <div className="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center">
                      <svg className="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                      </svg>
                    </div>
                  </div>
                  <div>
                    <h3 className="text-lg font-semibold text-gray-900 mb-1">Date et heure</h3>
                    <p className="text-gray-700 font-medium">{formattedDate}</p>
                    {event.time && (
                      <p className="text-gray-600">à {formattedTime}</p>
                    )}
                  </div>
                </div>

                {/* Lieu */}
                {event.location && (
                  <div className="flex items-start space-x-4">
                    <div className="flex-shrink-0">
                      <div className="w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center">
                        <svg className="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                      </div>
                    </div>
                    <div>
                      <h3 className="text-lg font-semibold text-gray-900 mb-1">Lieu</h3>
                      <p className="text-gray-700 leading-relaxed">{event.location}</p>
                      {/* Placeholder pour carte */}
                      <div className="mt-3 p-4 bg-gray-50 rounded-lg border-2 border-dashed border-gray-300 text-center text-gray-500 text-sm print:hidden">
                        <svg className="w-8 h-8 mx-auto mb-2 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-1.447-.894L15 4m0 13V4m-6 3l6-3" />
                        </svg>
                        Carte à intégrer
                      </div>
                    </div>
                  </div>
                )}

                {/* Description */}
                {event.description && (
                  <div className="flex items-start space-x-4">
                    <div className="flex-shrink-0">
                      <div className="w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center">
                        <svg className="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                      </div>
                    </div>
                    <div>
                      <h3 className="text-lg font-semibold text-gray-900 mb-3">Description</h3>
                      <div className="prose prose-gray max-w-none">
                        <p className="text-gray-700 leading-relaxed whitespace-pre-wrap">
                          {event.description}
                        </p>
                      </div>
                    </div>
                  </div>
                )}
              </div>

              {/* Sidebar */}
              <div className="lg:col-span-1">
                <div className="bg-gray-50 rounded-lg p-6 space-y-6 print:bg-gray-100">
                  <h3 className="text-lg font-semibold text-gray-900">Informations</h3>
                  
                  {/* Catégorie */}
                  <div>
                    <dt className="text-sm font-medium text-gray-500 mb-1">Catégorie</dt>
                    <dd className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-sm font-medium ${colors.bg} ${colors.text} border ${colors.border}`}>
                      {event.category}
                    </dd>
                  </div>

                  {/* ID de l'événement */}
                  <div>
                    <dt className="text-sm font-medium text-gray-500 mb-1">ID</dt>
                    <dd className="text-sm text-gray-900 font-mono">#{event.id}</dd>
                  </div>

                  {/* Date de création (placeholder) */}
                  <div className="print:hidden">
                    <dt className="text-sm font-medium text-gray-500 mb-1">Actions rapides</dt>
                    <dd className="space-y-2">
                      <button
                        onClick={() => window.open(`https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(event.title)}&dates=${event.date.replace(/-/g, '')}T${event.time?.replace(':', '') || '0000'}00/${event.date.replace(/-/g, '')}T${event.time?.replace(':', '') || '0000'}00&details=${encodeURIComponent(event.description || '')}&location=${encodeURIComponent(event.location || '')}`, '_blank')}
                        className="w-full text-left px-3 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md transition-colors"
                      >
                        <svg className="w-4 h-4 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
                          <path fillRule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clipRule="evenodd" />
                        </svg>
                        Ajouter à Google Calendar
                      </button>
                    </dd>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Navigation entre événements (placeholder) */}
        <div className="mt-8 flex justify-between items-center print:hidden">
          <button
            onClick={() => navigate(`/calendar/event/${parseInt(id) - 1}`)}
            disabled={parseInt(id) <= 1}
            className="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
            Événement précédent
          </button>
          
          <button
            onClick={() => navigate(`/calendar/event/${parseInt(id) + 1}`)}
            className="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
          >
            Événement suivant
            <svg className="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </button>
        </div>
      </div>
    </div>
  );
};

export default EventDetailPage;
</file>

<file path="sigl_frontend/src/pages/HomePage.jsx">
// sigl_frontend/src/pages/HomePage.jsx
import React from 'react';
import LoginForm from '../components/LoginForm';

const HomePage = () => {
  return (
    <div className="min-h-screen flex bg-gray-50">
      {/* Colonne gauche : login */}
      <div className="w-full lg:w-1/2 flex items-center justify-center p-8 bg-white">
        <div className="w-full max-w-md">
          {/* Logo + titre */}
          <div className="mb-8">
            <div className="flex items-center space-x-3 mb-6">
              <div className="w-12 h-12 bg-primary-600 rounded-xl flex items-center justify-center">
                <span className="text-white font-bold text-2xl">I</span>
              </div>
              <h1 className="text-3xl font-bold text-gray-800">IZIA</h1>
            </div>
            <h2 className="text-2xl font-semibold text-gray-800 mb-2">
              Bienvenue sur votre plateforme
            </h2>
            <p className="text-sm text-gray-600">
              Connectez-vous pour accéder à vos informations d&apos;apprenti,
              votre journal de bord et le suivi avec vos encadrants.
            </p>
          </div>

          <LoginForm />
        </div>
      </div>

      {/* Colonne droite (visuel / texte) */}
      <div className="hidden lg:flex w-1/2 bg-primary-600 text-white items-center justify-center p-8">
        <div className="max-w-md space-y-4">
          <h2 className="text-3xl font-bold">Suivi simplifié de votre alternance</h2>
          <p className="text-sm text-primary-100">
            Retrouvez vos journaux de bord, vos évaluations, vos soutenances et vos
            échanges avec vos encadrants au même endroit.
          </p>
        </div>
      </div>
    </div>
  );
};

export default HomePage;
</file>

<file path="sigl_frontend/src/pages/RegisterPage.jsx">
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import authService from '../services/authService';

const RegisterPage = () => {
  const navigate = useNavigate();

  const [formData, setFormData] = useState({
    // Champs obligatoires
    nom: '',
    prenom: '',
    dateNaissance: '',
    email: '',
    telephone: '',
    password: '',
    confirmPassword: '',
    // Champ optionnel
    codePostal: '',
  });

  const [errors, setErrors] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);

  // Validation champ par champ
  const validateField = (name, value) => {
    let error = '';

    switch (name) {
      case 'nom':
      case 'prenom':
        if (!value.trim()) {
          error = 'Ce champ est requis';
        } else if (!/^[a-zA-ZÀ-ÿ\s\-']+$/.test(value)) {
          error = 'Uniquement des lettres, espaces et tirets autorisés';
        } else if (value.length < 2) {
          error = 'Minimum 2 caractères';
        }
        break;

      case 'dateNaissance': {
        if (!value) {
          error = 'La date de naissance est requise';
        } else {
          const date = new Date(value);
          const today = new Date();
          const age = today.getFullYear() - date.getFullYear();

          if (isNaN(date.getTime())) {
            error = 'Date invalide';
          } else if (age < 16) {
            error = 'Vous devez avoir au moins 16 ans';
          } else if (age > 100) {
            error = 'Date de naissance non valide';
          }
        }
        break;
      }

      case 'telephone':
        if (!value.trim()) {
          error = 'Le numéro de téléphone est requis';
        } else if (!/^0\d{9}$/.test(value)) {
          error = 'Le numéro doit contenir 10 chiffres et commencer par 0';
        }
        break;

      case 'email':
        if (!value.trim()) {
          error = "L'email est requis";
        } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
          error = "Format d'email invalide (doit contenir @)";
        } else if (!value.endsWith('@reseau.eseo.fr')) {
          error = "L'email doit se terminer par @reseau.eseo.fr";
        }
        break;

      case 'codePostal':
        if (value.trim() && !/^\d{5}$/.test(value)) {
          error = 'Le code postal doit contenir exactement 5 chiffres';
        }
        break;

      case 'password':
        if (!value) {
          error = 'Le mot de passe est requis';
        } else if (value.length < 8) {
          error = 'Minimum 8 caractères';
        } else if (!/[A-Z]/.test(value)) {
          error = 'Au moins une majuscule requise';
        } else if (!/[a-z]/.test(value)) {
          error = 'Au moins une minuscule requise';
        } else if (!/[0-9]/.test(value)) {
          error = 'Au moins un chiffre requis';
        } else if (!/[!@#$%^&*]/.test(value)) {
          error = 'Au moins un caractère spécial requis (!@#$%^&*)';
        }
        break;

      case 'confirmPassword':
        if (!value) {
          error = 'Veuillez confirmer votre mot de passe';
        } else if (value !== formData.password) {
          error = 'Les mots de passe ne correspondent pas';
        }
        break;

      default:
        break;
    }

    return error;
  };

  const handleChange = (e) => {
    const { name, value } = e.target;

    let formattedValue = value;
    if (name === 'telephone') {
      formattedValue = value.replace(/\D/g, '').slice(0, 10);
    }
    if (name === 'codePostal') {
      formattedValue = value.replace(/\D/g, '').slice(0, 5);
    }

    setFormData((prev) => ({
      ...prev,
      [name]: formattedValue,
    }));

    const error = validateField(name, formattedValue);
    setErrors((prev) => ({
      ...prev,
      [name]: error,
    }));

    if (name === 'password' && formData.confirmPassword) {
      const confirmError =
        formattedValue !== formData.confirmPassword
          ? 'Les mots de passe ne correspondent pas'
          : '';
      setErrors((prev) => ({
        ...prev,
        confirmPassword: confirmError,
      }));
    }
  };

  const validateForm = () => {
    const newErrors = {};
    const requiredFields = [
      'nom',
      'prenom',
      'dateNaissance',
      'email',
      'telephone',
      'password',
      'confirmPassword',
    ];

    requiredFields.forEach((key) => {
      const error = validateField(key, formData[key]);
      if (error) newErrors[key] = error;
    });

    if (formData.codePostal) {
      const error = validateField('codePostal', formData.codePostal);
      if (error) newErrors.codePostal = error;
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) return;

    setIsLoading(true);

    try {
      const username = `${formData.prenom.toLowerCase()}_${formData.nom.toLowerCase()}`
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/\s/g, '');

      const userData = {
        username,
        email: formData.email,
        password: formData.password,
        role: 'APPRENTI',
        firstName: formData.prenom,
        lastName: formData.nom,
        birthDate: formData.dateNaissance,
        phone: formData.telephone,
        postalCode: formData.codePostal || null,
      };

      const response = await authService.register(userData);
      console.log('✅ Inscription réussie :', response);

      navigate('/', {
        state: {
          message: 'Compte créé avec succès ! Vous pouvez maintenant vous connecter.',
          email: formData.email,
        },
      });
    } catch (error) {
      console.error("❌ Erreur d'inscription :", error);
      let errorMessage = "Une erreur est survenue lors de l'inscription";

      if (error.error) errorMessage = error.error;
      else if (error.message) errorMessage = error.message;

      setErrors({ submit: errorMessage });
    } finally {
      setIsLoading(false);
    }
  };

  const getPasswordStrength = (password) => {
    let strength = 0;
    if (password.length >= 8) strength++;
    if (/[A-Z]/.test(password)) strength++;
    if (/[a-z]/.test(password)) strength++;
    if (/[0-9]/.test(password)) strength++;
    if (/[!@#$%^&*]/.test(password)) strength++;
    return strength;
  };

  const passwordStrength = getPasswordStrength(formData.password);

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 flex items-center justify-center p-4 py-12">
      <div className="w-full max-w-3xl">
        {/* Header */}
        <div className="text-center mb-8">
          <div className="flex items-center justify-center space-x-3 mb-4">
            <div className="w-12 h-12 bg-primary-600 rounded-xl flex items-center justify-center">
              <span className="text-white font-bold text-2xl">I</span>
            </div>
            <h1 className="text-3xl font-bold text-gray-800">IZIA</h1>
          </div>
          <h2 className="text-2xl font-semibold text-gray-800 mb-2">
            Créer votre compte
          </h2>
          <p className="text-gray-600">
            Remplissez les informations obligatoires pour vous inscrire
          </p>
        </div>

        {/* Formulaire */}
        <div className="bg-white rounded-xl shadow-lg p-8">
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Section Identité */}
            <section>
              <h3 className="text-lg font-semibold text-gray-800 mb-4">
                Informations personnelles
              </h3>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Nom <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="text"
                    name="nom"
                    value={formData.nom}
                    onChange={handleChange}
                    className={`input-field ${errors.nom ? 'border-red-500' : ''}`}
                  />
                  {errors.nom && (
                    <p className="text-xs text-red-500 mt-1">{errors.nom}</p>
                  )}
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Prénom <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="text"
                    name="prenom"
                    value={formData.prenom}
                    onChange={handleChange}
                    className={`input-field ${errors.prenom ? 'border-red-500' : ''}`}
                  />
                  {errors.prenom && (
                    <p className="text-xs text-red-500 mt-1">{errors.prenom}</p>
                  )}
                </div>
              </div>

              <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Date de naissance <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="date"
                    name="dateNaissance"
                    value={formData.dateNaissance}
                    onChange={handleChange}
                    className={`input-field ${errors.dateNaissance ? 'border-red-500' : ''}`}
                  />
                  {errors.dateNaissance && (
                    <p className="text-xs text-red-500 mt-1">
                      {errors.dateNaissance}
                    </p>
                  )}
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Code postal
                  </label>
                  <input
                    type="text"
                    name="codePostal"
                    value={formData.codePostal}
                    onChange={handleChange}
                    className={`input-field ${errors.codePostal ? 'border-red-500' : ''}`}
                  />
                  {errors.codePostal && (
                    <p className="text-xs text-red-500 mt-1">
                      {errors.codePostal}
                    </p>
                  )}
                </div>
              </div>
            </section>

            {/* Section contact & connexion */}
            <section>
              <h3 className="text-lg font-semibold text-gray-800 mb-4">
                Contact & connexion
              </h3>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Adresse e-mail <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="email"
                    name="email"
                    value={formData.email}
                    onChange={handleChange}
                    className={`input-field ${errors.email ? 'border-red-500' : ''}`}
                    placeholder="prenom.nom@reseau.eseo.fr"
                  />
                  <p className="text-xs text-gray-500 mt-1">
                    Doit se terminer par <span className="font-mono">@reseau.eseo.fr</span>.
                  </p>
                  {errors.email && (
                    <p className="text-xs text-red-500 mt-1">{errors.email}</p>
                  )}
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Téléphone portable <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="tel"
                    name="telephone"
                    value={formData.telephone}
                    onChange={handleChange}
                    className={`input-field ${errors.telephone ? 'border-red-500' : ''}`}
                    placeholder="0XXXXXXXXX"
                    maxLength={10}
                  />
                  <p className="text-xs text-gray-500 mt-1">
                    10 chiffres, commençant par 0 (utilisé pour certains scénarios MFA par SMS).
                  </p>
                  {errors.telephone && (
                    <p className="text-xs text-red-500 mt-1">
                      {errors.telephone}
                    </p>
                  )}
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Mot de passe <span className="text-red-500">*</span>
                    </label>
                    <div className="relative">
                      <input
                        type={showPassword ? 'text' : 'password'}
                        name="password"
                        value={formData.password}
                        onChange={handleChange}
                        className={`input-field pr-10 ${
                          errors.password ? 'border-red-500' : ''
                        }`}
                      />
                      <button
                        type="button"
                        onClick={() => setShowPassword((v) => !v)}
                        className="absolute inset-y-0 right-0 px-3 flex items-center text-sm text-gray-500"
                      >
                        {showPassword ? 'Masquer' : 'Afficher'}
                      </button>
                    </div>
                    {errors.password && (
                      <p className="text-xs text-red-500 mt-1">
                        {errors.password}
                      </p>
                    )}

                    {/* Indicateur de force */}
                    <div className="mt-2">
                      <div className="flex justify-between text-xs text-gray-500 mb-1">
                        <span>Force du mot de passe</span>
                      </div>
                      <div className="flex space-x-1">
                        {[1, 2, 3, 4, 5].map((level) => (
                          <div
                            key={level}
                            className={`h-1 flex-1 rounded-full ${
                              passwordStrength >= level
                                ? 'bg-green-500'
                                : 'bg-gray-200'
                            }`}
                          />
                        ))}
                      </div>
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Confirmation du mot de passe <span className="text-red-500">*</span>
                    </label>
                    <div className="relative">
                      <input
                        type={showConfirmPassword ? 'text' : 'password'}
                        name="confirmPassword"
                        value={formData.confirmPassword}
                        onChange={handleChange}
                        className={`input-field pr-10 ${
                          errors.confirmPassword ? 'border-red-500' : ''
                        }`}
                      />
                      <button
                        type="button"
                        onClick={() => setShowConfirmPassword((v) => !v)}
                        className="absolute inset-y-0 right-0 px-3 flex items-center text-sm text-gray-500"
                      >
                        {showConfirmPassword ? 'Masquer' : 'Afficher'}
                      </button>
                    </div>
                    {errors.confirmPassword && (
                      <p className="text-xs text-red-500 mt-1">
                        {errors.confirmPassword}
                      </p>
                    )}
                  </div>
                </div>
              </div>
            </section>

            {/* Erreur globale */}
            {errors.submit && (
              <div className="rounded-md bg-red-50 p-3 border border-red-200">
                <p className="text-sm text-red-700 flex items-center">
                  {errors.submit}
                </p>
              </div>
            )}

            {/* Boutons */}
            <div className="flex items-center justify-between pt-4">
              <Link
                to="/"
                className="text-gray-600 hover:text-gray-800 font-medium flex items-center"
              >
                <svg
                  className="w-4 h-4 mr-1"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M10 19l-7-7m0 0l7-7m-7 7h18"
                  />
                </svg>
                Retour à la connexion
              </Link>

              <button
                type="submit"
                className="btn-primary"
                disabled={isLoading}
              >
                {isLoading ? (
                  <span className="flex items-center">
                    <svg
                      className="animate-spin -ml-1 mr-2 h-4 w-4 text-white"
                      fill="none"
                      viewBox="0 0 24 24"
                    >
                      <circle
                        className="opacity-25"
                        cx="12"
                        cy="12"
                        r="10"
                        stroke="currentColor"
                        strokeWidth="4"
                      />
                      <path
                        className="opacity-75"
                        fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                      />
                    </svg>
                    Inscription en cours...
                  </span>
                ) : (
                  'Créer mon compte'
                )}
              </button>
            </div>
          </form>
        </div>

        <p className="text-center text-sm text-gray-600 mt-6">
          <span className="text-red-500">*</span> Champs obligatoires
        </p>
      </div>
    </div>
  );
};

export default RegisterPage;
</file>

<file path="sigl_frontend/src/pages/soutenance/PlanifierSoutenancePage.jsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import bookingService from '../../services/bookingService';

const PlanifierSoutenancePage = () => {
    const navigate = useNavigate();

    const [formData, setFormData] = useState({
        apprentiId: '',
        date: '',
        heure: '',
        salle: '',
        professeurIds: []
    });
    const [errors, setErrors] = useState({});
    const [isLoading, setIsLoading] = useState(false);
    const [users, setUsers] = useState({ apprentis: [], professeurs: [] });
    const [loadingUsers, setLoadingUsers] = useState(true);

    useEffect(() => {
        loadUsers();
    }, []);

    const loadUsers = async () => {
        try {
            const result = await bookingService.getAvailableContacts();
            if (result.success) {
                const allUsers = result.users || [];
                setUsers({
                    apprentis: allUsers.filter(u => u.role === 'APPRENTI'),
                    professeurs: allUsers.filter(u => u.role === 'PROF')
                });
            }
        } catch (err) {
            console.error('Erreur chargement utilisateurs:', err);
        } finally {
            setLoadingUsers(false);
        }
    };

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
    };

    const handleProfToggle = (profId) => {
        setFormData(prev => {
            const profs = prev.professeurIds.includes(profId)
                ? prev.professeurIds.filter(id => id !== profId)
                : [...prev.professeurIds, profId];
            return { ...prev, professeurIds: profs };
        });
    };

    const validateForm = () => {
        const newErrors = {};
        if (!formData.apprentiId) newErrors.apprentiId = 'Sélectionnez un apprenti';
        if (!formData.date) newErrors.date = 'La date est requise';
        if (!formData.heure) newErrors.heure = 'L\'heure est requise';
        if (formData.professeurIds.length < 3) {
            newErrors.professeurs = 'Sélectionnez au moins 3 professeurs (max 5)';
        }
        if (formData.professeurIds.length > 5) {
            newErrors.professeurs = 'Maximum 5 professeurs dans le jury';
        }
        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!validateForm()) return;

        setIsLoading(true);
        try {
            const dateHeure = `${formData.date}T${formData.heure}:00`;

            await bookingService.planifierSoutenance(
                formData.apprentiId,
                dateHeure,
                formData.salle,
                formData.professeurIds
            );

            alert('Soutenance planifiée avec succès !');
            navigate('/soutenance/gestion');
        } catch (error) {
            setErrors({ submit: error.response?.data?.error || 'Erreur lors de la planification' });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="min-h-screen bg-gray-50">
            {/* Header */}
            <header className="bg-white shadow-sm border-b border-gray-200">
                <div className="max-w-3xl mx-auto px-4 py-4 flex items-center space-x-3">
                    <button onClick={() => navigate('/soutenance/gestion')} className="text-gray-600 hover:text-gray-800">
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                        </svg>
                    </button>
                    <h1 className="text-xl font-bold text-gray-800">🎓 Planifier une Soutenance</h1>
                </div>
            </header>

            {/* Formulaire */}
            <div className="max-w-3xl mx-auto px-4 py-8">
                <div className="bg-white rounded-lg shadow p-6">
                    <form onSubmit={handleSubmit} className="space-y-6">
                        {/* Apprenti */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1">
                                Apprenti <span className="text-red-500">*</span>
                            </label>
                            {loadingUsers ? (
                                <div className="text-gray-500">Chargement...</div>
                            ) : (
                                <select
                                    name="apprentiId"
                                    value={formData.apprentiId}
                                    onChange={handleChange}
                                    className={`input-field ${errors.apprentiId ? 'border-red-500' : ''}`}
                                >
                                    <option value="">Sélectionner un apprenti</option>
                                    {users.apprentis.map(a => (
                                        <option key={a._id} value={a._id}>{a.nom} ({a.email})</option>
                                    ))}
                                </select>
                            )}
                            {errors.apprentiId && <p className="mt-1 text-xs text-red-600">{errors.apprentiId}</p>}
                        </div>

                        {/* Date et heure */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-1">
                                    Date <span className="text-red-500">*</span>
                                </label>
                                <input
                                    type="date"
                                    name="date"
                                    value={formData.date}
                                    onChange={handleChange}
                                    className={`input-field ${errors.date ? 'border-red-500' : ''}`}
                                    min={new Date().toISOString().split('T')[0]}
                                />
                                {errors.date && <p className="mt-1 text-xs text-red-600">{errors.date}</p>}
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-700 mb-1">
                                    Heure <span className="text-red-500">*</span>
                                </label>
                                <input
                                    type="time"
                                    name="heure"
                                    value={formData.heure}
                                    onChange={handleChange}
                                    className={`input-field ${errors.heure ? 'border-red-500' : ''}`}
                                />
                                {errors.heure && <p className="mt-1 text-xs text-red-600">{errors.heure}</p>}
                            </div>
                        </div>

                        {/* Salle */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1">Salle</label>
                            <input
                                type="text"
                                name="salle"
                                value={formData.salle}
                                onChange={handleChange}
                                className="input-field"
                                placeholder="Ex: Salle A101, Amphithéâtre B..."
                            />
                        </div>

                        {/* Jury */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">
                                Composition du jury (3-5 professeurs) <span className="text-red-500">*</span>
                            </label>
                            <p className="text-sm text-gray-500 mb-3">
                                Sélectionnés: {formData.professeurIds.length}/5
                            </p>
                            {loadingUsers ? (
                                <div className="text-gray-500">Chargement...</div>
                            ) : users.professeurs.length === 0 ? (
                                <div className="text-red-500">Aucun professeur disponible</div>
                            ) : (
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-2 max-h-64 overflow-y-auto">
                                    {users.professeurs.map(prof => (
                                        <label
                                            key={prof._id}
                                            className={`flex items-center p-3 border-2 rounded-lg cursor-pointer transition ${
                                                formData.professeurIds.includes(prof._id)
                                                    ? 'border-primary-500 bg-primary-50'
                                                    : 'border-gray-200 hover:border-gray-300'
                                            }`}
                                        >
                                            <input
                                                type="checkbox"
                                                checked={formData.professeurIds.includes(prof._id)}
                                                onChange={() => handleProfToggle(prof._id)}
                                                className="w-4 h-4 text-primary-600 mr-3"
                                            />
                                            <div>
                                                <div className="font-medium text-gray-800">{prof.nom}</div>
                                                <div className="text-xs text-gray-500">{prof.email}</div>
                                            </div>
                                        </label>
                                    ))}
                                </div>
                            )}
                            {errors.professeurs && <p className="mt-2 text-xs text-red-600">{errors.professeurs}</p>}
                        </div>

                        {/* Erreur générale */}
                        {errors.submit && (
                            <div className="bg-red-50 border border-red-200 rounded-lg p-4 text-red-800">
                                {errors.submit}
                            </div>
                        )}

                        {/* Boutons */}
                        <div className="flex justify-between pt-4">
                            <button
                                type="button"
                                onClick={() => navigate('/soutenance/gestion')}
                                className="px-6 py-3 border border-gray-300 text-gray-700 rounded-lg font-medium hover:bg-gray-50"
                            >
                                Annuler
                            </button>
                            <button
                                type="submit"
                                disabled={isLoading}
                                className="btn-primary"
                            >
                                {isLoading ? 'Planification...' : 'Planifier la soutenance'}
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    );
};

export default PlanifierSoutenancePage;
</file>

<file path="sigl_frontend/src/services/Api.js">
// sigl_frontend/src/services/Api.js
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000/api';

// Instance Axios principale
const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000,
});

/**
 * Récupère une valeur en priorisant la session, puis le localStorage.
 */
function getFromAnyStorage(key) {
  if (typeof window === 'undefined') return null;

  try {
    const sessionValue = window.sessionStorage.getItem(key);
    if (sessionValue !== null && sessionValue !== undefined) {
      return sessionValue;
    }
    return window.localStorage.getItem(key);
  } catch {
    return null;
  }
}

/**
 * Enregistre les tokens dans le même storage que celui qui contenait le refresh token.
 */
function storeTokensFromRefresh(accessToken, newRefreshToken) {
  if (typeof window === 'undefined') return;

  try {
    const sessionRefresh = window.sessionStorage.getItem('refreshToken');
    const localRefresh = window.localStorage.getItem('refreshToken');

    let target = window.localStorage;

    if (sessionRefresh && !localRefresh) {
      target = window.sessionStorage;
    } else if (sessionRefresh && localRefresh) {
      if (sessionRefresh === newRefreshToken) {
        target = window.sessionStorage;
      } else if (localRefresh === newRefreshToken) {
        target = window.localStorage;
      }
    }

    target.setItem('accessToken', accessToken);
    if (newRefreshToken) {
      target.setItem('refreshToken', newRefreshToken);
    }
  } catch {
    // ignore
  }
}

/**
 * Supprime tokens + user de tous les storages.
 */
function clearAuthEverywhere() {
  if (typeof window === 'undefined') return;

  try {
    [window.localStorage, window.sessionStorage].forEach((store) => {
      if (!store) return;
      store.removeItem('accessToken');
      store.removeItem('refreshToken');
      store.removeItem('user');
    });
  } catch {
    // ignore
  }
}

// Intercepteur pour ajouter le token JWT
api.interceptors.request.use(
  (config) => {
    const token = getFromAnyStorage('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Intercepteur pour gérer les erreurs et refresh token
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = getFromAnyStorage('refreshToken');

        if (refreshToken) {
          const response = await axios.post(
            `${API_URL}/auth/refresh`,
            {},
            {
              headers: {
                Authorization: `Bearer ${refreshToken}`,
              },
            }
          );

          const { accessToken, refreshToken: newRefreshToken } =
            response.data?.data || {};

          if (!accessToken) {
            throw new Error('Réponse refresh invalide');
          }

          storeTokensFromRefresh(accessToken, newRefreshToken);

          originalRequest.headers.Authorization = `Bearer ${accessToken}`;
          return api(originalRequest);
        }
      } catch (refreshError) {
        clearAuthEverywhere();
        if (typeof window !== 'undefined') {
          window.location.href = '/';
        }
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

export default api;
</file>

<file path="sigl_frontend/src/services/calendarService.js">
import axios from 'axios';

// Configuration de base pour l'API calendrier
const CALENDAR_API_BASE_URL = 'http://localhost:3000/api/calendar';

// Instance axios spécifique pour le calendrier
const calendarApi = axios.create({
  baseURL: CALENDAR_API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000,
});

// Intercepteur pour gérer les erreurs
calendarApi.interceptors.response.use(
  (response) => response,
  (error) => {
    console.error('Erreur API Calendrier:', error);
    
    // Gestion des erreurs réseau
    if (!error.response) {
      throw new Error('Erreur de connexion au serveur. Vérifiez votre connexion internet.');
    }
    
    // Gestion des erreurs HTTP
    switch (error.response.status) {
      case 404:
        throw new Error('Ressource non trouvée.');
      case 500:
        throw new Error('Erreur interne du serveur. Veuillez réessayer plus tard.');
      default:
        throw new Error(error.response.data?.message || 'Une erreur est survenue.');
    }
  }
);

/**
 * Service pour la gestion des événements du calendrier
 */
class CalendarService {
  
  /**
   * Récupère tous les événements
   * @param {string} category - Catégorie optionnelle pour filtrer les événements
   * @returns {Promise<Array>} Liste des événements
   */
  static async getAllEvents(category = null) {
    try {
      const params = category ? { category } : {};
      const response = await calendarApi.get('/events', { params });
      
      if (response.data.success) {
        return response.data.data;
      } else {
        throw new Error(response.data.message || 'Erreur lors de la récupération des événements');
      }
    } catch (error) {
      console.error('Erreur getAllEvents:', error);
      throw error;
    }
  }

  /**
   * Récupère un événement par son ID
   * @param {number} id - ID de l'événement
   * @returns {Promise<Object>} Données de l'événement
   */
  static async getEventById(id) {
    try {
      if (!id || isNaN(id)) {
        throw new Error('ID d\'événement invalide');
      }

      const response = await calendarApi.get(`/events/${id}`);
      
      if (response.data.success) {
        return response.data.data;
      } else {
        throw new Error(response.data.message || 'Événement non trouvé');
      }
    } catch (error) {
      console.error('Erreur getEventById:', error);
      throw error;
    }
  }

  /**
   * Récupère les événements d'un mois spécifique
   * @param {number} year - Année
   * @param {number} month - Mois (1-12)
   * @returns {Promise<Array>} Liste des événements du mois
   */
  static async getEventsByMonth(year, month) {
    try {
      if (!year || !month || isNaN(year) || isNaN(month) || month < 1 || month > 12) {
        throw new Error('Paramètres de date invalides');
      }

      const response = await calendarApi.get(`/events/month/${year}/${month}`);
      
      if (response.data.success) {
        return response.data.data;
      } else {
        throw new Error(response.data.message || 'Erreur lors de la récupération des événements du mois');
      }
    } catch (error) {
      console.error('Erreur getEventsByMonth:', error);
      throw error;
    }
  }

  /**
   * Récupère toutes les catégories disponibles
   * @returns {Promise<Array>} Liste des catégories
   */
  static async getCategories() {
    try {
      const response = await calendarApi.get('/categories');
      
      if (response.data.success) {
        return response.data.data;
      } else {
        throw new Error(response.data.message || 'Erreur lors de la récupération des catégories');
      }
    } catch (error) {
      console.error('Erreur getCategories:', error);
      throw error;
    }
  }

  /**
   * Formate une date pour l'affichage en français
   * @param {string} dateString - Date au format ISO
   * @returns {string} Date formatée
   */
  static formatDate(dateString) {
    try {
      const date = new Date(dateString);
      return date.toLocaleDateString('fr-FR', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    } catch (error) {
      console.error('Erreur formatage date:', error);
      return dateString;
    }
  }

  /**
   * Formate une heure pour l'affichage
   * @param {string} timeString - Heure au format HH:MM
   * @returns {string} Heure formatée
   */
  static formatTime(timeString) {
    try {
      if (!timeString) return '';
      
      const [hours, minutes] = timeString.split(':');
      return `${hours}h${minutes}`;
    } catch (error) {
      console.error('Erreur formatage heure:', error);
      return timeString;
    }
  }

  /**
   * Obtient la couleur associée à une catégorie
   * @param {string} category - Catégorie de l'événement
   * @returns {Object} Objet contenant les classes CSS pour la couleur
   */
  static getCategoryColor(category) {
    const colors = {
      'réunion': {
        bg: 'bg-blue-100',
        border: 'border-blue-500',
        text: 'text-blue-800',
        dot: 'bg-blue-500'
      },
      'rendez-vous': {
        bg: 'bg-green-100',
        border: 'border-green-500',
        text: 'text-green-800',
        dot: 'bg-green-500'
      },
      'culturel': {
        bg: 'bg-purple-100',
        border: 'border-purple-500',
        text: 'text-purple-800',
        dot: 'bg-purple-500'
      },
      'formation': {
        bg: 'bg-orange-100',
        border: 'border-orange-500',
        text: 'text-orange-800',
        dot: 'bg-orange-500'
      }
    };

    return colors[category?.toLowerCase()] || {
      bg: 'bg-gray-100',
      border: 'border-gray-500',
      text: 'text-gray-800',
      dot: 'bg-gray-500'
    };
  }

  /**
   * Groupe les événements par date
   * @param {Array} events - Liste des événements
   * @returns {Object} Événements groupés par date
   */
  static groupEventsByDate(events) {
    return events.reduce((grouped, event) => {
      const date = event.date;
      if (!grouped[date]) {
        grouped[date] = [];
      }
      grouped[date].push(event);
      return grouped;
    }, {});
  }

  /**
   * Cache simple pour éviter les appels API répétés
   */
  static cache = new Map();
  static cacheTimeout = 5 * 60 * 1000; // 5 minutes

  /**
   * Récupère les événements avec mise en cache
   * @param {number} year - Année
   * @param {number} month - Mois
   * @returns {Promise<Array>} Événements du mois
   */
  static async getCachedEventsByMonth(year, month) {
    const cacheKey = `events-${year}-${month}`;
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.data;
    }

    try {
      const events = await this.getEventsByMonth(year, month);
      this.cache.set(cacheKey, {
        data: events,
        timestamp: Date.now()
      });
      return events;
    } catch (error) {
      // Si erreur et cache disponible, retourner le cache
      if (cached) {
        console.warn('Utilisation du cache en raison d\'une erreur API');
        return cached.data;
      }
      throw error;
    }
  }

  /**
   * Vide le cache
   */
  static clearCache() {
    this.cache.clear();
  }
}

export default CalendarService;
</file>

<file path="README.md">
# SIGL - Système d'Information de Gestion de Liaison

## Introduction au projet

SIGL est une plateforme web pensée pour orchestrer les relations entre étudiants, entreprises et établissements d'enseignement. C'est un système complet qui traite la coordination des stages, des soutenances, des entretiens et du suivi pédagogique.

### Fonctionnalités principales

- **Authentification sécurisée** avec JWT et authentification multi-facteurs (MFA).
- **Gestion des entretiens** et planification des créneaux.
- **Système de soutenances** avec gestion des jurys. 
- **Tableau de bord personnalisé** selon le rôle utilisateur. Chacun voit ce qui le concerne.
- **Journal de bord** pour le suivi des activités. La traçabilité, c'est important.
- **Système de rôles** (Étudiant, Entreprise, Administrateur). 

## Stack technique

- **Backend**: Node.js 16+ avec Express.js, MongoDB et Mongoose
- **Frontend**: React 18, Vite pour la vitesse, Tailwind CSS
- **Base de données**: MongoDB 5.0+
- **Authentification**: JWT avec refresh tokens et MFA
- **Sécurité**: Helmet, CORS, rate limiting, bcrypt
- **Tests API**: Bruno (collection incluse dans le projet)

## Prérequis système

Avant de commencer, assurez-vous d'avoir installé les éléments suivants :

- **Node.js** version 16.0.0 ou supérieure
- **npm** version 8.0.0 ou supérieure
- **MongoDB** version 5.0.0 ou supérieure
- **Git** pour le clonage du repository

### Vérification des versions

```bash
node --version
npm --version
mongod --version
git --version
```

## Installation étape par étape

### 1. Cloner le repository

```bash
git clone <url-du-repository>
cd SIGL_projet
```

### 2. Installation des dépendances du backend

```bash
cd sigl_backend
npm install
```

### 3. Installation des dépendances du frontend

```bash
cd ../sigl_frontend
npm install
```

### 4. Retour à la racine du projet

```bash
cd ..
```

## Configuration des variables d'environnement

### Backend (.env)

Créez un fichier `.env` dans le dossier `sigl_backend/` avec le contenu suivant :

```env
# Secrets JWT (IMPORTANT: Changez ces valeurs en production)
JWT_SECRET=your-very-strong-secret-key-min-32-chars-for-access-tokens-2024
JWT_REFRESH_SECRET=another-strong-secret-for-refresh-tokens-must-be-different-2024

# Configuration de sécurité
BCRYPT_SALT_ROUNDS=10
MAX_LOGIN_ATTEMPTS=5
ACCOUNT_LOCK_TIME=900000

# Configuration serveur
NODE_ENV=development
PORT=3000

# Base de données
MONGODB_URI=mongodb://localhost:27017/database

# Configuration SMTP (Mailtrap pour le développement)
SMTP_HOST=sandbox.smtp.mailtrap.io
SMTP_PORT=2525
SMTP_USER=cc40f8c68deca9
SMTP_PASS=bb9da2e2951b72
SMTP_FROM="SKILIO" <no-reply@skilio.local>

# URL du frontend
FRONTEND_URL=http://localhost:5173
```

### Frontend (.env)

Créez un fichier `.env` dans le dossier `sigl_frontend/` avec le contenu suivant :

```env
# URL de l'API backend
VITE_API_URL=http://localhost:3000/api
```

## Démarrage du serveur de développement

### 1. Démarrer MongoDB

Assurez-vous que MongoDB est en cours d'exécution :

```bash
# Windows
net start MongoDB

# macOS/Linux
sudo systemctl start mongod
# ou
brew services start mongodb-community
```

### 2. Démarrer le backend

Dans un premier terminal :

```bash
cd sigl_backend
npm run dev
```

Le serveur backend sera accessible sur `http://localhost:3000`

### 3. Démarrer le frontend

Dans un second terminal :

```bash
cd sigl_frontend
npm run dev
```

Le serveur frontend sera accessible sur `http://localhost:5173`

## Informations sur les ports

| Service | Port | URL | Description |
|---------|------|-----|-------------|
| Backend API | 3000 | http://localhost:3000 | Serveur Express.js |
| Frontend Dev | 5173 | http://localhost:5173 | Serveur de développement Vite |
| Frontend Preview | 4173 | http://localhost:4173 | Serveur de prévisualisation Vite |
| MongoDB | 27017 | mongodb://localhost:27017 | Base de données MongoDB |

## Tests disponibles

### Tests API avec Bruno

Le projet inclut une collection complète de tests API dans le dossier `API_test/`.

1. **Installer Bruno** : [https://usebruno.com/](https://usebruno.com/)
2. **Ouvrir la collection** : Fichier → Ouvrir Collection → Sélectionner le dossier `API_test`
3. **Configurer l'environnement** : Utiliser l'environnement "local" pré-configuré

### Tests inclus

- **Authentification** : Login, logout, refresh token, MFA
- **Gestion utilisateurs** : CRUD complet, profils, rôles
- **Entretiens** : Demande, confirmation, annulation
- **Soutenances** : Planification, gestion des jurys
- **Tests généraux** : Santé de l'API, connectivité

### Commandes npm

```bash
# Backend
cd sigl_backend
npm run dev          # Démarrage en mode développement
npm start           # Démarrage en mode production
npm run test        # Exécution des tests (si configurés)

# Frontend
cd sigl_frontend
npm run dev         # Serveur de développement
npm run build       # Build de production
npm run preview     # Prévisualisation du build
npm run lint        # Vérification du code
```

## Section de dépannage

### Erreur : "Cannot connect to MongoDB"

**Solution :**
```bash
# Vérifier si MongoDB est démarré
# Windows
sc query MongoDB

# macOS/Linux
sudo systemctl status mongod

# Redémarrer MongoDB si nécessaire
# Windows
net stop MongoDB && net start MongoDB

# macOS/Linux
sudo systemctl restart mongod
```

### Erreur : "Port 3000 already in use"

**Solution :**
```bash
# Trouver le processus utilisant le port
# Windows
netstat -ano | findstr :3000

# macOS/Linux
lsof -i :3000

# Tuer le processus (remplacer PID par l'ID du processus)
# Windows
taskkill /PID <PID> /F

# macOS/Linux
kill -9 <PID>
```

### Erreur : "Module not found"

**Solution :**
```bash
# Supprimer node_modules et réinstaller
rm -rf node_modules package-lock.json
npm install

# Ou utiliser npm ci pour une installation propre
npm ci
```


### Erreur : "CORS policy"

**Solution :**
Vérifier que `FRONTEND_URL` dans le fichier `.env` du backend correspond à l'URL du frontend.

### Base de données vide

**Solution :**
```bash
# Restaurer la base de données depuis le dump
cd database
mongorestore --db database ./database/
```

### Logs et débogage

- **Backend logs** : Consultez la console du terminal backend
- **Frontend logs** : Ouvrez les DevTools du navigateur (F12)
- **MongoDB logs** : Vérifiez les logs MongoDB dans `/var/log/mongodb/` (Linux/macOS)

## Documentation supplémentaire

### Liens utiles

- **Documentation React** : [https://react.dev/](https://react.dev/)
- **Documentation Vite** : [https://vitejs.dev/](https://vitejs.dev/)
- **Documentation Tailwind CSS** : [https://tailwindcss.com/](https://tailwindcss.com/)
- **Documentation Express.js** : [https://expressjs.com/](https://expressjs.com/)
- **Documentation MongoDB** : [https://docs.mongodb.com/](https://docs.mongodb.com/)
- **Documentation JWT** : [https://jwt.io/](https://jwt.io/)
- **Documentation Bruno** : [https://docs.usebruno.com/](https://docs.usebruno.com/)

### Structure du projet

```
SIGL_projet/
├── sigl_backend/             # API Backend Node.js/Express
│   ├── app/                  # Code source de l'application
│   │   ├── auth/             # Authentification et sécurité
│   │   ├── user/             # Gestion des utilisateurs
│   │   ├── entretien/        # Gestion des entretiens
│   │   ├── soutenance/       # Gestion des soutenances
│   │   └── middleware/       # Middlewares Express
│   └── .env                  # Variables d'environnement backend
├── sigl_frontend/            # Application React
│   ├── src/                  # Code source React
│   │   ├── components/       # Composants réutilisables
│   │   ├── pages/            # Pages de l'application
│   │   └── services/         # Services API
│   └── .env                  # Variables d'environnement frontend
├── API_test/                 # Collection de tests Bruno
├── database/                 # Dump de la base de données
└── README.md                 # Ce fichier
```

### Rôles et permissions

| Rôle | Permissions |
|------|-------------|
| Étudiant | Consulter offres, demander entretiens, gérer son profil, journal de bord |
| Entreprise | Publier offres, gérer entretiens, consulter profils étudiants |
| Administrateur | Gestion complète, modération, configuration système |
</file>

<file path="sigl_backend/package.json">
{
  "name": "backend",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node app/app.js"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "bcryptjs": "^2.4.3",
    "cookie-parser": "~1.4.4",
    "cors": "^2.8.5",
    "debug": "~2.6.9",
    "dotenv": "^16.6.1",
    "express": "~4.16.1",
    "express-rate-limit": "^7.5.1",
    "file-type": "^21.1.0",
    "helmet": "^7.2.0",
    "http-errors": "~1.6.3",
    "ics": "^3.8.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.0.0",
    "morgan": "~1.9.1",
    "multer": "^2.0.2",
    "nodemailer": "^7.0.10",
    "pug": "2.0.0-beta11"
  }
}
</file>

<file path="API_test/collection.bru">
auth {
  mode: bearer
}

auth:bearer {
  token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTFlZDBjYzVmNzU5MDk4NjE5MWIyNDQiLCJlbWFpbCI6InRlc3RAZXhhbXBsZS5jb20iLCJyb2xlIjoiQVBQUkVOVEkiLCJ0eXBlIjoiYWNjZXNzIiwiaWF0IjoxNzY4MjA5NjgzLCJleHAiOjE3NjgyMTA1ODMsImF1ZCI6Imxtcy11c2VycyIsImlzcyI6ImxlYXJuaW5nLW1hbmFnZW1lbnQtc3lzdGVtIn0.MF8FSWGC7n_Dj76eXMHAgjSp6CE2Hz6ikCOve-wVUkE
}
</file>

<file path="sigl_backend/app/user/routes.js">
// sigl_backend/app/user/routes.js
const express = require('express');
const router = express.Router();
const userController = require('./controller');
const { authenticate } = require('../middleware/authenticate');
const {
  authorizeSelfOrAdmin,
  adminOnly,
  staffOnly,
} = require('../middleware/authorize');
const Utilisateur = require('../common/models/user.model');  // ← Correction ici !

/**
 * Routes Utilisateur avec authentification et autorisation
 */

// POST /api/users/register - Enregistrer un nouvel utilisateur (public)
router.post('/register', userController.register);

// GET /api/users - Lister tous les utilisateurs (admin/staff seulement)
router.get(
  '/',
  authenticate,
  staffOnly(),
  userController.listUsers
);

router.get('/available-contacts', authenticate, async (req, res) => {
    try {
        const users = await Utilisateur.find(
            { role: { $in: ['APPRENTI', 'TP', 'MA', 'PROF', 'CA', 'RC'] } },
            'nom email role _id'
        );
        res.json({ success: true, users });
    } catch (error) {
        res.status(500).json({ success: false, error: error.message });
    }
});

// GET /api/users/:id - Obtenir le profil utilisateur (utilisateur lui-même ou admin)
router.get(
  '/:id',
  authenticate,
  authorizeSelfOrAdmin('id'),
  userController.getProfile
);

// PUT /api/users/:id - Mettre à jour les informations utilisateur (utilisateur lui-même ou admin)
router.put(
  '/:id',
  authenticate,
  authorizeSelfOrAdmin('id'),
  userController.updateUser
);

// DELETE /api/users/:id - Supprimer le compte utilisateur (admin seulement)
router.delete(
  '/:id',
  authenticate,
  adminOnly(),
  userController.deleteUser
);

module.exports = router;
</file>

<file path="sigl_frontend/src/pages/journal/JournalDetailPage.jsx">
import React, { useEffect, useState } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import journalService from '../../services/journalService';

const JournalDetailPage = () => {
  const { id } = useParams();
  const navigate = useNavigate();

  const [journal, setJournal] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchJournal = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const journaux = await journalService.getMyJournaux();

        const found =
          journaux.find((j) => String(j.id) === String(id)) ||
          journaux[parseInt(id, 10)];

        if (!found) {
          setError('Journal introuvable.');
        } else {
          setJournal(found);
        }
      } catch (err) {
        console.error(err);
        setError("Erreur lors du chargement du journal.");
      } finally {
        setIsLoading(false);
      }
    };

    fetchJournal();
  }, [id]);

  if (isLoading) {
    return <p className="p-4 text-gray-600">Chargement du journal...</p>;
  }

  if (error) {
    return (
      <div className="p-4">
        <button
          type="button"
          onClick={() => navigate('/dashboard?tab=journal')}
          className="inline-flex items-center text-sm text-primary-600 hover:text-primary-800 mb-4"
        >
          ← Retour au tableau de bord
        </button>
        <p className="text-red-600 text-sm">{error}</p>
      </div>
    );
  }

  if (!journal) {
    return null;
  }

  const periodes = journal.periodes || [];

  return (
    <div className="max-w-5xl mx-auto px-4 py-8">
      <div className="mb-4">
        <button
          type="button"
          onClick={() => navigate('/dashboard?tab=journal')}
          className="inline-flex items-center text-sm text-primary-600 hover:text-primary-800"
        >
          ← Retour au tableau de bord
        </button>
      </div>

      <h1 className="text-2xl font-semibold mb-4">
        Détail du journal de formation
      </h1>

      {periodes.map((p, idx) => (
        <div
          key={idx}
          className="bg-white border border-gray-200 rounded-lg p-4 mb-4"
        >
          <div className="flex justify-between items-center mb-2">
            <h2 className="text-lg font-semibold text-gray-800">
              Période {idx + 1} {p.titre ? `– ${p.titre}` : ''}
            </h2>
            <span className="text-xs text-gray-500">
              {p.dateDebut && p.dateFin
                ? `${p.dateDebut} → ${p.dateFin}`
                : 'Dates non renseignées'}
            </span>
          </div>

          {(p.missions || []).map((m, mIndex) => (
            <div
              key={mIndex}
              className="border border-gray-100 rounded-md p-3 mb-3"
            >
              <h3 className="text-sm font-semibold text-gray-700 mb-1">
                {m.titre || `Mission ${mIndex + 1}`}
              </h3>
              {m.competences && (
                <p className="text-xs text-gray-500 mb-1">
                  Compétences : {m.competences}
                </p>
              )}
              {m.description && (
                <p className="text-sm text-gray-700 whitespace-pre-line">
                  {m.description}
                </p>
              )}
            </div>
          ))}
        </div>
      ))}

      {journal.calendarEvent && (
        <div className="mt-6 bg-primary-50 border border-primary-200 rounded-lg p-4">
          <h2 className="text-lg font-semibold text-gray-800 mb-2">
            Événement de calendrier lié
          </h2>
          <p className="text-sm text-gray-800">
            <strong>{journal.calendarEvent.title}</strong>
          </p>
          <p className="text-sm text-gray-600">
            {journal.calendarEvent.date}
            {journal.calendarEvent.time ? ` à ${journal.calendarEvent.time}` : ''}
          </p>
          {journal.calendarEvent.location && (
            <p className="text-sm text-gray-600">
              Lieu : {journal.calendarEvent.location}
            </p>
          )}
          {journal.calendarEvent.participantsRaw && (
            <p className="text-sm text-gray-600">
              Participants : {journal.calendarEvent.participantsRaw}
            </p>
          )}
          {journal.calendarEvent.notes && (
            <p className="text-sm text-gray-700 mt-2 whitespace-pre-line">
              {journal.calendarEvent.notes}
            </p>
          )}
        </div>
      )}
    </div>
  );
};

export default JournalDetailPage;
</file>

<file path="sigl_frontend/src/pages/profile/ProfilePage.jsx">
// sigl_frontend/src/pages/profile/ProfilePage.jsx
import React, { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import authService from '../../services/authService';
import ToggleSwitch from '../../components/ToggleSwitch';

const ProfilePage = () => {
  const [formData, setFormData] = useState({
    prenom: '',
    nom: '',
    email: '',
    telephone: '',
    mfaEnabled: false,
    mfaMethod: 'email',
    avatar: null,
  });

  const [initials, setInitials] = useState('?');
  const [avatarPreview, setAvatarPreview] = useState(null);

  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);

  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  // ---------- Chargement du profil ----------
  useEffect(() => {
    const loadProfile = async () => {
      setIsLoading(true);
      setError('');
      try {
        const user = await authService.getMe();

        if (!user) {
          setError('Impossible de récupérer votre profil.');
          return;
        }

        const prenom = user.prenom || user.firstName || '';
        const nom = user.nom || user.lastName || '';
        const email = user.email || '';
        const telephone = user.telephone || user.phone || '';
        const mfaEnabled = !!user.mfaEnabled;
        const mfaMethod = user.mfaMethod || (telephone ? 'sms' : 'email');
        const avatar = user.avatar || null;

        setFormData({
          prenom,
          nom,
          email,
          telephone,
          mfaEnabled,
          mfaMethod,
          avatar,
        });

        setAvatarPreview(avatar || null);
        updateInitials(prenom, nom, email);
      } catch (err) {
        console.error('Erreur de chargement du profil :', err);
        const message =
          err?.response?.data?.message ||
          err?.message ||
          'Erreur lors du chargement du profil.';
        setError(message);
      } finally {
        setIsLoading(false);
      }
    };

    loadProfile();
  }, []);

  const updateInitials = (prenom, nom, email) => {
    const p = (prenom || '').trim();
    const n = (nom || '').trim();

    if (p || n) {
      setInitials(`${p.charAt(0)}${n.charAt(0)}`.toUpperCase());
    } else if (email) {
      setInitials(email.charAt(0).toUpperCase());
    } else {
      setInitials('?');
    }
  };

  // ---------- Handlers ----------

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;

    setFormData((prev) => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value,
    }));

    if (name === 'prenom' || name === 'nom') {
      const nextPrenom = name === 'prenom' ? value : formData.prenom;
      const nextNom = name === 'nom' ? value : formData.nom;
      updateInitials(nextPrenom, nextNom, formData.email);
    }

    setError('');
    setSuccess('');
  };

  const handleFileChange = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setError('');
    setSuccess('');

    const reader = new FileReader();
    reader.onloadend = () => {
      const dataUrl = reader.result;
      setAvatarPreview(dataUrl);
      setFormData((prev) => ({
        ...prev,
        avatar: dataUrl,
      }));
    };
    reader.readAsDataURL(file);
  };

  const handleSaveProfile = async (e) => {
    e.preventDefault();
    setIsSaving(true);
    setError('');
    setSuccess('');

    try {
      const payload = {
        prenom: formData.prenom.trim(),
        nom: formData.nom.trim(),
        email: formData.email.trim(),
        telephone: formData.telephone.trim() || null,
        mfaEnabled: formData.mfaEnabled,
        mfaMethod: formData.mfaEnabled ? formData.mfaMethod || 'email' : null,
        avatar:
          typeof formData.avatar === 'string' && formData.avatar.trim().length > 0
            ? formData.avatar.trim()
            : null,
      };

      const updatedUser = await authService.updateProfile(payload);

      if (updatedUser) {
        const prenom = updatedUser.prenom || updatedUser.firstName || payload.prenom;
        const nom = updatedUser.nom || updatedUser.lastName || payload.nom;
        const email = updatedUser.email || payload.email;
        const telephone = updatedUser.telephone || updatedUser.phone || payload.telephone;
        const mfaEnabled = !!updatedUser.mfaEnabled;
        const mfaMethod = updatedUser.mfaMethod || payload.mfaMethod;
        const avatar = updatedUser.avatar || payload.avatar || null;

        setFormData({
          prenom,
          nom,
          email,
          telephone,
          mfaEnabled,
          mfaMethod,
          avatar,
        });
        setAvatarPreview(avatar);
        updateInitials(prenom, nom, email);

        setSuccess('Profil mis à jour avec succès.');
      }
    } catch (err) {
      console.error('Erreur lors de la sauvegarde du profil :', err);
      const message =
        err?.response?.data?.error ||
        err?.response?.data?.message ||
        err?.message ||
        'Erreur lors de la mise à jour du profil.';
      setError(message);
    } finally {
      setIsSaving(false);
    }
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <p className="text-gray-600">Chargement du profil...</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <main className="max-w-4xl mx-auto py-10 px-4 sm:px-6 lg:px-8">
        <div className="mb-6">
          <Link
            to="/dashboard"
            className="text-sm text-primary-600 hover:text-primary-700"
          >
            ← Retour au tableau de bord
          </Link>
        </div>

        <div className="bg-white shadow rounded-lg p-6 md:p-8">
          <div className="flex items-center justify-between mb-6">
            <div>
              <h1 className="text-2xl font-semibold text-gray-900">
                Mon profil
              </h1>
              <p className="mt-1 text-sm text-gray-500">
                Gérez vos informations personnelles et vos préférences de sécurité.
              </p>
            </div>
          </div>

          {error && (
            <div className="mb-4 rounded-md bg-red-50 p-4 text-sm text-red-700">
              {error}
            </div>
          )}

          {success && (
            <div className="mb-4 rounded-md bg-green-50 p-4 text-sm text-green-700">
              {success}
            </div>
          )}

          <form onSubmit={handleSaveProfile} className="space-y-8">
            {/* Avatar */}
            <div className="flex items-center space-x-4">
              <div className="h-16 w-16 rounded-full bg-primary-100 text-primary-700 flex items-center justify-center text-xl font-semibold overflow-hidden">
                {avatarPreview ? (
                  // eslint-disable-next-line jsx-a11y/alt-text
                  <img
                    src={avatarPreview}
                    className="h-full w-full object-cover"
                  />
                ) : (
                  initials
                )}
              </div>
              <div>
                <p className="text-sm font-medium text-gray-800">
                  Photo de profil
                </p>
                <p className="text-xs text-gray-500 mb-2">
                  Cette photo sera utilisée sur l’ensemble de la plateforme.
                </p>
                <label className="inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50 cursor-pointer">
                  <span>Choisir une image</span>
                  <input
                    type="file"
                    accept="image/*"
                    className="hidden"
                    onChange={handleFileChange}
                    disabled={isSaving}
                  />
                </label>
              </div>
            </div>

            {/* Infos principales */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* Prénom */}
              <div>
                <label
                  htmlFor="prenom"
                  className="block mb-2 text-sm font-medium text-gray-700"
                >
                  Prénom
                </label>
                <input
                  type="text"
                  id="prenom"
                  name="prenom"
                  className="block w-full rounded-md border border-gray-300 px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-1 focus:ring-primary-500"
                  value={formData.prenom}
                  onChange={handleInputChange}
                  disabled={isSaving}
                />
              </div>

              {/* Nom */}
              <div>
                <label
                  htmlFor="nom"
                  className="block mb-2 text-sm font-medium text-gray-700"
                >
                  Nom
                </label>
                <input
                  type="text"
                  id="nom"
                  name="nom"
                  className="block w-full rounded-md border border-gray-300 px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-1 focus:ring-primary-500"
                  value={formData.nom}
                  onChange={handleInputChange}
                  disabled={isSaving}
                />
              </div>

              {/* Email */}
              <div className="md:col-span-2">
                <label
                  htmlFor="email"
                  className="block mb-2 text-sm font-medium text-gray-700"
                >
                  Adresse email
                </label>
                <input
                  type="email"
                  id="email"
                  name="email"
                  className="block w-full rounded-md border border-gray-300 px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-1 focus:ring-primary-500"
                  value={formData.email}
                  onChange={handleInputChange}
                  disabled={isSaving}
                />
                <p className="mt-1 text-xs text-gray-500">
                  Cette adresse est utilisée pour vos notifications et la sécurité du compte.
                </p>
              </div>

              {/* Téléphone */}
              <div className="md:col-span-2">
                <label
                  htmlFor="telephone"
                  className="block mb-2 text-sm font-medium text-gray-700"
                >
                  Téléphone (pour le MFA SMS)
                </label>
                <input
                  type="tel"
                  id="telephone"
                  name="telephone"
                  className="block w-full rounded-md border border-gray-300 px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-1 focus:ring-primary-500"
                  value={formData.telephone}
                  onChange={handleInputChange}
                  disabled={isSaving}
                />
                <p className="mt-1 text-xs text-gray-500">
                  Facultatif. Requis si vous choisissez le MFA par SMS.
                </p>
              </div>
            </div>

            {/* Sécurité / MFA */}
            <div className="border-t border-gray-200 pt-6 space-y-4">
              <h2 className="text-sm font-semibold text-gray-800">
                Sécurité du compte
              </h2>

              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm font-medium text-gray-700">
                    Authentification multi-facteur (MFA)
                  </p>
                  <p className="text-xs text-gray-500">
                    Ajoutez une couche de sécurité supplémentaire lors de la connexion.
                  </p>
                </div>
                <ToggleSwitch
                  checked={formData.mfaEnabled}
                  onChange={() =>
                    setFormData((prev) => ({
                      ...prev,
                      mfaEnabled: !prev.mfaEnabled,
                    }))
                  }
                  disabled={isSaving}
                />
              </div>

              {formData.mfaEnabled && (
                <div className="space-y-2">
                  <label className="block text-xs font-medium text-gray-700">
                    Méthode de vérification
                  </label>
                  <select
                    name="mfaMethod"
                    value={formData.mfaMethod}
                    onChange={handleInputChange}
                    disabled={isSaving}
                    className="block w-full md:w-64 rounded-md border border-gray-300 px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-1 focus:ring-primary-500"
                  >
                    <option value="email">Email</option>
                    <option value="sms" disabled={!formData.telephone}>
                      SMS {formData.telephone ? '' : '(ajoutez un téléphone)'}
                    </option>
                  </select>
                </div>
              )}
            </div>

            <div className="pt-4 flex justify-end">
              <button
                type="submit"
                className="btn-primary max-w-xs"
                disabled={isSaving}
              >
                {isSaving ? 'Enregistrement...' : 'Enregistrer les modifications'}
              </button>
            </div>
          </form>
        </div>
      </main>
    </div>
  );
};

export default ProfilePage;
</file>

<file path="sigl_frontend/src/services/journalService.js">
// sigl_frontend/src/services/journalService.js
import api from './api';

const journalService = {
  // Récupérer tous les journaux de l'apprenti connecté
  async getMyJournaux() {
    const response = await api.get('/journaux');
    // Le backend renvoie { success, data: [...] }
    return response.data?.data || [];
  },

  // Récupérer un journal par son id
  async getJournalById(id) {
    const response = await api.get(`/journaux/${id}`);
    return response.data?.data || null;
  },

  // Créer un journal pour l'apprenti connecté
  async createJournal(journalPayload) {
    const response = await api.post('/journaux', journalPayload);
    return response.data?.data;
  },
};

export default journalService;
</file>

<file path="sigl_backend/app/user/controller.js">
// sigl_backend/app/user/controller.js
const mongoose = require('mongoose');
const userService = require('./service');

const userRepository = require('./repository');
const authRepository = require('../auth/auth.repository');
const authService = require('../auth/auth.service');

const VALID_ROLES = ['APPRENTI', 'MA', 'TP', 'CA', 'RC', 'PROF', 'ADMIN'];

const normalizeName = (value) => {
  if (!value) return '';
  return String(value).trim();
};

/**
 * POST /api/users/register
 */
const register = async (req, res) => {
  try {
    const {
      username,
      email,
      password,
      role,
      firstName,
      lastName,
      prenom,
      nom,
      telephone,
    } = req.body;

    // ------------------ validations (sans casser l'existant) ------------------
    if (!username || !email || !password) {
      return res.status(400).json({
        error: "Le nom d'utilisateur, l'email et le mot de passe sont obligatoires",
      });
    }

    // Username: 3-20, caractères autorisés (cohérent avec updateUser)
    const usernameRegex = /^[a-zA-Z0-9_.-]{3,20}$/;
    if (!usernameRegex.test(username)) {
      return res.status(400).json({
        error:
          "Nom d'utilisateur invalide (3-20 caractères, lettres/chiffres/._- uniquement)",
      });
    }

    // Email basique
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(String(email))) {
      return res.status(400).json({
        error: 'Format email invalide',
      });
    }

    // Password: ton front peut avoir “>= 6”, mais ton authService.hashPassword exige “>= 8”
    if (typeof password !== 'string' || password.length < 6) {
      return res.status(400).json({
        error: 'Le mot de passe doit contenir au moins 6 caractères',
      });
    }
    if (password.length < 8) {
      return res.status(400).json({
        error: 'Le mot de passe doit contenir au moins 8 caractères',
      });
    }

    let dbRole = role || 'APPRENTI';
    if (!VALID_ROLES.includes(dbRole)) {
      return res.status(400).json({
        error: `Le rôle doit être l'un des suivants : ${VALID_ROLES.join(', ')}`,
      });
    }

    // Vérifie doublons (email / username) AVANT création
    const existingByEmail = await userRepository.findUserByEmail(email);
    if (existingByEmail) {
      return res.status(409).json({
        error: "Un utilisateur existe déjà avec cet email",
      });
    }

    const existingByUsername = await userRepository.findUserByUsername(username);
    if (existingByUsername) {
      return res.status(409).json({
        error: "Un utilisateur existe déjà avec ce nom d'utilisateur",
      });
    }

    // ------------------ création user (sans password) ------------------
    const result = await userService.createUser({
      username,
      email,
      role: dbRole,
      firstName: normalizeName(firstName ?? prenom),
      lastName: normalizeName(lastName ?? nom),
      telephone,
    });

    if (!result.success) {
      return res.status(400).json({
        error: result.error,
        details: result.details,
      });
    }

    // ------------------ création credentials (Auth) ------------------
    try {
      const hashedPassword = await authService.hashPassword(password);
      const userId = result.data?._id || result.data?.id; // selon ce que renvoie toSafeObject()
      await authRepository.createAuthRecord(userId, hashedPassword);
    } catch (authErr) {
      // Rollback best-effort: si user créé mais pas credentials, on supprime le user
      try {
        const userId = result.data?._id || result.data?.id;
        if (userId) {
          await userService.deleteUserAccount(userId);
        }
      } catch (rollbackErr) {
        console.error('register rollback error:', rollbackErr);
      }

      console.error('register auth creation error:', authErr);
      return res.status(500).json({
        error:
          "Utilisateur créé, mais échec de création des identifiants. Réessaie.",
      });
    }

    return res.status(201).json({
      message: 'Utilisateur enregistré avec succès',
      user: result.data,
    });
  } catch (error) {
    console.error('register error:', error);
    return res.status(500).json({
      error: 'Erreur interne du serveur',
    });
  }
};

/**
 * GET /api/users/:id
 */
const getProfile = async (req, res) => {
  try {
    const userId = req.params.id;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({
        error: "Format d'ID utilisateur invalide",
      });
    }

    const result = await userService.getUserProfile(userId);

    if (result.success) {
      return res.status(200).json({
        user: result.data,
      });
    } else {
      return res.status(404).json({
        error: result.error,
      });
    }
  } catch (error) {
    console.error('getProfile error:', error);
    return res.status(500).json({
      error: 'Erreur interne du serveur',
    });
  }
};

/**
 * PUT /api/users/:id
 */
const updateUser = async (req, res) => {
  try {
    const userId = req.params.id;
    const updateData = req.body;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({
        error: "Format d'ID utilisateur invalide",
      });
    }

    // Validation: username
    if (updateData.username) {
      const usernameRegex = /^[a-zA-Z0-9_.-]{3,20}$/;
      if (!usernameRegex.test(updateData.username)) {
        return res.status(400).json({
          error:
            "Nom d'utilisateur invalide (3-20 caractères, lettres/chiffres/._- uniquement)",
        });
      }
    }

    // Validation: email
    if (updateData.email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(updateData.email)) {
        return res.status(400).json({
          error: 'Format email invalide',
        });
      }
    }

    // Validation: role
    if (updateData.role && !VALID_ROLES.includes(updateData.role)) {
      return res.status(400).json({
        error: `Le rôle doit être l'un des suivants : ${VALID_ROLES.join(', ')}`,
      });
    }

    const result = await userService.updateUserInfo(userId, updateData)

    if (result.success) {
      return res.status(200).json({
        message: result.message,
        user: result.data,
      });
    } else {
      return res.status(400).json({
        error: result.error,
        details: result.details,
      });
    }
  } catch (error) {
    console.error('updateUser error:', error);
    return res.status(500).json({
      error: 'Erreur interne du serveur',
    });
  }
};

/**
 * DELETE /api/users/:id
 */
const deleteUser = async (req, res) => {
  try {
    const userId = req.params.id;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({
        error: "Format d'ID utilisateur invalide",
      });
    }

    const result = await userService.deleteUserAccount(userId);

    if (result.success) {
      return res.status(200).json({
        message: result.message,
      });
    } else {
      return res.status(404).json({
        error: result.error,
      });
    }
  } catch (error) {
    console.error('deleteUser error:', error);
    return res.status(500).json({
      error: 'Erreur interne du serveur',
    });
  }
};

/**
 * GET /api/users
 */
const listUsers = async (req, res) => {
  try {
    const result = await userService.listAllUsers();

    if (result.success) {
      return res.status(200).json({
        users: result.data,
        count: result.data.length,
      });
    } else {
      return res.status(500).json({
        error: result.error,
      });
    }
  } catch (error) {
    console.error('listUsers error:', error);
    return res.status(500).json({
      error: 'Erreur interne du serveur',
    });
  }
};

module.exports = {
  register,
  getProfile,
  updateUser,
  deleteUser,
  listUsers,
};
</file>

<file path="sigl_frontend/src/services/authService.js">
// sigl_frontend/src/services/authService.js
import axios from 'axios';
import api from './Api';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000/api';

// --- Helpers stockage ------------------------------------------------------

const STORAGE_KEYS = {
  accessToken: 'accessToken',
  refreshToken: 'refreshToken',
  user: 'user',
  rememberMe: 'rememberMe',
};

function getFromAnyStorage(key) {
  if (typeof window === 'undefined') return null;

  try {
    const sessionValue = window.sessionStorage.getItem(key);
    if (sessionValue !== null && sessionValue !== undefined) {
      return sessionValue;
    }
    return window.localStorage.getItem(key);
  } catch {
    return null;
  }
}

function clearAuthInAllStorages() {
  if (typeof window === 'undefined') return;

  try {
    [window.localStorage, window.sessionStorage].forEach((store) => {
      if (!store) return;
      store.removeItem(STORAGE_KEYS.accessToken);
      store.removeItem(STORAGE_KEYS.refreshToken);
      store.removeItem(STORAGE_KEYS.user);
    });
  } catch {
    // ignore
  }
}

/**
 * Sauvegarde les infos d'auth (tokens + user) soit en localStorage (rememberMe = true),
 * soit en sessionStorage (rememberMe = false).
 */
function saveAuthState({ tokens, user, rememberMe }) {
  if (typeof window === 'undefined') return;
  if (!tokens?.accessToken || !user) return;

  try {
    clearAuthInAllStorages();

    const target = rememberMe ? window.localStorage : window.sessionStorage;

    target.setItem(STORAGE_KEYS.accessToken, tokens.accessToken);
    if (tokens.refreshToken) {
      target.setItem(STORAGE_KEYS.refreshToken, tokens.refreshToken);
    }
    target.setItem(STORAGE_KEYS.user, JSON.stringify(user));
    target.setItem(STORAGE_KEYS.rememberMe, rememberMe ? 'true' : 'false');
  } catch {
    // ignore
  }
}

/**
 * Devine si l’utilisateur avait choisi "Se souvenir de moi".
 */
function inferRememberMe() {
  if (typeof window === 'undefined') return false;

  try {
    const remembered = window.localStorage.getItem(STORAGE_KEYS.rememberMe);
    if (remembered === 'true') return true;
    if (remembered === 'false') return false;

    const hasLocalAccess = !!window.localStorage.getItem(STORAGE_KEYS.accessToken);
    const hasSessionAccess = !!window.sessionStorage.getItem(STORAGE_KEYS.accessToken);

    if (hasLocalAccess && !hasSessionAccess) return true;
    if (!hasLocalAccess && hasSessionAccess) return false;

    return false;
  } catch {
    return false;
  }
}

// --- Service ---------------------------------------------------------------

const authService = {
  // --- INSCRIPTION ---------------------------------------------------------
  register: async (userData) => {
    try {
      const response = await axios.post(`${API_URL}/users/register`, userData);
      return response.data;
    } catch (error) {
      throw error.response?.data || { error: "Erreur lors de l'inscription" };
    }
  },

  // --- LOGIN + MFA --------------------------------------------------------

  /**
   * Étape 1 : login
   * - si MFA non requis : stocke tokens + user (session ou local selon rememberMe)
   * - si MFA requis : ne stocke rien, renvoie juste la payload
   */
  login: async (email, password, rememberMe = false) => {
    try {
      const response = await axios.post(`${API_URL}/auth/login`, {
        email,
        password,
      });

      const resData = response.data;

      if (resData.mfaRequired) {
        return resData;
      }

      const { data } = resData;

      if (data?.tokens && data?.user) {
        saveAuthState({
          tokens: data.tokens,
          user: data.user,
          rememberMe,
        });
      }

      return resData;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la connexion' };
    }
  },

  /**
   * Étape 2 : vérification du code MFA
   */
  verifyMfaCode: async (userId, code, rememberMe = false) => {
    try {
      const response = await axios.post(`${API_URL}/auth/mfa/verify`, {
        userId,
        code: String(code).trim(),
      });

      const resData = response.data;
      const { data } = resData;

      if (data?.tokens && data?.user) {
        saveAuthState({
          tokens: data.tokens,
          user: data.user,
          rememberMe,
        });
      }

      return resData;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la vérification MFA' };
    }
  },

  // --- DÉCONNEXION ---------------------------------------------------------

  logout: async () => {
    try {
      const token = getFromAnyStorage(STORAGE_KEYS.accessToken);
      if (token) {
        await axios.post(
          `${API_URL}/auth/logout`,
          {},
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
      }
    } catch (error) {
      console.error('Erreur lors du logout :', error);
    } finally {
      clearAuthInAllStorages();
      if (typeof window !== 'undefined') {
        window.location.href = '/';
      }
    }
  },

  // --- MOT DE PASSE --------------------------------------------------------

  requestPasswordReset: async (email) => {
    try {
      const response = await axios.post(`${API_URL}/auth/request-reset`, { email });
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la demande de réinitialisation' };
    }
  },

  resetPassword: async (token, newPassword) => {
    try {
      const response = await axios.post(`${API_URL}/auth/reset-password`, {
        token,
        newPassword,
      });
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la réinitialisation du mot de passe' };
    }
  },

  changePassword: async (currentPassword, newPassword) => {
    try {
      const response = await api.post('/auth/change-password', {
        currentPassword,
        newPassword,
      });
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors du changement de mot de passe' };
    }
  },

  // --- ACCÈS / USER EN MÉMOIRE --------------------------------------------

  getAccessToken: () => {
    return getFromAnyStorage(STORAGE_KEYS.accessToken);
  },

  getRefreshToken: () => {
    return getFromAnyStorage(STORAGE_KEYS.refreshToken);
  },

  getCurrentUser: () => {
    const userStr = getFromAnyStorage(STORAGE_KEYS.user);
    if (!userStr) return null;
    try {
      return JSON.parse(userStr);
    } catch {
      return null;
    }
  },

  setCurrentUser: (user) => {
    if (typeof window === 'undefined') return;

    try {
      const rememberMe = inferRememberMe();
      const target = rememberMe ? window.localStorage : window.sessionStorage;

      if (user) {
        const serialized = JSON.stringify(user);
        target.setItem(STORAGE_KEYS.user, serialized);
      } else {
        window.localStorage.removeItem(STORAGE_KEYS.user);
        window.sessionStorage.removeItem(STORAGE_KEYS.user);
      }
    } catch {
      // ignore
    }
  },

  isAuthenticated: () => {
    return !!authService.getAccessToken();
  },

  // --- PROFIL --------------------------------------------------------------

  getMe: async () => {
    const current = authService.getCurrentUser();

    if (!current?.id) {
      return null;
    }

    try {
      const response = await api.get(`/users/${current.id}`);
      return response.data?.user ?? response.data?.data?.user ?? null;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la récupération du profil' };
    }
  },

  getUserProfile: async (userId) => {
    try {
      const response = await api.get(`/users/${userId}`);
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la récupération du profil' };
    }
  },

  requestRoleChange: async (userId, requestedRole, reason) => {
    const response = await api.post('/roles/change-request', {
      userId,
      requestedRole,
      reason,
    });
    return response.data;
  },

  updateProfile: async (profileData) => {
    const current = authService.getCurrentUser();

    if (!current?.id) {
      throw { message: 'Utilisateur non connecté' };
    }

    try {
      const response = await api.put(`/users/${current.id}`, profileData);
      const updatedUser =
        response.data?.user ?? response.data?.data?.user ?? null;

      if (updatedUser) {
        const merged = {
          ...current,
          ...updatedUser,
        };

        authService.setCurrentUser(merged);
      }

      return updatedUser;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la mise à jour du profil' };
    }
  },

  inferRememberMe,
};

export default authService;
</file>

<file path="sigl_frontend/src/pages/journal/CreateJournalPage.jsx">
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import journalService from '../../services/journalService';

const CreateJournalPage = () => {
  const navigate = useNavigate();

  // ---------- STATE JOURNAL ----------
  const [periodes, setPeriodes] = useState([
    {
      id: 1,
      titre: '',
      dateDebut: '',
      dateFin: '',
      missions: [
        {
          id: 1,
          titre: '',
          description: '',
          competences: '',
        },
      ],
    },
  ]);

  // ---------- STATE ÉVÉNEMENT CALENDRIER (Option A) ----------
  const [calendarEvent, setCalendarEvent] = useState({
    enable: false,
    title: '',
    date: '',
    time: '',
    location: '',
    participants: '',
    notes: '',
  });

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null);

  // ---------- HELPERS JOURNAL ----------

  const handlePeriodeChange = (periodeIndex, field, value) => {
    setPeriodes((prev) =>
      prev.map((p, index) =>
        index === periodeIndex ? { ...p, [field]: value } : p
      )
    );
  };

  const handleMissionChange = (
    periodeIndex,
    missionIndex,
    field,
    value
  ) => {
    setPeriodes((prev) =>
      prev.map((p, pIndex) => {
        if (pIndex !== periodeIndex) return p;
        return {
          ...p,
          missions: p.missions.map((m, mIndex) =>
            mIndex === missionIndex ? { ...m, [field]: value } : m
          ),
        };
      })
    );
  };

  const addPeriode = () => {
    setPeriodes((prev) => [
      ...prev,
      {
        id: prev.length + 1,
        titre: '',
        dateDebut: '',
        dateFin: '',
        missions: [
          {
            id: 1,
            titre: '',
            description: '',
            competences: '',
          },
        ],
      },
    ]);
  };

  const removePeriode = (periodeIndex) => {
    setPeriodes((prev) => {
      if (prev.length === 1) return prev; // on garde au moins une période
      return prev.filter((_, index) => index !== periodeIndex);
    });
  };

  const addMission = (periodeIndex) => {
    setPeriodes((prev) =>
      prev.map((p, index) => {
        if (index !== periodeIndex) return p;
        return {
          ...p,
          missions: [
            ...p.missions,
            {
              id: p.missions.length + 1,
              titre: '',
              description: '',
              competences: '',
            },
          ],
        };
      })
    );
  };

  const removeMission = (periodeIndex, missionIndex) => {
    setPeriodes((prev) =>
      prev.map((p, pIndex) => {
        if (pIndex !== periodeIndex) return p;

        // On ne supprime que les missions ajoutées (index > 0) pour
        // respecter ton "retirer celles ajoutées en plus de la première"
        if (missionIndex === 0) return p;
        if (p.missions.length <= 1) return p;

        return {
          ...p,
          missions: p.missions.filter((_, mIndex) => mIndex !== missionIndex),
        };
      })
    );
  };

  // Nettoyage des périodes/missions vides
  const sanitizePeriodes = (rawPeriodes) => {
    return rawPeriodes
      .map((p) => {
        const cleanMissions = (p.missions || []).filter((m) => {
          const titre = (m.titre || '').trim();
          const desc = (m.description || '').trim();
          const comp = (m.competences || '').trim();
          return titre || desc || comp;
        });

        return {
          ...p,
          missions: cleanMissions,
        };
      })
      .filter((p) => {
        const hasTitre = (p.titre || '').trim();
        const hasDates = p.dateDebut || p.dateFin;
        const hasMissions = (p.missions || []).length > 0;
        return hasTitre || hasDates || hasMissions;
      });
  };

  // ---------- SUBMIT ----------

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setIsSubmitting(true);

    try {
      const cleanedPeriodes = sanitizePeriodes(periodes);

      if (!cleanedPeriodes.length) {
        setError(
          'Veuillez renseigner au moins une période ou une mission avant de sauvegarder.'
        );
        setIsSubmitting(false);
        return;
      }

      // Construction éventuelle de l’évènement de calendrier (Option A)
      let calendarEventPayload = null;
      if (
        calendarEvent.enable &&
        calendarEvent.title.trim() &&
        calendarEvent.date
      ) {
        calendarEventPayload = {
          title: calendarEvent.title.trim(),
          date: calendarEvent.date,
          time: calendarEvent.time || null,
          location: calendarEvent.location || null,
          participantsRaw: calendarEvent.participants || '',
          notes: calendarEvent.notes || '',
        };
      }

      const payload = {
        periodes: cleanedPeriodes,
        status: 'EN_COURS',
        createdAt: new Date().toISOString(),
        calendarEvent: calendarEventPayload,
      };

      await journalService.createJournal(payload);

      navigate('/dashboard?tab=journal');
    } catch (err) {
      console.error(err);
      setError("Erreur lors de l'enregistrement du journal.");
    } finally {
      setIsSubmitting(false);
    }
  };

  // ---------- Rendu ----------

  return (
    <div className="max-w-5xl mx-auto px-4 py-8">
      {/* Lien retour tableau de bord */}
      <div className="mb-4">
        <button
          type="button"
          onClick={() => navigate('/dashboard?tab=journal')}
          className="inline-flex items-center text-sm text-primary-600 hover:text-primary-800"
        >
          ← Retour au tableau de bord
        </button>
      </div>

      <h1 className="text-2xl font-semibold mb-6">Créer une note mensuelle</h1>

      {error && (
        <div className="mb-4 text-red-600 text-sm bg-red-50 border border-red-200 px-4 py-2 rounded">
          {error}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-8">
        {periodes.map((periode, pIndex) => (
          <div
            key={periode.id}
            className="bg-white rounded-lg shadow border border-gray-200 p-6 space-y-4"
          >
            <div className="flex justify-between items-center">
              <div>
                <h2 className="text-lg font-semibold text-gray-800">
                  Période {pIndex + 1}
                </h2>
                <span className="text-xs text-gray-500">
                  {periode.dateDebut && periode.dateFin
                    ? `${periode.dateDebut} → ${periode.dateFin}`
                    : 'Dates non renseignées'}
                </span>
              </div>

              {periodes.length > 1 && (
                <button
                  type="button"
                  onClick={() => removePeriode(pIndex)}
                  className="text-xs text-red-600 hover:text-red-800"
                >
                  Supprimer la période
                </button>
              )}
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="md:col-span-1">
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Intitulé de la période
                </label>
                <input
                  type="text"
                  className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                  placeholder="Ex : Missions de novembre"
                  value={periode.titre}
                  onChange={(e) =>
                    handlePeriodeChange(pIndex, 'titre', e.target.value)
                  }
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Date de début
                </label>
                <input
                  type="date"
                  className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                  value={periode.dateDebut}
                  onChange={(e) =>
                    handlePeriodeChange(pIndex, 'dateDebut', e.target.value)
                  }
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Date de fin
                </label>
                <input
                  type="date"
                  className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                  value={periode.dateFin}
                  onChange={(e) =>
                    handlePeriodeChange(pIndex, 'dateFin', e.target.value)
                  }
                />
              </div>
            </div>

            <div className="space-y-4">
              {periode.missions.map((mission, mIndex) => (
                <div
                  key={mission.id}
                  className="border border-gray-200 rounded-md p-4 space-y-3"
                >
                  <div className="flex justify-between items-center">
                    <h3 className="text-sm font-semibold text-gray-700">
                      Mission {mIndex + 1}
                    </h3>

                    {/* On autorise la suppression pour les missions ajoutées (index > 0) */}
                    {mIndex > 0 && (
                      <button
                        type="button"
                        onClick={() => removeMission(pIndex, mIndex)}
                        className="text-xs text-red-600 hover:text-red-800"
                      >
                        Supprimer la mission
                      </button>
                    )}
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="block text-xs font-medium text-gray-600 mb-1">
                        Intitulé de la mission
                      </label>
                      <input
                        type="text"
                        className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                        placeholder="Ex : Développement d'une API REST"
                        value={mission.titre}
                        onChange={(e) =>
                          handleMissionChange(
                            pIndex,
                            mIndex,
                            'titre',
                            e.target.value
                          )
                        }
                      />
                    </div>
                    <div>
                      <label className="block text-xs font-medium text-gray-600 mb-1">
                        Compétences mobilisées
                      </label>
                      <input
                        type="text"
                        className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                        placeholder="Ex : C#, travail en équipe."
                        value={mission.competences}
                        onChange={(e) =>
                          handleMissionChange(
                            pIndex,
                            mIndex,
                            'competences',
                            e.target.value
                          )
                        }
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-xs font-medium text-gray-600 mb-1">
                      Description de la mission
                    </label>
                    <textarea
                      className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                      rows={3}
                      placeholder="Décrivez ce que vous avez réalisé, les outils utilisés, les résultats."
                      value={mission.description}
                      onChange={(e) =>
                        handleMissionChange(
                          pIndex,
                          mIndex,
                          'description',
                          e.target.value
                        )
                      }
                    />
                  </div>
                </div>
              ))}

              <button
                type="button"
                onClick={() => addMission(pIndex)}
                className="inline-flex items-center px-3 py-1.5 rounded-md text-xs font-medium bg-primary-50 text-primary-700 hover:bg-primary-100"
              >
                + Ajouter une mission
              </button>
            </div>
          </div>
        ))}

        {/* ---------- SECTION ÉVÉNEMENT CALENDRIER (Option A) ---------- */}
        <div className="bg-white rounded-lg shadow border border-primary-100 p-6 space-y-4">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-gray-800">
              Lier un événement de calendrier (optionnel)
            </h2>
            <label className="inline-flex items-center space-x-2 text-sm">
              <input
                type="checkbox"
                className="rounded border-gray-300"
                checked={calendarEvent.enable}
                onChange={(e) =>
                  setCalendarEvent((prev) => ({
                    ...prev,
                    enable: e.target.checked,
                  }))
                }
              />
              <span>Créer un événement lié à ce journal</span>
            </label>
          </div>

          {calendarEvent.enable && (
            <div className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Titre de l&apos;événement
                  </label>
                  <input
                    type="text"
                    className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                    placeholder='Ex : Entretien semestriel'
                    value={calendarEvent.title}
                    onChange={(e) =>
                      setCalendarEvent((prev) => ({
                        ...prev,
                        title: e.target.value,
                      }))
                    }
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Date
                  </label>
                  <input
                    type="date"
                    className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                    value={calendarEvent.date}
                    onChange={(e) =>
                      setCalendarEvent((prev) => ({
                        ...prev,
                        date: e.target.value,
                      }))
                    }
                  />
                </div>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Heure
                  </label>
                  <input
                    type="time"
                    className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                    value={calendarEvent.time}
                    onChange={(e) =>
                      setCalendarEvent((prev) => ({
                        ...prev,
                        time: e.target.value,
                      }))
                    }
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Lieu
                  </label>
                  <input
                    type="text"
                    className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                    placeholder="Ex : ESEO Angers, Salle de soutenance 2"
                    value={calendarEvent.location}
                    onChange={(e) =>
                      setCalendarEvent((prev) => ({
                        ...prev,
                        location: e.target.value,
                      }))
                    }
                  />
                </div>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Participants (emails séparés par des virgules)
                </label>
                <input
                  type="text"
                  className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                  placeholder="Ex : tuteur@eseo.fr, maitre.entreprise@boite.com, jury@eseo.fr"
                  value={calendarEvent.participants}
                  onChange={(e) =>
                    setCalendarEvent((prev) => ({
                      ...prev,
                      participants: e.target.value,
                    }))
                  }
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Notes / ordre du jour (optionnel)
                </label>
                <textarea
                  className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                  rows={3}
                  placeholder="Ex : Préparer le bilan semestriel, les objectifs à venir, etc."
                  value={calendarEvent.notes}
                  onChange={(e) =>
                    setCalendarEvent((prev) => ({
                      ...prev,
                      notes: e.target.value,
                    }))
                  }
                />
              </div>
            </div>
          )}
        </div>

        {/* Boutons bas de page */}
        <div className="flex items-center justify-between">
          <button
            type="button"
            onClick={addPeriode}
            className="inline-flex items-center px-4 py-2 rounded-md text-sm font-medium bg-gray-100 text-gray-700 hover:bg-gray-200"
          >
            + Ajouter une période
          </button>

          <div className="space-x-3">
            <button
              type="button"
              onClick={() => navigate('/dashboard?tab=journal')}
              className="inline-flex items-center px-4 py-2 rounded-md text-sm font-medium bg-white border border-gray-300 text-gray-700 hover:bg-gray-50"
            >
              Annuler
            </button>

            <button
              type="submit"
              disabled={isSubmitting}
              className="inline-flex items-center px-6 py-3 rounded-lg text-sm font-medium bg-primary-600 text-white hover:bg-primary-700 disabled:opacity-60"
            >
              {isSubmitting ? 'Enregistrement...' : 'Enregistrer le journal'}
            </button>
          </div>
        </div>
      </form>
    </div>
  );
};

export default CreateJournalPage;
</file>

<file path="sigl_frontend/src/App.jsx">
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';

import HomePage from './pages/HomePage';
import RegisterPage from './pages/RegisterPage';
import StudentDashboard from './pages/dashboard/StudentDashboard';

import CreateJournalPage from './pages/journal/CreateJournalPage';
import JournalDetailPage from './pages/journal/JournalDetailPage';

import ProfilePage from './pages/profile/ProfilePage'; // ta page profil (branche KC)
import CalendarPage from './pages/calendar/CalendarPage'; // branche calendrier
import EventDetailPage from './pages/calendar/EventDetailPage'; // branche calendrier

import DemandeEntretienPage from './pages/entretien/DemandeEntretienPage';
import MesEntretiensPage from './pages/entretien/MesEntretiensPage';
import PlanifierSoutenancePage from './pages/soutenance/PlanifierSoutenancePage';
import MaSoutenancePage from './pages/soutenance/MaSoutenancePage';
import GestionSoutenancesPage from './pages/soutenance/GestionSoutenancesPage';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Public */}
        <Route path="/" element={<HomePage />} />
        <Route path="/register" element={<RegisterPage />} />

        {/* Espace apprenti */}
        <Route path="/dashboard" element={<StudentDashboard />} />
        <Route path="/journal/create" element={<CreateJournalPage />} />
        <Route path="/journal/:id" element={<JournalDetailPage />} />

        {/* Profil utilisateur */}
        <Route path="/profile" element={<ProfilePage />} />

        {/* Calendrier global */}
        <Route path="/calendar" element={<CalendarPage />} />
        <Route path="/calendar/event/:id" element={<EventDetailPage />} />

        {/* Entretien routes */}
        <Route path="/entretien/demande" element={<DemandeEntretienPage />} />
        <Route path="/entretien/mes-entretiens" element={<MesEntretiensPage />} />

        {/* Soutenance routes */}
        <Route path="/soutenance/planifier" element={<PlanifierSoutenancePage />} />
        <Route path="/soutenance/ma-soutenance" element={<MaSoutenancePage />} />
        <Route path="/soutenance/gestion" element={<GestionSoutenancesPage />} />

        {/* Fallback */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
</file>

<file path="sigl_frontend/src/pages/dashboard/StudentDashboard.jsx">
import React, { useState, useEffect } from 'react';
import { useNavigate, Link, useLocation } from 'react-router-dom';
import authService from '../../services/authService';
import journalService from '../../services/journalService';
import bookingService from '../../services/bookingService';

/**
 * Dashboard principal de l'apprenti
 */
const StudentDashboard = () => {
  const [activeTab, setActiveTab] = useState('journal');
  const [journaux, setJournaux] = useState([]);
  const [journauxLoading, setJournauxLoading] = useState(false);
  const [journauxError, setJournauxError] = useState(null);
  
  // State for entretiens
  const [entretiens, setEntretiens] = useState([]);
  const [entretiensLoading, setEntretiensLoading] = useState(false);
  const [entretiensError, setEntretiensError] = useState(null);
  
  // State for soutenance
  const [soutenance, setSoutenance] = useState(null);
  const [soutenanceLoading, setSoutenanceLoading] = useState(false);
  const [soutenanceError, setSoutenanceError] = useState(null);

  const navigate = useNavigate();
  const location = useLocation();
  const currentUser = authService.getCurrentUser();


  // --- Gestion logout ---
  const handleLogout = async () => {
    await authService.logout();
    navigate('/');
  };

  // --- Gestion navigation vers profil ---
  const handleProfileClick = () => {
    console.log('Profile clicked - navigating to /profile');
    navigate('/profile');
  };

  // --- Infos user (nom + avatar) ---

  // On privilégie toujours "prenom + nom" (ou firstName + lastName),
  // puis on retombe sur nom seul, puis l'email.
  const displayName =
    [currentUser?.prenom || currentUser?.firstName, currentUser?.nom || currentUser?.lastName]
      .filter(Boolean)
      .join(' ') ||
    currentUser?.nom ||
    currentUser?.email ||
    'Utilisateur';

  const avatarUrl = currentUser?.avatar || currentUser?.avatarUrl || null;

  const avatarLetter =
    displayName?.trim()?.charAt(0)?.toUpperCase() || '?';

  const roleLabel = currentUser?.role || 'APPRENTI';

  // --- Onglets du dashboard ---
  const tabs = [
    { id: 'journal', name: 'Journal de formation', icon: '📔' },
    { id: 'documents', name: 'Mes documents', icon: '📄' },
    { id: 'calendar', name: 'Calendrier', icon: '📅' },
    { id: 'entretiens', name: 'Entretiens & Soutenances', icon: '💬' },
    { id: 'notifications', name: 'Notifications', icon: '🔔' },
  ];

  // --- Chargement des journaux pour l'onglet Journal ---
  useEffect(() => {
    const loadJournaux = async () => {
      try {
        setJournauxLoading(true);
        setJournauxError(null);
        const data = await journalService.getMyJournaux();
        // data = [{ id, createdAt, updatedAt, periodes, status }]
        const sorted = [...data].sort(
          (a, b) => new Date(b.createdAt) - new Date(a.createdAt)
        );
        setJournaux(sorted);
      } catch (error) {
        console.error('Erreur lors du chargement des journaux :', error);
        setJournauxError(
          "Impossible de charger votre journal de formation pour le moment."
        );
      } finally {
        setJournauxLoading(false);
      }
    };

    loadJournaux();
  }, []);

  // --- Chargement des entretiens avec bookingService (comme MesEntretiensPage) ---
  useEffect(() => {
    const loadEntretiens = async () => {
      try {
        setEntretiensLoading(true);
        setEntretiensError(null);
        
        const result = await bookingService.getMesEntretiens();
        if (result.success) {
          setEntretiens(result.data || []);
        } else {
          setEntretiensError("Impossible de charger vos entretiens pour le moment.");
        }
      } catch (error) {
        console.error('Erreur lors du chargement des entretiens :', error);
        setEntretiensError("Impossible de charger vos entretiens pour le moment.");
      } finally {
        setEntretiensLoading(false);
      }
    };

    loadEntretiens();
  }, []);

  // --- Chargement de la soutenance avec bookingService ---
  useEffect(() => {
    const loadSoutenance = async () => {
      try {
        setSoutenanceLoading(true);
        setSoutenanceError(null);
        
        const result = await bookingService.getMaSoutenance();
        if (result.success) {
          setSoutenance(result.data);
        } else {
          setSoutenanceError("Impossible de charger votre soutenance pour le moment.");
        }
      } catch (error) {
        console.error('Erreur lors du chargement de la soutenance :', error);
        setSoutenanceError("Impossible de charger votre soutenance pour le moment.");
      } finally {
        setSoutenanceLoading(false);
      }
    };

    loadSoutenance();
  }, []);

  const formatDate = (value) => {
    if (!value) return '—';
    try {
      return new Date(value).toLocaleDateString('fr-FR', {
        day: '2-digit',
        month: 'short',
        year: 'numeric',
      });
    } catch {
      return '—';
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'EN_COURS':
        return 'En cours';
      case 'SOUMIS':
        return 'Soumis';
      case 'VALIDE':
        return 'Validé';
      default:
        return 'En cours';
    }
  };

  const handleOpenJournal = (id) => {
    navigate(`/journal/${id}`);
  };

  const handleCreateJournal = () => {
    navigate('/journal/create');
  };

  const getEntretienStatusLabel = (status) => {
    switch (status) {
      case 'EN_ATTENTE':
        return 'En attente';
      case 'CONFIRME':
        return 'Confirmé';
      case 'ANNULE':
        return 'Annulé';
      default:
        return 'En attente';
    }
  };

  const getSoutenanceStatusLabel = (status) => {
    switch (status) {
      case 'PLANIFIEE':
        return 'Planifiée';
      case 'VALIDEE':
        return 'Validée';
      case 'ANNULEE':
        return 'Annulée';
      default:
        return 'Planifiée';
    }
  };

  const formatDateTime = (value) => {
    if (!value) return '—';
    try {
      return new Date(value).toLocaleDateString('fr-FR', {
        day: '2-digit',
        month: 'short',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
      });
    } catch {
      return '—';
    }
  };

  // --- Rendu du contenu par onglet ---
  const renderContent = () => {
    switch (activeTab) {
      case 'journal':
        return (
          <section className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
            <div className="flex items-center justify-between mb-4">
              <div>
                <h2 className="text-lg font-semibold text-gray-900">
                  Journal de formation
                </h2>
                <p className="text-sm text-gray-500">
                  Suivez vos missions et périodes d'alternance.
                </p>
              </div>
              <button
                type="button"
                onClick={handleCreateJournal}
                className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
              >
                + Créer un journal
              </button>
            </div>

            {journauxLoading && (
              <div className="py-6 text-sm text-gray-500">
                Chargement de vos journaux...
              </div>
            )}

            {journauxError && (
              <div className="mb-4 rounded-md bg-red-50 border border-red-200 px-4 py-3 text-sm text-red-700">
                {journauxError}
              </div>
            )}

            {!journauxLoading && !journauxError && journaux.length === 0 && (
              <div className="py-10 text-center text-sm text-gray-500">
                Aucun journal pour le moment.
                <br />
                Cliquez sur «&nbsp;Créer un journal&nbsp;» pour commencer à
                consigner vos missions.
              </div>
            )}

            {!journauxLoading && !journauxError && journaux.length > 0 && (
              <div className="mt-4 overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200 text-sm">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-4 py-2 text-left font-medium text-gray-500 uppercase tracking-wider">
                        Créé le
                      </th>
                      <th className="px-4 py-2 text-left font-medium text-gray-500 uppercase tracking-wider">
                        Dernière mise à jour
                      </th>
                      <th className="px-4 py-2 text-left font-medium text-gray-500 uppercase tracking-wider">
                        Nombre de périodes
                      </th>
                      <th className="px-4 py-2 text-left font-medium text-gray-500 uppercase tracking-wider">
                        Statut
                      </th>
                      <th className="px-4 py-2" />
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {journaux.map((j, index) => (
                      <tr key={j.id || j._id || `journal-${index}`} className="hover:bg-gray-50">
                        <td className="px-4 py-2 whitespace-nowrap text-gray-700">
                          {formatDate(j.createdAt)}
                        </td>
                        <td className="px-4 py-2 whitespace-nowrap text-gray-700">
                          {formatDate(j.updatedAt)}
                        </td>
                        <td className="px-4 py-2 whitespace-nowrap text-gray-700">
                          {Array.isArray(j.periodes) ? j.periodes.length : 0}
                        </td>
                        <td className="px-4 py-2 whitespace-nowrap">
                          <span className="inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium bg-blue-50 text-blue-700">
                            {getStatusLabel(j.status)}
                          </span>
                        </td>
                        <td className="px-4 py-2 text-right whitespace-nowrap">
                          <button
                            type="button"
                            onClick={() => handleOpenJournal(j.id)}
                            className="text-primary-600 hover:text-primary-800 text-sm font-medium"
                          >
                            Ouvrir
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </section>
        );

      case 'documents':
        return (
          <section className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 text-sm text-gray-600">
            <h2 className="text-lg font-semibold text-gray-900 mb-2">
              Mes documents
            </h2>
            <p>Module à venir : dépôt et suivi des documents (rapports, CV…).</p>
          </section>
        );

      case 'calendar':
        return (
          <section className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 text-sm text-gray-600">
            <h2 className="text-lg font-semibold text-gray-900 mb-2">
              Calendrier
            </h2>
            <p>
              Module à venir : synchronisation du calendrier des soutenances,
              sessions et événements.
            </p>
          </section>
        );

      case 'entretiens':
        return (
          <div className="space-y-6">
            {/* Section Entretiens */}
            <section className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
              <div className="flex items-center justify-between mb-4">
                <div>
                  <h2 className="text-lg font-semibold text-gray-900">
                    Mes Entretiens
                  </h2>
                  <p className="text-sm text-gray-500">
                    Planification et suivi de vos entretiens.
                  </p>
                </div>
                <div className="flex space-x-2">
                  <Link
                    to="/entretien/demande"
                    className="inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
                  >
                    Demander un entretien
                  </Link>
                  <Link
                    to="/entretien/mes-entretiens"
                    className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
                  >
                    Voir tous mes entretiens
                  </Link>
                </div>
              </div>

              {entretiensLoading && (
                <div className="py-6 text-sm text-gray-500">
                  Chargement de vos entretiens...
                </div>
              )}

              {entretiensError && (
                <div className="mb-4 rounded-md bg-red-50 border border-red-200 px-4 py-3 text-sm text-red-700">
                  {entretiensError}
                </div>
              )}

              {!entretiensLoading && !entretiensError && entretiens.length === 0 && (
                <div className="py-10 text-center text-sm text-gray-500">
                  Aucun entretien planifié pour le moment.
                  <br />
                  Cliquez sur «&nbsp;Demander un entretien&nbsp;» pour en planifier un.
                </div>
              )}

              {!entretiensLoading && !entretiensError && entretiens.length > 0 && (
                <div className="mt-4 overflow-x-auto">
                  <table className="min-w-full divide-y divide-gray-200 text-sm">
                    <thead className="bg-gray-50">
                      <tr>
                        <th className="px-4 py-2 text-left font-medium text-gray-500 uppercase tracking-wider">
                          Objet
                        </th>
                        <th className="px-4 py-2 text-left font-medium text-gray-500 uppercase tracking-wider">
                          Date et heure
                        </th>
                        <th className="px-4 py-2 text-left font-medium text-gray-500 uppercase tracking-wider">
                          Participants
                        </th>
                        <th className="px-4 py-2 text-left font-medium text-gray-500 uppercase tracking-wider">
                          Statut
                        </th>
                        <th className="px-4 py-2" />
                      </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200">
                      {entretiens.slice(0, 3).map((entretien, index) => (
                        <tr key={entretien.id || entretien._id || `entretien-${index}`} className="hover:bg-gray-50">
                          <td className="px-4 py-2 whitespace-nowrap text-gray-700 font-medium">
                            {entretien.objet || 'Entretien'}
                          </td>
                          <td className="px-4 py-2 whitespace-nowrap text-gray-700">
                            {formatDateTime(entretien.debut)}
                          </td>
                          <td className="px-4 py-2 whitespace-nowrap text-gray-700">
                            {entretien.participants?.length || 0} participant(s)
                          </td>
                          <td className="px-4 py-2 whitespace-nowrap">
                            <span className={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${
                              entretien.status === 'CONFIRME'
                                ? 'bg-green-50 text-green-700'
                                : entretien.status === 'ANNULE'
                                ? 'bg-red-50 text-red-700'
                                : 'bg-yellow-50 text-yellow-700'
                            }`}>
                              {getEntretienStatusLabel(entretien.status)}
                            </span>
                          </td>
                          <td className="px-4 py-2 text-right whitespace-nowrap">
                            <Link
                              to="/entretien/mes-entretiens"
                              className="text-primary-600 hover:text-primary-800 text-sm font-medium"
                            >
                              Voir détails
                            </Link>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  {entretiens.length > 3 && (
                    <div className="mt-3 text-center">
                      <Link
                        to="/entretien/mes-entretiens"
                        className="text-primary-600 hover:text-primary-800 text-sm font-medium"
                      >
                        Voir tous les entretiens ({entretiens.length})
                      </Link>
                    </div>
                  )}
                </div>
              )}
            </section>

            {/* Section Soutenance */}
            <section className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
              <div className="flex items-center justify-between mb-4">
                <div>
                  <h2 className="text-lg font-semibold text-gray-900">
                    Ma Soutenance
                  </h2>
                  <p className="text-sm text-gray-500">
                    Informations sur votre soutenance de fin d'études.
                  </p>
                </div>
                <div className="flex space-x-2">
                  <Link
                    to="/soutenance/planifier"
                    className="inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
                  >
                    Planifier
                  </Link>
                  <Link
                    to="/soutenance/ma-soutenance"
                    className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
                  >
                    Voir ma soutenance
                  </Link>
                </div>
              </div>

              {soutenanceLoading && (
                <div className="py-6 text-sm text-gray-500">
                  Chargement de votre soutenance...
                </div>
              )}

              {soutenanceError && (
                <div className="mb-4 rounded-md bg-red-50 border border-red-200 px-4 py-3 text-sm text-red-700">
                  {soutenanceError}
                </div>
              )}

              {!soutenanceLoading && !soutenanceError && !soutenance && (
                <div className="py-10 text-center text-sm text-gray-500">
                  Aucune soutenance planifiée pour le moment.
                  <br />
                  Cliquez sur «&nbsp;Planifier&nbsp;» pour organiser votre soutenance.
                </div>
              )}

              {!soutenanceLoading && !soutenanceError && soutenance && (
                <div className="bg-gray-50 rounded-lg p-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900 mb-2">Informations générales</h3>
                      <dl className="space-y-1 text-sm">
                        <div className="flex justify-between">
                          <dt className="text-gray-500">Date et heure :</dt>
                          <dd className="text-gray-900 font-medium">
                            {formatDateTime(soutenance.dateHeure)}
                          </dd>
                        </div>
                        <div className="flex justify-between">
                          <dt className="text-gray-500">Salle :</dt>
                          <dd className="text-gray-900">{soutenance.salle || '—'}</dd>
                        </div>
                        <div className="flex justify-between">
                          <dt className="text-gray-500">Statut :</dt>
                          <dd>
                            <span className={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${
                              soutenance.status === 'VALIDEE'
                                ? 'bg-green-50 text-green-700'
                                : soutenance.status === 'ANNULEE'
                                ? 'bg-red-50 text-red-700'
                                : 'bg-blue-50 text-blue-700'
                            }`}>
                              {getSoutenanceStatusLabel(soutenance.status)}
                            </span>
                          </dd>
                        </div>
                      </dl>
                    </div>
                    <div>
                      <h3 className="text-sm font-medium text-gray-900 mb-2">Jury</h3>
                      <div className="space-y-1 text-sm">
                        {soutenance.jury && soutenance.jury.length > 0 ? (
                          soutenance.jury.map((membre, index) => (
                            <div key={membre.id || membre.email || `jury-member-${index}`} className="text-gray-700">
                              {membre.nom || membre.email || 'Membre du jury'}
                            </div>
                          ))
                        ) : (
                          <div className="text-gray-500">Aucun membre du jury assigné</div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </section>
          </div>
        );

      case 'notifications':
        return (
          <section className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 text-sm text-gray-600">
            <h2 className="text-lg font-semibold text-gray-900 mb-2">
              Notifications
            </h2>
            <p>Module à venir : notifications système et rappels.</p>
          </section>
        );

      default:
        return null;
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <header className="bg-white shadow-sm border-b border-gray-200">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center">
              <h1 className="text-xl font-semibold text-gray-900">
                Dashboard Apprenti
              </h1>
            </div>

            <div className="flex items-center space-x-4">
              {/* User info - clickable to go to profile */}
              <div
                className="flex items-center space-x-3 cursor-pointer hover:bg-gray-50 rounded-lg p-2 transition-colors duration-200"
                onClick={handleProfileClick}
                title="Voir mon profil"
              >
                {avatarUrl ? (
                  <img
                    className="h-8 w-8 rounded-full object-cover"
                    src={avatarUrl}
                    alt={displayName}
                  />
                ) : (
                  <div className="h-8 w-8 rounded-full bg-primary-600 flex items-center justify-center text-white text-sm font-medium">
                    {avatarLetter}
                  </div>
                )}
                <div className="text-sm">
                  <div className="font-medium text-gray-900">{displayName}</div>
                  <div className="text-gray-500">{roleLabel}</div>
                </div>
              </div>

              {/* Logout button */}
              <button
                onClick={handleLogout}
                className="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
              >
                Déconnexion
              </button>
            </div>
          </div>
        </div>
      </header>

      {/* Main content */}
      <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        <div className="px-4 py-6 sm:px-0">
          {/* Tabs */}
          <div className="border-b border-gray-200 mb-6">
            <nav className="-mb-px flex space-x-8" aria-label="Tabs">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
                    activeTab === tab.id
                      ? 'border-primary-500 text-primary-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  }`}
                >
                  <span className="mr-2">{tab.icon}</span>
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {/* Tab content */}
          {renderContent()}
        </div>
      </main>
    </div>
  );
};

export default StudentDashboard;
</file>

<file path="sigl_backend/app/app.js">
// Load environment variables first
require('dotenv').config();

const express = require('express');
const mongoose = require('mongoose');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');
const cors = require('cors');
const journalRoutes = require('./journal/routes');
const app = express();
const calendarRoutes = require('./calendar/routes');
const testRoutes = require('./test/routes');
const userRoutes = require('./user/routes');
const authRoutes = require('./auth/auth.routes');
const entretienRoutes = require('./entretien/entretien.routes');
const soutenanceRoutes = require('./soutenance/soutenance.routes');

// Environment validation
const requiredEnvVars = [
    'JWT_SECRET',
    'JWT_REFRESH_SECRET',
    'BCRYPT_SALT_ROUNDS',
    'NODE_ENV',
    'MONGODB_URI'
];

const missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);
if (missingEnvVars.length > 0) {
    console.error('❌ Missing required environment variables:', missingEnvVars.join(', '));
    process.exit(1);
}

// Log startup information (without sensitive data)
console.log('🚀 Starting application...');
console.log(`📦 Environment: ${process.env.NODE_ENV}`);
console.log(`🔌 Port: ${process.env.PORT || 3000}`);

// MongoDB Connection
const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/database';
mongoose.connect(mongoUri)
    .then(() => {
        console.log('✅ MongoDB connection successful');
    })
    .catch((error) => {
        console.error('❌ MongoDB connection error:', error.message);
        process.exit(1);
    });

// Security Middleware - Helmet (must be early in middleware stack)
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    crossOriginEmbedderPolicy: false,
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
}));

// CORS Configuration
const allowedOrigins = [
  process.env.FRONTEND_URL || 'http://localhost:5173',
  'http://localhost:5173',
  'http://localhost:4173', // (si tu build/testes en preview Vite)
];

app.use(cors({
  origin: function (origin, callback) {
    // autoriser aussi les requêtes sans origin (ex: curl, Postman)
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      console.warn(`CORS: origine non autorisée -> ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  exposedHeaders: ['X-Total-Count'],
}));

// Body parsing middleware with size limits
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Rate Limiting Configuration
const generalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    message: {
        error: 'Too many requests from this IP, please try again later.',
        retryAfter: '15 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
        console.warn(`🚨 Rate limit exceeded for IP: ${req.ip} on ${req.path}`);
        res.status(429).json({
            error: 'Too many requests from this IP, please try again later.',
            retryAfter: '15 minutes'
        });
    }
});

const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // limit each IP to 5 requests per windowMs for auth endpoints
    message: {
        error: 'Too many authentication attempts, please try again later.',
        retryAfter: '15 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
        console.warn(`🚨 Auth rate limit exceeded for IP: ${req.ip} on ${req.path}`);
        res.status(429).json({
            error: 'Too many authentication attempts, please try again later.',
            retryAfter: '15 minutes'
        });
    }
});

// Apply general rate limiting to all requests
app.use(generalLimiter);

// Request Logging
if (process.env.NODE_ENV === 'development') {
    app.use(morgan('dev'));
} else {
    app.use(morgan('combined'));
}

// Health check route
app.get('/status', (req, res) => {
    res.json({
        status: 'Running',
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV,
        database: mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected',
        uptime: process.uptime()
    });
});

// Routes registration
app.use('/api/test', testRoutes);
app.use('/api/users', userRoutes);
app.use('/api/calendar', calendarRoutes);
app.use('/api/journaux', journalRoutes);
app.use('/api/entretiens', entretienRoutes);
app.use('/api/soutenances', soutenanceRoutes);

// Apply stricter rate limiting to auth endpoints
app.use('/api/auth', authLimiter, authRoutes);

// 404 Handler
app.use((req, res) => {
    console.warn(`🔍 404 - Route not found: ${req.method} ${req.path} from IP: ${req.ip}`);
    res.status(404).json({
        error: 'Route not found',
        path: req.path,
        method: req.method
    });
});

// Global Error Handler
app.use((error, req, res, next) => {
    // Log error details for debugging (without sensitive information)
    console.error('🚨 Global Error Handler:', {
        message: error.message,
        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
        path: req.path,
        method: req.method,
        ip: req.ip,
        timestamp: new Date().toISOString()
    });

    // Handle specific error types
    if (error.name === 'ValidationError') {
        return res.status(400).json({
            error: 'Validation Error',
            message: 'Invalid input data',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }

    if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({
            error: 'Authentication Error',
            message: 'Invalid token'
        });
    }

    if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
            error: 'Authentication Error',
            message: 'Token expired'
        });
    }

    if (error.name === 'CastError') {
        return res.status(400).json({
            error: 'Invalid ID',
            message: 'Invalid resource identifier'
        });
    }

    if (error.code === 11000) {
        return res.status(409).json({
            error: 'Duplicate Entry',
            message: 'Resource already exists'
        });
    }

    // Default error response
    const statusCode = error.statusCode || error.status || 500;
    res.status(statusCode).json({
        error: statusCode === 500 ? 'Internal Server Error' : error.message || 'An error occurred',
        message: statusCode === 500 ? 'Something went wrong on our end' : error.message,
        ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
    });
});

// Graceful shutdown handling
const gracefulShutdown = (signal) => {
    console.log(`\n🛑 Received ${signal}. Starting graceful shutdown...`);
    
    // Close MongoDB connection
    mongoose.connection.close(() => {
        console.log('📦 MongoDB connection closed');
    });
    
    // Close server
    server.close(() => {
        console.log('🔌 HTTP server closed');
        console.log('✅ Graceful shutdown completed');
        process.exit(0);
    });
    
    // Force close after 10 seconds
    setTimeout(() => {
        console.error('⚠️  Forced shutdown after timeout');
        process.exit(1);
    }, 10000);
};

// Start server
const PORT = process.env.PORT || 3000;
const server = app.listen(PORT, () => {
    console.log(`🚀 Server running on port ${PORT}`);
    console.log(`🌍 Environment: ${process.env.NODE_ENV}`);
    console.log(`🔒 Security middleware active`);
    console.log(`📊 Rate limiting configured`);
    console.log('✅ Application startup complete');
});

// Register shutdown handlers
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
    console.error('💥 Uncaught Exception:', error);
    gracefulShutdown('UNCAUGHT_EXCEPTION');
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
    console.error('💥 Unhandled Rejection at:', promise, 'reason:', reason);
    gracefulShutdown('UNHANDLED_REJECTION');
});

module.exports = app;
</file>

</files>
