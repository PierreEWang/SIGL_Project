This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
API_test/Auth/Change Password - Valid.bru
API_test/Auth/Change Password - Weak Password.bru
API_test/Auth/folder.bru
API_test/Auth/Login - Invalid Credentials.bru
API_test/Auth/Login - Valid Admin.bru
API_test/Auth/Login - Valid Credentials.bru
API_test/Auth/Logout - Valid.bru
API_test/Auth/Protected Route - Invalid Token.bru
API_test/Auth/Protected Route - No Token.bru
API_test/Auth/Token Refresh - Invalid Token.bru
API_test/Auth/Token Refresh - Valid.bru
API_test/Auth/User Registration - Complete Flow.bru
API_test/bruno.json
API_test/collection.bru
API_test/environments/local.bru
API_test/SETUP.md
API_test/Status.bru
API_test/Test/folder.bru
API_test/Test/Test GET.bru
API_test/Test/Test POST.bru
API_test/Upload/folder.bru
API_test/User/Delete User - Invalid ID.bru
API_test/User/Delete User - Valid ID.bru
API_test/User/folder.bru
API_test/User/Get User Profile - Invalid ID.bru
API_test/User/Get User Profile - Not Found.bru
API_test/User/Get User Profile - Valid ID.bru
API_test/User/List All Users.bru
API_test/User/Register User - Admin].bru
API_test/User/Register User - Duplicate Email.bru
API_test/User/Register User - Invalid Email.bru
API_test/User/Register User - Invalid Role.bru
API_test/User/Register User - Invalid Username.bru
API_test/User/Register User - Missing Fields.bru
API_test/User/Register User - Valid copy.bru
API_test/User/Register User - Valid Role.bru
API_test/User/Register User - Valid.bru
API_test/User/Register User - Weak Password.bru
API_test/User/Update User - Invalid ID.bru
API_test/User/Update User - No Fields.bru
API_test/User/Update User - Valid.bru
database/database/candidatures.bson
database/database/candidatures.metadata.json
database/database/commentaires.bson
database/database/commentaires.metadata.json
database/database/competences.bson
database/database/competences.metadata.json
database/database/creneaux.bson
database/database/creneaux.metadata.json
database/database/documents.bson
database/database/documents.metadata.json
database/database/entreprises.bson
database/database/entreprises.metadata.json
database/database/entretiens.bson
database/database/entretiens.metadata.json
database/database/evaluations.bson
database/database/evaluations.metadata.json
database/database/journal_entries.bson
database/database/journal_entries.metadata.json
database/database/jurys.bson
database/database/jurys.metadata.json
database/database/notifications.bson
database/database/notifications.metadata.json
database/database/offres.bson
database/database/offres.metadata.json
database/database/prelude.json
database/database/promotions.bson
database/database/promotions.metadata.json
database/database/rapports.bson
database/database/rapports.metadata.json
database/database/soutenances.bson
database/database/soutenances.metadata.json
database/database/utilisateurs.bson
database/database/utilisateurs.metadata.json
package.json
README.md
sigl_backend/.env
sigl_backend/.gitignore
sigl_backend/app/app.js
sigl_backend/app/auth/auth.controller.js
sigl_backend/app/auth/auth.model.js
sigl_backend/app/auth/auth.repository.js
sigl_backend/app/auth/auth.routes.js
sigl_backend/app/auth/auth.service.js
sigl_backend/app/common/models/user.model.js
sigl_backend/app/config/jwt.config.js
sigl_backend/app/journal/controller.js
sigl_backend/app/journal/journalEntry.model.js
sigl_backend/app/journal/repository.js
sigl_backend/app/journal/routes.js
sigl_backend/app/journal/service.js
sigl_backend/app/middleware/authenticate.js
sigl_backend/app/middleware/authorize.js
sigl_backend/app/test/controller.js
sigl_backend/app/test/routes.js
sigl_backend/app/user/controller.js
sigl_backend/app/user/repository.js
sigl_backend/app/user/routes.js
sigl_backend/app/user/service.js
sigl_backend/Dockerfile
sigl_backend/package.json
sigl_backend/README.md
sigl_frontend/.env
sigl_frontend/.gitignore
sigl_frontend/index.html
sigl_frontend/package.json
sigl_frontend/postcss.config.js
sigl_frontend/public/images/image_accueil (2).jpg
sigl_frontend/public/images/image_accueil (3).jpg
sigl_frontend/public/images/image_accueil (4).jpg
sigl_frontend/public/images/image_accueil.jpg
sigl_frontend/src/App.jsx
sigl_frontend/src/components/Header.jsx
sigl_frontend/src/components/LoginForm.jsx
sigl_frontend/src/components/TestConnection.jsx
sigl_frontend/src/main.jsx
sigl_frontend/src/pages/dashboard/StudentDashboard.jsx
sigl_frontend/src/pages/HomePage.jsx
sigl_frontend/src/pages/journal/CreateJournalPage.jsx
sigl_frontend/src/pages/journal/JournalDetailPage.jsx
sigl_frontend/src/pages/RegisterPage.jsx
sigl_frontend/src/services/Api.js
sigl_frontend/src/services/authService.js
sigl_frontend/src/services/journalService.js
sigl_frontend/src/styles/index.css
sigl_frontend/tailwind.config.js
sigl_frontend/vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="package.json">
{
  "dependencies": {
    "repomix": "^1.9.1"
  }
}
</file>

<file path="sigl_frontend/src/pages/journal/JournalDetailPage.jsx">
import React, { useEffect, useState } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import journalService from '../../services/journalService';

const JournalDetailPage = () => {
  const { id } = useParams();
  const navigate = useNavigate();

  const [journal, setJournal] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchJournal = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // On réutilise la route GET /api/journaux
        const journaux = await journalService.getMyJournaux();

        const found =
          journaux.find((j) => j.id === id) ||
          journaux[parseInt(id, 10)] || // fallback si jamais l'id était un index
          null;

        if (!found) {
          setError('Journal introuvable.');
        } else {
          setJournal(found);
        }
      } catch (err) {
        console.error(err);
        setError('Erreur lors du chargement du journal.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchJournal();
  }, [id]);

  const formatDate = (dateString) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    if (Number.isNaN(date.getTime())) return dateString;
    return date.toLocaleDateString('fr-FR', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
    });
  };

  if (isLoading) {
    return (
      <div className="max-w-5xl mx-auto px-4 py-8">
        <p className="text-gray-600">Chargement du journal...</p>
      </div>
    );
  }

  if (error || !journal) {
    return (
      <div className="max-w-5xl mx-auto px-4 py-8 space-y-4">
        <p className="text-red-600 text-sm">{error || 'Journal introuvable.'}</p>
        <button
          onClick={() => navigate('/dashboard?tab=journal')}
          className="inline-flex items-center px-4 py-2 rounded-md text-sm font-medium bg-primary-600 text-white hover:bg-primary-700"
        >
          ← Retour au journal de formation
        </button>
      </div>
    );
  }

  return (
    <div className="max-w-5xl mx-auto px-4 py-8 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-semibold text-gray-900 mb-1">
            Détail de la note mensuelle
          </h1>
          <p className="text-sm text-gray-500">
            Créée le {formatDate(journal.createdAt)}
          </p>
        </div>
        <button
          onClick={() => navigate('/dashboard?tab=journal')}
          className="inline-flex items-center px-4 py-2 rounded-md text-sm font-medium bg-gray-100 text-gray-700 hover:bg-gray-200"
        >
          ← Retour au journal
        </button>
      </div>

      {journal.periodes?.length ? (
        <div className="space-y-6">
          {journal.periodes.map((periode, pIndex) => (
            <div
              key={periode.id || pIndex}
              className="bg-white border border-gray-200 rounded-lg shadow-sm p-6 space-y-4"
            >
              <div className="flex justify-between items-center">
                <h2 className="text-lg font-semibold text-gray-800">
                  Période {pIndex + 1}{' '}
                  {periode.titre ? `- ${periode.titre}` : ''}
                </h2>
                <span className="text-xs text-gray-500">
                  {periode.dateDebut && periode.dateFin
                    ? `${periode.dateDebut} → ${periode.dateFin}`
                    : ''}
                </span>
              </div>

              {periode.missions?.length ? (
                <div className="space-y-3">
                  {periode.missions.map((mission, mIndex) => (
                    <div
                      key={mission.id || mIndex}
                      className="border border-gray-200 rounded-md p-4 bg-gray-50 space-y-2"
                    >
                      <h3 className="text-sm font-semibold text-gray-800">
                        Mission {mIndex + 1}{' '}
                        {mission.titre ? `- ${mission.titre}` : ''}
                      </h3>
                      {mission.competences && (
                        <p className="text-xs text-gray-600">
                          <span className="font-medium">Compétences : </span>
                          {mission.competences}
                        </p>
                      )}
                      {mission.description && (
                        <p className="text-sm text-gray-700 whitespace-pre-line">
                          {mission.description}
                        </p>
                      )}
                    </div>
                  ))}
                </div>
              ) : (
                <p className="text-sm text-gray-500">
                  Aucune mission renseignée pour cette période.
                </p>
              )}
            </div>
          ))}
        </div>
      ) : (
        <p className="text-sm text-gray-500">Aucune période renseignée.</p>
      )}
    </div>
  );
};

export default JournalDetailPage;
</file>

<file path="API_test/Auth/Change Password - Valid.bru">
meta {
  name: Change Password - Valid
  type: http
  seq: 5
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/change-password
  body: json
  auth: bearer
}

auth:bearer {
  token: {{accessToken}}
}

body:json {
  {
    "currentPassword": "{{testPassword}}",
    "newPassword": "NewSecurePass123!"
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response has appropriate message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('Password changed successfully');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('password');
    expect(res.getBody()).to.not.have.property('tokens');
    expect(res.getBody()).to.not.have.property('data');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 200) {
    // Update password in environment for future tests
    bru.setEnvVar("testPassword", "NewSecurePass123!");
    // Clear tokens as they should be invalidated after password change
    bru.setEnvVar("accessToken", "");
    bru.setEnvVar("refreshToken", "");
  }
}
</file>

<file path="API_test/Auth/Change Password - Weak Password.bru">
meta {
  name: Change Password - Weak Password
  type: http
  seq: 7
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/change-password
  body: json
  auth: bearer
}

auth:bearer {
  token: {{accessToken}}
}

body:json {
  {
    "currentPassword": "{{testPassword}}",
    "newPassword": "weak"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has appropriate error", function() {
    expect(res.getBody()).to.have.property('error');
    expect(['WEAK_PASSWORD', 'WEAK_PASSWORD_COMPLEXITY']).to.include(res.getBody().error);
  });
  
  test("Response has descriptive message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('password');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('tokens');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/folder.bru">
meta {
  name: Auth
  seq: 4
}

auth {
  mode: inherit
}
</file>

<file path="API_test/Auth/Login - Invalid Credentials.bru">
meta {
  name: Login - Invalid Credentials
  type: http
  seq: 2
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/login
  body: json
  auth: none
}

body:json {
  {
    "email": "{{testUserEmail}}",
    "password": "wrongpassword"
  }
}

tests {
  test("Status code is 401", function() {
    expect(res.getStatus()).to.equal(401);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has error code", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal('INVALID_CREDENTIALS');
  });
  
  test("Response message is generic", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Invalid email or password');
  });
  
  test("No sensitive information leaked", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('tokens');
    expect(res.getBody()).to.not.have.property('user');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Login - Valid Admin.bru">
meta {
  name: Login - Valid Admin
  type: http
  seq: 11
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/login
  body: json
  auth: none
}

body:json {
  {
    "email": "admin@admin.fr",
    "password": "goodlife"
  }
}

script:post-response {
  if (res.getStatus() === 200) {
    const data = res.getBody().data;
    bru.setEnvVar("accessToken", data.tokens.accessToken);
    bru.setEnvVar("refreshToken", data.tokens.refreshToken);
    bru.setEnvVar("loggedInUserId", data.user.id);
    bru.setEnvVar("userRole", data.user.role);
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('data');
    expect(res.getBody().data).to.have.property('user');
    const user = res.getBody().data.user;
    expect(user).to.have.property('id');
    expect(user).to.have.property('nom');
    expect(user).to.have.property('email');
    expect(user).to.have.property('role');
    expect(user).to.not.have.property('password');
  });
  
  test("Response contains tokens", function() {
    expect(res.getBody().data).to.have.property('tokens');
    const tokens = res.getBody().data.tokens;
    expect(tokens).to.have.property('accessToken');
    expect(tokens).to.have.property('refreshToken');
    expect(tokens).to.have.property('tokenType');
    expect(tokens).to.have.property('expiresIn');
    expect(tokens.tokenType).to.equal('Bearer');
  });
  
  test("Tokens are valid JWT format", function() {
    const tokens = res.getBody().data.tokens;
    // JWT tokens should have 3 parts separated by dots
    expect(tokens.accessToken.split('.').length).to.equal(3);
    expect(tokens.refreshToken.split('.').length).to.equal(3);
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Login - Valid Credentials.bru">
meta {
  name: Login - Valid Credentials
  type: http
  seq: 1
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/login
  body: json
  auth: none
}

body:json {
  {
    "email": "{{testUserEmail}}",
    "password": "{{testPassword}}"
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('data');
    expect(res.getBody().data).to.have.property('user');
    const user = res.getBody().data.user;
    expect(user).to.have.property('id');
    expect(user).to.have.property('nom');
    expect(user).to.have.property('email');
    expect(user).to.have.property('role');
    expect(user).to.not.have.property('password');
  });
  
  test("Response contains tokens", function() {
    expect(res.getBody().data).to.have.property('tokens');
    const tokens = res.getBody().data.tokens;
    expect(tokens).to.have.property('accessToken');
    expect(tokens).to.have.property('refreshToken');
    expect(tokens).to.have.property('tokenType');
    expect(tokens).to.have.property('expiresIn');
    expect(tokens.tokenType).to.equal('Bearer');
  });
  
  test("Tokens are valid JWT format", function() {
    const tokens = res.getBody().data.tokens;
    // JWT tokens should have 3 parts separated by dots
    expect(tokens.accessToken.split('.').length).to.equal(3);
    expect(tokens.refreshToken.split('.').length).to.equal(3);
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 200) {
    const data = res.getBody().data;
    bru.setEnvVar("accessToken", data.tokens.accessToken);
    bru.setEnvVar("refreshToken", data.tokens.refreshToken);
    bru.setEnvVar("loggedInUserId", data.user.id);
    bru.setEnvVar("userRole", data.user.role);
  }
}
</file>

<file path="API_test/Auth/Logout - Valid.bru">
meta {
  name: Logout - Valid
  type: http
  seq: 4
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/logout
  body: none
  auth: bearer
}

auth:bearer {
  token: {{accessToken}}
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response has logout message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Logout successful');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('tokens');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 200) {
    // Clear tokens after successful logout
    bru.setEnvVar("accessToken", "");
    bru.setEnvVar("refreshToken", "");
  }
}
</file>

<file path="API_test/Auth/Protected Route - Invalid Token.bru">
meta {
  name: Protected Route - Invalid Token
  type: http
  seq: 9
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{loggedInUserId}}
  body: none
  auth: bearer
}

auth:bearer {
  token: invalid.jwt.token
}

tests {
  test("Status code is 401", function() {
    expect(res.getStatus()).to.equal(401);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has token error", function() {
    expect(res.getBody()).to.have.property('error');
    expect(['INVALID_TOKEN', 'TOKEN_VERIFICATION_FAILED']).to.include(res.getBody().error);
  });
  
  test("Response has appropriate message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('token');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('user');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Protected Route - No Token.bru">
meta {
  name: Protected Route - No Token
  type: http
  seq: 8
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{loggedInUserId}}
  body: none
  auth: none
}

tests {
  test("Status code is 401", function() {
    expect(res.getStatus()).to.equal(401);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has authentication error", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal('MISSING_TOKEN');
  });
  
  test("Response has appropriate message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('No token provided');
  });
  
  test("No sensitive data in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('user');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Token Refresh - Invalid Token.bru">
meta {
  name: Token Refresh - Invalid Token
  type: http
  seq: 6
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/refresh
  body: none
  auth: bearer
}

auth:bearer {
  token: invalid.jwt.token
}

tests {
  test("Status code is 401", function() {
    expect(res.getStatus()).to.equal(401);
  });
  
  test("Response has success flag false", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(false);
  });
  
  test("Response has appropriate error", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal('INVALID_REFRESH_TOKEN');
  });
  
  test("Response has error message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('Invalid or expired refresh token');
  });
  
  test("No tokens in response", function() {
    expect(res.getBody()).to.not.have.property('data');
    expect(res.getBody()).to.not.have.property('tokens');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/Auth/Token Refresh - Valid.bru">
meta {
  name: Token Refresh - Valid
  type: http
  seq: 3
}

post {
  url: {{baseUrl}}{{apiPath}}/auth/refresh
  body: none
  auth: bearer
}

auth:bearer {
  token: {{refreshToken}}
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success flag", function() {
    expect(res.getBody()).to.have.property('success');
    expect(res.getBody().success).to.equal(true);
  });
  
  test("Response contains new tokens", function() {
    expect(res.getBody()).to.have.property('data');
    const data = res.getBody().data;
    expect(data).to.have.property('accessToken');
    expect(data).to.have.property('refreshToken');
    expect(data).to.have.property('tokenType');
    expect(data).to.have.property('expiresIn');
    expect(data.tokenType).to.equal('Bearer');
  });
  
  test("New access token is different from old one", function() {
    const newAccessToken = res.getBody().data.accessToken;
    const oldAccessToken = bru.getEnvVar("accessToken");
    expect(newAccessToken).to.not.equal(oldAccessToken);
  });
  
  test("Tokens are valid JWT format", function() {
    const data = res.getBody().data;
    expect(data.accessToken.split('.').length).to.equal(3);
    expect(data.refreshToken.split('.').length).to.equal(3);
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 200) {
    const data = res.getBody().data;
    bru.setEnvVar("accessToken", data.accessToken);
    bru.setEnvVar("refreshToken", data.refreshToken);
  }
}
</file>

<file path="API_test/Auth/User Registration - Complete Flow.bru">
meta {
  name: User Registration - Complete Flow
  type: http
  seq: 10
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "authtest",
    "email": "authtest@example.com",
    "password": "AuthTest123!",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.include('succès');
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('user');
    const user = res.getBody().user;
    expect(user).to.have.property('_id');
    expect(user).to.have.property('nom');
    expect(user).to.have.property('email');
    expect(user).to.have.property('role');
    expect(user).to.not.have.property('password');
  });
  
  test("User data is correct", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('authtest');
    expect(user.email).to.equal('authtest@example.com');
    expect(user.role).to.equal('APPRENTI');
  });
  
  test("Response contains auth record info", function() {
    expect(res.getBody()).to.have.property('auth');
    const auth = res.getBody().auth;
    expect(auth).to.have.property('userId');
    expect(auth).to.have.property('isActive');
    expect(auth.isActive).to.equal(true);
    expect(auth).to.not.have.property('passwordHash');
    expect(auth).to.not.have.property('refreshToken');
  });
  
  test("User and auth records are linked", function() {
    const user = res.getBody().user;
    const auth = res.getBody().auth;
    expect(auth.userId).to.equal(user._id);
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(3000);
  });
}

script:post-response {
  if (res.getStatus() === 201) {
    const user = res.getBody().user;
    bru.setEnvVar("authTestUserId", user._id);
    bru.setEnvVar("authTestEmail", user.email);
  }
}
</file>

<file path="API_test/bruno.json">
{
  "version": "1",
  "name": "SIGL",
  "type": "collection",
  "ignore": [
    "node_modules",
    ".git"
  ]
}
</file>

<file path="API_test/collection.bru">
auth {
  mode: bearer
}

auth:bearer {
  token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTFlY2ZhYWZiMmIzYTk4ODc4NDVhM2UiLCJlbWFpbCI6ImFkbWluQGFkbWluLmZyIiwicm9sZSI6IkFETUlOIiwidHlwZSI6ImFjY2VzcyIsImlhdCI6MTc2MzYyNzA5NSwiZXhwIjoxNzYzNjI3OTk1LCJhdWQiOiJsbXMtdXNlcnMiLCJpc3MiOiJsZWFybmluZy1tYW5hZ2VtZW50LXN5c3RlbSJ9.i3F9ZdyPs0utLLY_Dc1HgBf-G_NLoR3oDMYJ6zEqxdc
}
</file>

<file path="API_test/environments/local.bru">
vars {
  baseUrl: http://localhost:3000
  apiPath: /api
  testUserId:
  testUserEmail: test@example.com
  testUsername: testuser
  testPassword: password123
  adminUserId:
  flowTestUserId:
  validObjectId: 507f1f77bcf86cd799439011
  invalidObjectId: invalid_id
  accessToken:
  refreshToken:
  loggedInUserId:
  userRole:
  authTestUserId:
  authTestEmail: authtest@example.com
}
</file>

<file path="API_test/SETUP.md">
# Bruno Environment Setup

## Quick Setup Instructions

1. **Open Bruno and import this collection**

2. **Create Environment:**
   - Click the dropdown in top-right that says "No Environment"
   - Select "Configure" → "Create Environment"
   - Name it "Local" or "Development"

3. **Add these variables:**
   ```
   baseUrl = http://localhost:3000
   apiPath = /api
   testUserId = (leave empty - will be set automatically)
   testUserEmail = test@example.com
   testUsername = testuser
   testPassword = password123
   adminUserId = (leave empty - will be set automatically)
   flowTestUserId = (leave empty - will be set automatically)
   validObjectId = 507f1f77bcf86cd799439011
   invalidObjectId = invalid_id
   ```

4. **Select the environment** from the dropdown

5. **Start your backend server** on http://localhost:3000

6. **Run tests in this order:**
   - Register User - Valid (creates test user)
   - Other registration tests
   - Get User Profile tests
   - List All Users
   - Update User tests
   - Delete User tests

## Notes
- Tests automatically manage user IDs via environment variables
- Some tests depend on previous tests creating users
- All URLs resolve to: `{{baseUrl}}{{apiPath}}/users/...`
</file>

<file path="API_test/Status.bru">
meta {
  name: Status
  type: http
  seq: 5
}

get {
  url: http://localhost:3000/status
  body: none
  auth: inherit
}

settings {
  encodeUrl: true
  timeout: 0
}
</file>

<file path="API_test/Test/folder.bru">
meta {
  name: Test
  seq: 2
}

auth {
  mode: inherit
}
</file>

<file path="API_test/Test/Test GET.bru">
meta {
  name: Test GET
  type: http
  seq: 3
}

get {
  url: http://localhost:3000/api/test
  body: none
  auth: inherit
}

settings {
  encodeUrl: true
  timeout: 0
}
</file>

<file path="API_test/Test/Test POST.bru">
meta {
  name: Test POST
  type: http
  seq: 1
}

post {
  url: http://localhost:3000/api/test
  body: none
  auth: inherit
}

settings {
  encodeUrl: true
  timeout: 0
}
</file>

<file path="API_test/Upload/folder.bru">
meta {
  name: Upload
  seq: 2
}

auth {
  mode: inherit
}
</file>

<file path="API_test/User/Delete User - Invalid ID.bru">
meta {
  name: Delete User - Invalid ID
  type: http
  seq: 13
}

delete {
  url: {{baseUrl}}{{apiPath}}/users/{{invalidObjectId}}
  body: none
  auth: none
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid ID format", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Format d'ID utilisateur invalide");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Delete User - Valid ID.bru">
meta {
  name: Delete User - Valid ID
  type: http
  seq: 12
}

delete {
  url: {{baseUrl}}{{apiPath}}/users/{{testUserId}}
  body: none
  auth: none
}

script:pre-request {
  // Ensure we have a valid test user ID from registration
  if (!bru.getEnvVar("testUserId")) {
    throw new Error("testUserId not set. Run 'Register User - Valid' test first.");
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Compte utilisateur supprimé avec succès');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}

script:post-response {
  // Clear the testUserId since user is deleted
  if (res.getStatus() === 200) {
    bru.setEnvVar("testUserId", "");
  }
}
</file>

<file path="API_test/User/folder.bru">
meta {
  name: User
  seq: 1
}

auth {
  mode: inherit
}
</file>

<file path="API_test/User/Get User Profile - Invalid ID.bru">
meta {
  name: Get User Profile - Invalid ID
  type: http
  seq: 7
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{invalidObjectId}}
  body: none
  auth: none
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid ID format", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Format d'ID utilisateur invalide");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Get User Profile - Not Found.bru">
meta {
  name: Get User Profile - Not Found
  type: http
  seq: 8
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{validObjectId}}
  body: none
  auth: none
}

tests {
  test("Status code is 404", function() {
    expect(res.getStatus()).to.equal(404);
  });
  
  test("Response has error message for user not found", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Utilisateur non trouvé");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Get User Profile - Valid ID.bru">
meta {
  name: Get User Profile - Valid ID
  type: http
  seq: 6
}

get {
  url: {{baseUrl}}{{apiPath}}/users/{{testUserId}}
  body: none
  auth: inherit
}

script:pre-request {
  // Ensure we have a valid test user ID from registration
  if (!bru.getEnvVar("testUserId")) {
    throw new Error("testUserId not set. Run 'Register User - Valid' test first.");
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('user');
    expect(res.getBody().user).to.have.property('_id');
    expect(res.getBody().user).to.have.property('nom');
    expect(res.getBody().user).to.have.property('email');
    expect(res.getBody().user).to.have.property('role');
    expect(res.getBody().user).to.not.have.property('password');
  });
  
  test("User ID matches requested ID", function() {
    expect(res.getBody().user._id).to.equal(bru.getEnvVar("testUserId"));
  });
  
  test("User data is correct", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('testuser');
    expect(user.email).to.equal('test@example.com');
    expect(user.role).to.equal('APPRENTI');
  });
  
  test("Response has timestamps", function() {
    expect(res.getBody().user).to.have.property('createdAt');
    expect(res.getBody().user).to.have.property('updatedAt');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/List All Users.bru">
meta {
  name: List All Users
  type: http
  seq: 9
}

get {
  url: {{baseUrl}}{{apiPath}}/users
  body: multipartForm
  auth: inherit
}

headers {
  : 
}

body:multipart-form {
  accessToken: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTFkODFkNjE4ZjQwMWY3YTUwYzcxMjEiLCJlbWFpbCI6InRlc3RAZXhhbXBsZS5jb20iLCJyb2xlIjoiQVBQUkVOVEkiLCJ0eXBlIjoiYWNjZXNzIiwiaWF0IjoxNzYzNjI1NzkwLCJleHAiOjE3NjM2MjY2OTAsImF1ZCI6Imxtcy11c2VycyIsImlzcyI6ImxlYXJuaW5nLW1hbmFnZW1lbnQtc3lzdGVtIn0.vGG6q-3M2o1-t1tkL2iMJnZH2xha40znLC6wMOcNEUc
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response contains users array", function() {
    expect(res.getBody()).to.have.property('users');
    expect(res.getBody().users).to.be.an('array');
  });
  
  test("Response contains count", function() {
    expect(res.getBody()).to.have.property('count');
    expect(res.getBody().count).to.be.a('number');
    expect(res.getBody().count).to.equal(res.getBody().users.length);
  });
  
  test("Users array contains at least one user", function() {
    expect(res.getBody().users.length).to.be.at.least(1);
  });
  
  test("Each user has required properties", function() {
    res.getBody().users.forEach(user => {
      expect(user).to.have.property('_id');
      expect(user).to.have.property('nom');
      expect(user).to.have.property('email');
      expect(user).to.have.property('role');
      expect(user).to.not.have.property('password');
    });
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/User/Register User - Admin].bru">
meta {
  name: Register User - Admin]
  type: http
  seq: 19
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "admin",
    "email": "admin@admin.fr",
    "password": "goodlife",
    "role": "ADMIN"
  }
}

script:post-response {
  if (res.getStatus() === 201) {
    bru.setEnvVar("testUserId", res.getBody().user._id);
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur enregistré avec succès');
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('user');
    expect(res.getBody().user).to.have.property('_id');
    expect(res.getBody().user).to.have.property('nom');
    expect(res.getBody().user).to.have.property('email');
    expect(res.getBody().user).to.have.property('role');
    expect(res.getBody().user).to.not.have.property('password');
  });
  
  test("User data is correct", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('testuser');
    expect(user.email).to.equal('test@example.com');
    expect(user.role).to.equal('APPRENTI');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/User/Register User - Duplicate Email.bru">
meta {
  name: Register User - Duplicate Email
  type: http
  seq: 5
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser5",
    "email": "{{testUserEmail}}",
    "password": "password123",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 409", function() {
    expect(res.getStatus()).to.equal(409);
  });
  
  test("Response has error message for duplicate email", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Email déjà enregistré");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Invalid Email.bru">
meta {
  name: Register User - Invalid Email
  type: http
  seq: 3
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser3",
    "email": "invalid-email",
    "password": "password123",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid email", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Format d'email invalide");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Invalid Role.bru">
meta {
  name: Register User - Invalid Role
  type: http
  seq: 15
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser_invalid",
    "email": "invalid_role@example.com",
    "password": "password123",
    "role": "InvalidRole"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid role", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.include("Le rôle doit être l'un des suivants");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Invalid Username.bru">
meta {
  name: Register User - Invalid Username
  type: http
  seq: 16
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "ab",
    "email": "short_username@example.com",
    "password": "password123",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid username", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.include("Le nom d'utilisateur doit contenir entre 3 et 20 caractères");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Missing Fields.bru">
meta {
  name: Register User - Missing Fields
  type: http
  seq: 2
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser2"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Le nom d'utilisateur, l'email et le mot de passe sont obligatoires");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Register User - Valid copy.bru">
meta {
  name: Register User - Valid copy
  type: http
  seq: 18
}

post {
  url: http://pierre.wang:3000/api/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "{{testUsername}}",
    "email": "{{testUserEmail}}",
    "password": "{{testPassword}}",
    "role": "APPRENTI"
  }
}

script:post-response {
  if (res.getStatus() === 201) {
    bru.setEnvVar("testUserId", res.getBody().user._id);
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur enregistré avec succès');
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('user');
    expect(res.getBody().user).to.have.property('_id');
    expect(res.getBody().user).to.have.property('nom');
    expect(res.getBody().user).to.have.property('email');
    expect(res.getBody().user).to.have.property('role');
    expect(res.getBody().user).to.not.have.property('password');
  });
  
  test("User data is correct", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('testuser');
    expect(user.email).to.equal('test@example.com');
    expect(user.role).to.equal('APPRENTI');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/User/Register User - Valid Role.bru">
meta {
  name: Register User - Valid Role
  type: http
  seq: 14
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "admin_user",
    "email": "admin@example.com",
    "password": "adminpass123",
    "role": "ADMIN"
  }
}

script:post-response {
  if (res.getStatus() === 201) {
    bru.setEnvVar("adminUserId", res.getBody().user._id);
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur enregistré avec succès');
  });
  
  test("User has correct role", function() {
    expect(res.getBody().user.role).to.equal('ADMIN');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="API_test/User/Register User - Valid.bru">
meta {
  name: Register User - Valid
  type: http
  seq: 1
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "{{testUsername}}",
    "email": "{{testUserEmail}}",
    "password": "{{testPassword}}",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 201", function() {
    expect(res.getStatus()).to.equal(201);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur enregistré avec succès');
  });
  
  test("Response contains user data", function() {
    expect(res.getBody()).to.have.property('user');
    expect(res.getBody().user).to.have.property('_id');
    expect(res.getBody().user).to.have.property('nom');
    expect(res.getBody().user).to.have.property('email');
    expect(res.getBody().user).to.have.property('role');
    expect(res.getBody().user).to.not.have.property('password');
  });
  
  test("User data is correct", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('testuser');
    expect(user.email).to.equal('test@example.com');
    expect(user.role).to.equal('APPRENTI');
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}

script:post-response {
  if (res.getStatus() === 201) {
    bru.setEnvVar("testUserId", res.getBody().user._id);
  }
}
</file>

<file path="API_test/User/Register User - Weak Password.bru">
meta {
  name: Register User - Weak Password
  type: http
  seq: 4
}

post {
  url: {{baseUrl}}{{apiPath}}/users/register
  body: json
  auth: none
}

body:json {
  {
    "username": "testuser4",
    "email": "test4@example.com",
    "password": "123",
    "role": "APPRENTI"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for weak password", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Le mot de passe doit contenir au moins 6 caractères");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Update User - Invalid ID.bru">
meta {
  name: Update User - Invalid ID
  type: http
  seq: 11
}

put {
  url: {{baseUrl}}{{apiPath}}/users/{{invalidObjectId}}
  body: json
  auth: none
}

body:json {
  {
    "username": "updateduser2",
    "email": "updated2@example.com"
  }
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for invalid ID format", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Format d'ID utilisateur invalide");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Update User - No Fields.bru">
meta {
  name: Update User - No Fields
  type: http
  seq: 17
}

put {
  url: {{baseUrl}}{{apiPath}}/users/{{validObjectId}}
  body: json
  auth: none
}

body:json {
  {}
}

tests {
  test("Status code is 400", function() {
    expect(res.getStatus()).to.equal(400);
  });
  
  test("Response has error message for no fields", function() {
    expect(res.getBody()).to.have.property('error');
    expect(res.getBody().error).to.equal("Aucun champ valide fourni pour la mise à jour");
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(1000);
  });
}
</file>

<file path="API_test/User/Update User - Valid.bru">
meta {
  name: Update User - Valid
  type: http
  seq: 10
}

put {
  url: {{baseUrl}}{{apiPath}}/users/{{testUserId}}
  body: json
  auth: none
}

body:json {
  {
    "username": "updateduser",
    "email": "updated@example.com",
    "role": "TP"
  }
}

script:pre-request {
  // Ensure we have a valid test user ID from registration
  if (!bru.getEnvVar("testUserId")) {
    throw new Error("testUserId not set. Run 'Register User - Valid' test first.");
  }
}

tests {
  test("Status code is 200", function() {
    expect(res.getStatus()).to.equal(200);
  });
  
  test("Response has success message", function() {
    expect(res.getBody()).to.have.property('message');
    expect(res.getBody().message).to.equal('Utilisateur mis à jour avec succès');
  });
  
  test("Response contains updated user data", function() {
    expect(res.getBody()).to.have.property('user');
    expect(res.getBody().user).to.have.property('_id');
    expect(res.getBody().user).to.have.property('nom');
    expect(res.getBody().user).to.have.property('email');
    expect(res.getBody().user).to.have.property('role');
    expect(res.getBody().user).to.not.have.property('password');
  });
  
  test("User data is updated correctly", function() {
    const user = res.getBody().user;
    expect(user.nom).to.equal('updateduser');
    expect(user.email).to.equal('updated@example.com');
    expect(user.role).to.equal('TP');
  });
  
  test("User ID remains the same", function() {
    expect(res.getBody().user._id).to.equal(bru.getEnvVar("testUserId"));
  });
  
  test("Response time is acceptable", function() {
    expect(res.getResponseTime()).to.be.below(2000);
  });
}
</file>

<file path="database/database/candidatures.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["offre","apprenti","etat"],"properties":{"offre":{"bsonType":"objectId"},"apprenti":{"bsonType":"objectId"},"etat":{"enum":["DEPOSEE","ACCEPTEE","REFUSEE","RETIRÉE"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"offre":{"$numberInt":"1"},"apprenti":{"$numberInt":"1"}},"name":"offre_1_apprenti_1","unique":true}],"uuid":"0698f2c00fcf43ce8d11ed22775e09e9","collectionName":"candidatures","type":"collection"}
</file>

<file path="database/database/commentaires.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["auteur","cibleType","cibleId","texte"],"properties":{"auteur":{"bsonType":"objectId"},"cibleType":{"enum":["JournalEntry","Document"]},"cibleId":{"bsonType":"objectId"},"texte":{"bsonType":"string","minLength":{"$numberInt":"1"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"cibleType":{"$numberInt":"1"},"cibleId":{"$numberInt":"1"}},"name":"cibleType_1_cibleId_1"}],"uuid":"8d56546c5da74e75b1980b82abe7e56a","collectionName":"commentaires","type":"collection"}
</file>

<file path="database/database/competences.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["libelle"],"properties":{"libelle":{"bsonType":"string","minLength":{"$numberInt":"2"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"}],"uuid":"20817414ada143aa9f7799f0f0d34b33","collectionName":"competences","type":"collection"}
</file>

<file path="database/database/creneaux.metadata.json">
{"options":{"validator":{"$and":[{"$jsonSchema":{"bsonType":"object","required":["debut","fin"],"properties":{"debut":{"bsonType":"date"},"fin":{"bsonType":"date"}},"additionalProperties":false}},{"$expr":{"$gt":["$fin","$debut"]}}]},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"debut":{"$numberInt":"1"},"fin":{"$numberInt":"1"}},"name":"debut_1_fin_1"}],"uuid":"25e5ab221c9c408783f896d8ca8ac653","collectionName":"creneaux","type":"collection"}
</file>

<file path="database/database/documents.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["type","url","apprenti"],"properties":{"type":{"enum":["RAPPORT","COMPTE_RENDU","AUTRE"]},"url":{"bsonType":"string","minLength":{"$numberInt":"5"}},"apprenti":{"bsonType":"objectId"}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"apprenti":{"$numberInt":"1"},"_id":{"$numberInt":"-1"}},"name":"apprenti_1__id_-1"}],"uuid":"0fcd7f1ed848438298ee74e6f39f4d67","collectionName":"documents","type":"collection"}
</file>

<file path="database/database/entreprises.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["nom"],"properties":{"nom":{"bsonType":"string","minLength":{"$numberInt":"2"}},"adresse":{"bsonType":["string","null"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"nom":{"$numberInt":"1"}},"name":"nom_1","unique":true}],"uuid":"11d928b212c04ea58c514a60503278d8","collectionName":"entreprises","type":"collection"}
</file>

<file path="database/database/entretiens.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["objet","creneau","participants"],"properties":{"objet":{"bsonType":"string","minLength":{"$numberInt":"2"}},"creneau":{"bsonType":"objectId"},"participants":{"bsonType":"array","minItems":{"$numberInt":"2"},"items":{"bsonType":"objectId"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"creneau":{"$numberInt":"1"}},"name":"creneau_1"}],"uuid":"ccb602901f4849ec878cfeac2fa512ce","collectionName":"entretiens","type":"collection"}
</file>

<file path="database/database/evaluations.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["apprenti","evaluateur","note","type"],"properties":{"apprenti":{"bsonType":"objectId"},"evaluateur":{"bsonType":"objectId"},"note":{"bsonType":["double","int","decimal"],"minimum":{"$numberInt":"0"},"maximum":{"$numberInt":"20"}},"appreciation":{"bsonType":["string","null"]},"type":{"enum":["RAPPORT","SOUTENANCE","CONTINU"]},"soutenance":{"bsonType":["objectId","null"]},"rapport":{"bsonType":["objectId","null"]},"competence":{"bsonType":["objectId","null"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"apprenti":{"$numberInt":"1"},"type":{"$numberInt":"1"}},"name":"apprenti_1_type_1"}],"uuid":"e76aaf0c4a5e4e39873aa523e80837cb","collectionName":"evaluations","type":"collection"}
</file>

<file path="database/database/journal_entries.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["apprenti","date","contenu"],"properties":{"apprenti":{"bsonType":"objectId"},"date":{"bsonType":"date"},"contenu":{"bsonType":"string","minLength":{"$numberInt":"1"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"apprenti":{"$numberInt":"1"},"date":{"$numberInt":"-1"}},"name":"apprenti_1_date_-1"}],"uuid":"adc53a365fa748b58843dc087ab4075e","collectionName":"journal_entries","type":"collection"}
</file>

<file path="database/database/jurys.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["professeurs"],"properties":{"professeurs":{"bsonType":"array","minItems":{"$numberInt":"3"},"maxItems":{"$numberInt":"5"},"items":{"bsonType":"objectId"}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"}],"uuid":"5768759c122e44c78b1c1ee9c9bb5ea1","collectionName":"jurys","type":"collection"}
</file>

<file path="database/database/notifications.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["destinataire","message","lu"],"properties":{"destinataire":{"bsonType":"objectId"},"message":{"bsonType":"string","minLength":{"$numberInt":"1"}},"lu":{"bsonType":"bool"},"objet":{"bsonType":["object","null"],"properties":{"type":{"bsonType":"string"},"id":{"bsonType":"objectId"}}}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"destinataire":{"$numberInt":"1"},"lu":{"$numberInt":"1"}},"name":"destinataire_1_lu_1"}],"uuid":"27dcff414c9e4ceb87ede3e4ac0ab3e8","collectionName":"notifications","type":"collection"}
</file>

<file path="database/database/offres.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["entreprise","intitule","statut"],"properties":{"entreprise":{"bsonType":"objectId"},"intitule":{"bsonType":"string","minLength":{"$numberInt":"2"}},"statut":{"enum":["OUVERTE","CLOTUREE","EN_RECRUTEMENT"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"entreprise":{"$numberInt":"1"},"statut":{"$numberInt":"1"},"_id":{"$numberInt":"-1"}},"name":"entreprise_1_statut_1__id_-1"}],"uuid":"f1daf243c58e417f9a1ce9e53fb9923e","collectionName":"offres","type":"collection"}
</file>

<file path="database/database/prelude.json">
{"ServerVersion":"8.2.1","ToolVersion":"100.13.0"}
</file>

<file path="database/database/promotions.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["annee"],"properties":{"annee":{"bsonType":"string","pattern":"^[0-9]{4}-[0-9]{4}$"}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"annee":{"$numberInt":"1"}},"name":"annee_1"}],"uuid":"36f3b08cea1140a2aa7a85b3f720a611","collectionName":"promotions","type":"collection"}
</file>

<file path="database/database/rapports.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["apprenti","titre","fichier"],"properties":{"apprenti":{"bsonType":"objectId"},"titre":{"bsonType":"string","minLength":{"$numberInt":"2"}},"fichier":{"bsonType":"string","minLength":{"$numberInt":"5"}},"soutenance":{"bsonType":["objectId","null"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"}],"uuid":"4677402cd1064c1aaede253a44c50b85","collectionName":"rapports","type":"collection"}
</file>

<file path="database/database/soutenances.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["apprenti","jury","dateHeure","etat"],"properties":{"apprenti":{"bsonType":"objectId"},"jury":{"bsonType":"objectId"},"salle":{"bsonType":["string","null"]},"dateHeure":{"bsonType":"date"},"etat":{"enum":["PLANIFIEE","VALIDEE","TERMINEE","ANNULEE"]}},"additionalProperties":false}},"validationLevel":"moderate"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"apprenti":{"$numberInt":"1"}},"name":"apprenti_1","unique":true},{"v":{"$numberInt":"2"},"key":{"dateHeure":{"$numberInt":"1"}},"name":"dateHeure_1"}],"uuid":"8496d90313a64eb0bfe0fa7dc2289cc4","collectionName":"soutenances","type":"collection"}
</file>

<file path="database/database/utilisateurs.metadata.json">
{"options":{"validator":{"$jsonSchema":{"bsonType":"object","required":["nom","email","role"],"properties":{"nom":{"bsonType":"string","minLength":{"$numberInt":"2"}},"email":{"bsonType":"string","pattern":"^.+@.+\\..+$"},"role":{"enum":["APPRENTI","MA","TP","CA","RC","PROF","ADMIN"]},"numero":{"bsonType":["string","null"]},"promotion":{"bsonType":["objectId","null"]},"entreprise":{"bsonType":["objectId","null"]},"grade":{"bsonType":["string","null"]},"departement":{"bsonType":["string","null"]},"service":{"bsonType":["string","null"]},"specialite":{"bsonType":["string","null"]},"fonction":{"bsonType":["string","null"]}},"additionalProperties":false}},"validationLevel":"moderate","validationAction":"error"},"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"email":{"$numberInt":"1"}},"name":"email_1","unique":true},{"v":{"$numberInt":"2"},"key":{"role":{"$numberInt":"1"}},"name":"role_1"}],"uuid":"2279db17d9b64097aedeb1a410814a6b","collectionName":"utilisateurs","type":"collection"}
</file>

<file path="sigl_backend/.env">
# JWT Configuration
JWT_SECRET=your-very-strong-secret-key-min-32-chars-for-access-tokens-2024
JWT_REFRESH_SECRET=another-strong-secret-for-refresh-tokens-must-be-different-2024

# Bcrypt Configuration
BCRYPT_SALT_ROUNDS=10

# Application Configuration
NODE_ENV=development
PORT=3000

# Database Configuration
MONGODB_URI=mongodb://localhost:27017/database

# Security Configuration
MAX_LOGIN_ATTEMPTS=5
ACCOUNT_LOCK_TIME=900000

FRONTEND_URL=http://localhost:5173
</file>

<file path="sigl_backend/.gitignore">
/.idea/
/node_modules/
/repomix-output.xml
</file>

<file path="sigl_backend/app/auth/auth.controller.js">
const authService = require('./auth.service');
const authRepository = require('./auth.repository');
const crypto = require('crypto');

/**
 * Authentication Controller
 * Handles HTTP requests for authentication endpoints including login, logout,
 * token refresh, and password management operations
 */
class AuthController {
    /**
     * User login endpoint
     * Validates credentials and returns access and refresh tokens
     * 
     * @param {Object} req - Express request object
     * @param {Object} res - Express response object
     * @returns {Promise<void>}
     */
    async login(req, res) {
        try {
            const { email, password } = req.body;

            // Input validation
            if (!email || !password) {
                return res.status(400).json({
                    success: false,
                    message: 'Email and password are required',
                    error: 'MISSING_CREDENTIALS'
                });
            }

            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                return res.status(400).json({
                    success: false,
                    message: 'Invalid email format',
                    error: 'INVALID_EMAIL_FORMAT'
                });
            }

            // Find user by email
            const authRecord = await authRepository.findAuthByEmail(email);
            if (!authRecord || !authRecord.user) {
                // Log failed login attempt for security monitoring
                console.log(`Failed login attempt for email: ${email} - User not found - ${new Date().toISOString()}`);
                
                return res.status(401).json({
                    success: false,
                    message: 'Invalid email or password',
                    error: 'INVALID_CREDENTIALS'
                });
            }

            // Check if account is locked
            if (authRecord.isLocked) {
                console.log(`Login attempt on locked account: ${email} - ${new Date().toISOString()}`);
                
                return res.status(403).json({
                    success: false,
                    message: 'Account is temporarily locked due to multiple failed login attempts. Please try again later.',
                    error: 'ACCOUNT_LOCKED'
                });
            }

            // Verify password
            const isPasswordValid = await authService.comparePassword(password, authRecord.passwordHash);
            
            if (!isPasswordValid) {
                // Increment failed login attempts
                await authRepository.incrementFailedAttempts(authRecord.userId);
                
                // Log failed login attempt
                console.log(`Failed login attempt for email: ${email} - Invalid password - ${new Date().toISOString()}`);
                
                return res.status(401).json({
                    success: false,
                    message: 'Invalid email or password',
                    error: 'INVALID_CREDENTIALS'
                });
            }

            // Generate JWT tokens with English role codes
            // Role system now uses standardized English codes only
            const tokens = authService.generateTokenPair(
                authRecord.userId.toString(),
                authRecord.user.email,
                authRecord.user.role  // English role code (APPRENTI, MA, TP, CA, RC, PROF, ADMIN)
            );

            // Store refresh token and reset failed attempts
            await authService.storeRefreshToken(authRecord.userId, tokens.refreshToken);
            await authRepository.resetFailedAttempts(authRecord.userId);

            // Log successful login
            console.log(`Successful login: ${email} (${authRecord.user.role}) - ${new Date().toISOString()}`);

            // Return success response with tokens and user info
            // User role returned as English code for consistency across system
            res.status(200).json({
                success: true,
                message: 'Login successful',
                data: {
                    user: {
                        id: authRecord.user._id,
                        nom: authRecord.user.nom,
                        email: authRecord.user.email,
                        role: authRecord.user.role  // English role code
                    },
                    tokens: {
                        accessToken: tokens.accessToken,
                        refreshToken: tokens.refreshToken,
                        tokenType: tokens.tokenType,
                        expiresIn: tokens.expiresIn
                    }
                }
            });

        } catch (error) {
            console.error('Login error:', error.message);
            res.status(500).json({
                success: false,
                message: 'Internal server error during login',
                error: 'LOGIN_ERROR'
            });
        }
    }

    /**
     * User logout endpoint
     * Revokes the user's refresh token
     * 
     * @param {Object} req - Express request object (requires authentication)
     * @param {Object} res - Express response object
     * @returns {Promise<void>}
     */
    async logout(req, res) {
        try {
            const { userId } = req.user;

            // Revoke refresh token
            await authService.revokeRefreshToken(userId);

            // Log logout event
            console.log(`User logout: ${req.user.email} - ${new Date().toISOString()}`);

            res.status(200).json({
                success: true,
                message: 'Logout successful'
            });

        } catch (error) {
            console.error('Logout error:', error.message);
            res.status(500).json({
                success: false,
                message: 'Internal server error during logout',
                error: 'LOGOUT_ERROR'
            });
        }
    }

    /**
     * Refresh access token endpoint
     * Generates a new access token from a valid refresh token
     * 
     * @param {Object} req - Express request object
     * @param {Object} res - Express response object
     * @returns {Promise<void>}
     */
    async refreshAccessToken(req, res) {
        try {
            const authHeader = req.headers.authorization;
            
            if (!authHeader) {
                return res.status(401).json({
                    success: false,
                    message: 'Refresh token is required',
                    error: 'MISSING_REFRESH_TOKEN'
                });
            }

            // Extract refresh token
            let refreshToken;
            try {
                refreshToken = authService.extractBearerToken(authHeader);
            } catch (error) {
                return res.status(401).json({
                    success: false,
                    message: 'Invalid authorization header format',
                    error: 'INVALID_HEADER_FORMAT'
                });
            }

            // Verify refresh token
            let decoded;
            try {
                decoded = authService.verifyToken(refreshToken, 'refresh');
            } catch (error) {
                return res.status(401).json({
                    success: false,
                    message: 'Invalid or expired refresh token',
                    error: 'INVALID_REFRESH_TOKEN'
                });
            }

            // Find auth record by refresh token to ensure it's still valid in database
            const authRecord = await authRepository.findAuthByRefreshToken(refreshToken);
            if (!authRecord || !authRecord.userId) {
                return res.status(401).json({
                    success: false,
                    message: 'Refresh token not found or revoked',
                    error: 'REFRESH_TOKEN_REVOKED'
                });
            }

            // Generate new access token
            const newAccessToken = authService.generateAccessToken(
                authRecord.userId._id.toString(),
                authRecord.userId.email,
                authRecord.userId.role
            );

            // Optionally rotate refresh token for enhanced security
            const shouldRotateRefreshToken = process.env.ROTATE_REFRESH_TOKENS === 'true';
            let newRefreshToken = refreshToken;
            
            if (shouldRotateRefreshToken) {
                newRefreshToken = authService.generateRefreshToken(authRecord.userId._id.toString());
                await authService.storeRefreshToken(authRecord.userId._id, newRefreshToken);
            }

            // Log token refresh
            console.log(`Token refreshed: ${authRecord.userId.email} - ${new Date().toISOString()}`);

            res.status(200).json({
                success: true,
                message: 'Token refreshed successfully',
                data: {
                    accessToken: newAccessToken,
                    refreshToken: newRefreshToken,
                    tokenType: 'Bearer',
                    expiresIn: '15m'
                }
            });

        } catch (error) {
            console.error('Token refresh error:', error.message);
            res.status(500).json({
                success: false,
                message: 'Internal server error during token refresh',
                error: 'TOKEN_REFRESH_ERROR'
            });
        }
    }

    /**
     * Change password endpoint
     * Allows authenticated users to change their password
     * 
     * @param {Object} req - Express request object (requires authentication)
     * @param {Object} res - Express response object
     * @returns {Promise<void>}
     */
    async changePassword(req, res) {
        try {
            const { userId } = req.user;
            const { currentPassword, newPassword } = req.body;

            // Input validation
            if (!currentPassword || !newPassword) {
                return res.status(400).json({
                    success: false,
                    message: 'Current password and new password are required',
                    error: 'MISSING_PASSWORDS'
                });
            }

            // Validate new password strength
            if (newPassword.length < 8) {
                return res.status(400).json({
                    success: false,
                    message: 'New password must be at least 8 characters long',
                    error: 'WEAK_PASSWORD'
                });
            }

            // Additional password complexity validation
            const hasUpperCase = /[A-Z]/.test(newPassword);
            const hasLowerCase = /[a-z]/.test(newPassword);
            const hasNumbers = /\d/.test(newPassword);
            const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(newPassword);

            if (!hasUpperCase || !hasLowerCase || !hasNumbers || !hasSpecialChar) {
                return res.status(400).json({
                    success: false,
                    message: 'New password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
                    error: 'WEAK_PASSWORD_COMPLEXITY'
                });
            }

            // Find current auth record
            const authRecord = await authRepository.findAuthByUserId(userId);
            if (!authRecord) {
                return res.status(404).json({
                    success: false,
                    message: 'User authentication record not found',
                    error: 'AUTH_RECORD_NOT_FOUND'
                });
            }

            // Verify current password
            const isCurrentPasswordValid = await authService.comparePassword(currentPassword, authRecord.passwordHash);
            if (!isCurrentPasswordValid) {
                // Log failed password change attempt
                console.log(`Failed password change attempt: ${req.user.email} - Invalid current password - ${new Date().toISOString()}`);
                
                return res.status(401).json({
                    success: false,
                    message: 'Current password is incorrect',
                    error: 'INVALID_CURRENT_PASSWORD'
                });
            }

            // Check if new password is different from current
            const isSamePassword = await authService.comparePassword(newPassword, authRecord.passwordHash);
            if (isSamePassword) {
                return res.status(400).json({
                    success: false,
                    message: 'New password must be different from current password',
                    error: 'SAME_PASSWORD'
                });
            }

            // Hash new password
            const newHashedPassword = await authService.hashPassword(newPassword);

            // Update password and revoke all refresh tokens for security
            await authRepository.updatePassword(userId, newHashedPassword);

            // Log successful password change
            console.log(`Password changed successfully: ${req.user.email} - ${new Date().toISOString()}`);

            res.status(200).json({
                success: true,
                message: 'Password changed successfully. Please login again with your new password.'
            });

        } catch (error) {
            console.error('Change password error:', error.message);
            res.status(500).json({
                success: false,
                message: 'Internal server error during password change',
                error: 'PASSWORD_CHANGE_ERROR'
            });
        }
    }

    /**
     * Request password reset endpoint
     * Initiates password reset flow by generating a reset token
     * 
     * @param {Object} req - Express request object
     * @param {Object} res - Express response object
     * @returns {Promise<void>}
     */
    async requestPasswordReset(req, res) {
        try {
            const { email } = req.body;

            // Input validation
            if (!email) {
                return res.status(400).json({
                    success: false,
                    message: 'Email is required',
                    error: 'MISSING_EMAIL'
                });
            }

            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                return res.status(400).json({
                    success: false,
                    message: 'Invalid email format',
                    error: 'INVALID_EMAIL_FORMAT'
                });
            }

            // Find user by email (don't reveal if email exists for security)
            const authRecord = await authRepository.findAuthByEmail(email);
            
            if (authRecord && authRecord.user) {
                // Generate secure reset token
                const resetToken = crypto.randomBytes(32).toString('hex');
                const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 hour from now

                // Store reset token (you would typically store this in a separate collection or add fields to auth model)
                // For now, we'll use a simple in-memory store or extend the auth model
                // This is a simplified implementation - in production, you'd want to store this properly
                
                // Log password reset request
                console.log(`Password reset requested: ${email} - ${new Date().toISOString()}`);
                
                // In a real implementation, you would:
                // 1. Store the reset token and expiry in the database
                // 2. Send an email with the reset link
                // For this implementation, we'll just log the token (DO NOT do this in production)
                console.log(`Reset token for ${email}: ${resetToken} (expires: ${resetTokenExpiry})`);
            }

            // Always return success to prevent email enumeration attacks
            res.status(200).json({
                success: true,
                message: 'If the email address exists in our system, you will receive a password reset link shortly.'
            });

        } catch (error) {
            console.error('Request password reset error:', error.message);
            res.status(500).json({
                success: false,
                message: 'Internal server error during password reset request',
                error: 'PASSWORD_RESET_REQUEST_ERROR'
            });
        }
    }

    /**
     * Reset password endpoint
     * Completes password reset with token validation
     * 
     * @param {Object} req - Express request object
     * @param {Object} res - Express response object
     * @returns {Promise<void>}
     */
    async resetPassword(req, res) {
        try {
            const { token, newPassword } = req.body;

            // Input validation
            if (!token || !newPassword) {
                return res.status(400).json({
                    success: false,
                    message: 'Reset token and new password are required',
                    error: 'MISSING_RESET_DATA'
                });
            }

            // Validate new password strength
            if (newPassword.length < 8) {
                return res.status(400).json({
                    success: false,
                    message: 'New password must be at least 8 characters long',
                    error: 'WEAK_PASSWORD'
                });
            }

            // Additional password complexity validation
            const hasUpperCase = /[A-Z]/.test(newPassword);
            const hasLowerCase = /[a-z]/.test(newPassword);
            const hasNumbers = /\d/.test(newPassword);
            const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(newPassword);

            if (!hasUpperCase || !hasLowerCase || !hasNumbers || !hasSpecialChar) {
                return res.status(400).json({
                    success: false,
                    message: 'New password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
                    error: 'WEAK_PASSWORD_COMPLEXITY'
                });
            }

            // In a real implementation, you would:
            // 1. Find the reset token in the database
            // 2. Check if it's expired
            // 3. Find the associated user
            // 4. Update their password
            // 5. Invalidate the reset token
            
            // For this simplified implementation, we'll return an error since we don't have
            // the reset token storage implemented
            return res.status(400).json({
                success: false,
                message: 'Invalid or expired reset token',
                error: 'INVALID_RESET_TOKEN'
            });

            // This is what the implementation would look like:
            /*
            // Find and validate reset token
            const resetRecord = await ResetToken.findOne({ 
                token, 
                expiresAt: { $gt: new Date() } 
            });
            
            if (!resetRecord) {
                return res.status(400).json({
                    success: false,
                    message: 'Invalid or expired reset token',
                    error: 'INVALID_RESET_TOKEN'
                });
            }

            // Hash new password
            const newHashedPassword = await authService.hashPassword(newPassword);

            // Update password and revoke all refresh tokens
            await authRepository.updatePassword(resetRecord.userId, newHashedPassword);

            // Delete the used reset token
            await ResetToken.deleteOne({ _id: resetRecord._id });

            // Log successful password reset
            console.log(`Password reset completed: ${resetRecord.email} - ${new Date().toISOString()}`);

            res.status(200).json({
                success: true,
                message: 'Password reset successful. Please login with your new password.'
            });
            */

        } catch (error) {
            console.error('Reset password error:', error.message);
            res.status(500).json({
                success: false,
                message: 'Internal server error during password reset',
                error: 'PASSWORD_RESET_ERROR'
            });
        }
    }
}

// Export singleton instance
module.exports = new AuthController();
</file>

<file path="sigl_backend/app/auth/auth.model.js">
const mongoose = require('mongoose');

/**
 * Authentication Schema
 * Stores authentication credentials separately from user profiles
 * Includes security features like account locking and failed attempt tracking
 */
const authSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Utilisateur',
        required: true,
        unique: true,
        index: true
    },
    passwordHash: {
        type: String,
        required: true,
        minlength: 60 // bcrypt hash length
    },
    refreshToken: {
        type: String,
        default: null,
        index: true
    },
    isActive: {
        type: Boolean,
        default: true,
        required: true
    },
    lastLogin: {
        type: Date,
        default: null
    },
    failedLoginAttempts: {
        type: Number,
        default: 0,
        min: 0
    },
    accountLockedUntil: {
        type: Date,
        default: null
    }
}, {
    timestamps: true,
    collection: 'auth_credentials'
});

// Compound index for performance optimization
authSchema.index({ userId: 1, isActive: 1 });
authSchema.index({ refreshToken: 1 }, { sparse: true });

/**
 * Virtual property to check if account is currently locked
 */
authSchema.virtual('isLocked').get(function() {
    return !!(this.accountLockedUntil && this.accountLockedUntil > Date.now());
});

/**
 * Method to check if account should be locked based on failed attempts
 * @returns {boolean} True if account should be locked
 */
authSchema.methods.shouldLockAccount = function() {
    const maxAttempts = parseInt(process.env.MAX_LOGIN_ATTEMPTS) || 5;
    return this.failedLoginAttempts >= maxAttempts;
};

/**
 * Method to lock the account for a specified duration
 */
authSchema.methods.lockAccount = function() {
    const lockTime = parseInt(process.env.ACCOUNT_LOCK_TIME) || 900000; // 15 minutes default
    this.accountLockedUntil = Date.now() + lockTime;
    this.failedLoginAttempts = 0; // Reset attempts after locking
};

/**
 * Method to increment failed login attempts
 */
authSchema.methods.incrementFailedAttempts = function() {
    // If account was previously locked and lock time has expired, reset attempts
    if (this.accountLockedUntil && this.accountLockedUntil < Date.now()) {
        this.failedLoginAttempts = 1;
        this.accountLockedUntil = null;
    } else {
        this.failedLoginAttempts += 1;
    }
    
    // Lock account if max attempts reached
    if (this.shouldLockAccount()) {
        this.lockAccount();
    }
};

/**
 * Method to reset failed login attempts after successful login
 */
authSchema.methods.resetFailedAttempts = function() {
    this.failedLoginAttempts = 0;
    this.accountLockedUntil = null;
    this.lastLogin = new Date();
};

/**
 * Method to safely return auth data without sensitive information
 */
authSchema.methods.toSafeObject = function() {
    const authObj = this.toObject();
    delete authObj.passwordHash;
    delete authObj.refreshToken;
    return authObj;
};

/**
 * Pre-save middleware to ensure security constraints
 */
authSchema.pre('save', function(next) {
    // Ensure passwordHash is never empty
    if (!this.passwordHash || this.passwordHash.length < 60) {
        return next(new Error('Invalid password hash format'));
    }
    
    // Validate userId is a valid ObjectId
    if (!mongoose.Types.ObjectId.isValid(this.userId)) {
        return next(new Error('Invalid userId format'));
    }
    
    next();
});

/**
 * Static method to find auth record by user ID with user details
 * @param {string} userId - The user ID to search for
 * @returns {Promise} Auth record with populated user data
 */
authSchema.statics.findByUserIdWithUser = function(userId) {
    return this.findOne({ userId, isActive: true })
        .populate('userId', 'nom email role')
        .exec();
};

/**
 * Static method to find auth record by email (requires join with user collection)
 * @param {string} email - The email to search for
 * @returns {Promise} Auth record with user data
 */
authSchema.statics.findByEmail = function(email) {
    return this.aggregate([
        {
            $lookup: {
                from: 'utilisateurs',
                localField: 'userId',
                foreignField: '_id',
                as: 'user'
            }
        },
        {
            $unwind: '$user'
        },
        {
            $match: {
                'user.email': email.toLowerCase(),
                isActive: true
            }
        }
    ]);
};

const Auth = mongoose.model('Auth', authSchema);

module.exports = Auth;
</file>

<file path="sigl_backend/app/auth/auth.repository.js">
const mongoose = require('mongoose');
const Auth = require('./auth.model');
const Utilisateur = require('../common/models/user.model');

/**
 * Authentication Repository
 * Handles all database operations for authentication credentials
 */
class AuthRepository {
    /**
     * Create a new authentication record for a user
     * @param {string} userId - User's unique identifier
     * @param {string} hashedPassword - Bcrypt hashed password
     * @returns {Promise<Object>} Created auth record (safe object without sensitive data)
     * @throws {Error} If creation fails
     */
    async createAuthRecord(userId, hashedPassword) {
        try {
            // Validate inputs
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Valid userId is required');
            }

            if (!hashedPassword || typeof hashedPassword !== 'string' || hashedPassword.length < 60) {
                throw new Error('Valid hashed password is required');
            }

            // Check if user exists
            const userExists = await Utilisateur.findById(userId);
            if (!userExists) {
                throw new Error('User not found');
            }

            // Check if auth record already exists
            const existingAuth = await Auth.findOne({ userId });
            if (existingAuth) {
                throw new Error('Authentication record already exists for this user');
            }

            const authRecord = new Auth({
                userId,
                passwordHash: hashedPassword,
                isActive: true,
                failedLoginAttempts: 0
            });

            const savedAuth = await authRecord.save();
            return savedAuth.toSafeObject();
        } catch (error) {
            console.error('Create auth record failed:', error.message);
            throw new Error(`Failed to create authentication record: ${error.message}`);
        }
    }

    /**
     * Find authentication record by user ID
     * @param {string} userId - User's unique identifier
     * @returns {Promise<Object|null>} Auth record or null if not found
     * @throws {Error} If query fails
     */
    async findAuthByUserId(userId) {
        try {
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Valid userId is required');
            }

            const authRecord = await Auth.findOne({ 
                userId, 
                isActive: true 
            }).populate('userId', 'nom email role');

            return authRecord;
        } catch (error) {
            console.error('Find auth by userId failed:', error.message);
            throw new Error('Failed to find authentication record by userId');
        }
    }

    /**
     * Find authentication record by email (requires join with user collection)
     * @param {string} email - User's email address
     * @returns {Promise<Object|null>} Auth record with user data or null if not found
     * @throws {Error} If query fails
     */
    async findAuthByEmail(email) {
        try {
            if (!email || typeof email !== 'string') {
                throw new Error('Valid email is required');
            }

            const authRecords = await Auth.findByEmail(email.toLowerCase());
            
            if (authRecords.length === 0) {
                return null;
            }

            // Return the first matching record (should be unique due to email uniqueness)
            const authRecord = authRecords[0];
            
            // Transform the aggregation result to match expected format
            return {
                _id: authRecord._id,
                userId: authRecord.userId,
                passwordHash: authRecord.passwordHash,
                refreshToken: authRecord.refreshToken,
                isActive: authRecord.isActive,
                lastLogin: authRecord.lastLogin,
                failedLoginAttempts: authRecord.failedLoginAttempts,
                accountLockedUntil: authRecord.accountLockedUntil,
                createdAt: authRecord.createdAt,
                updatedAt: authRecord.updatedAt,
                user: authRecord.user,
                // Add virtual properties
                isLocked: authRecord.accountLockedUntil && authRecord.accountLockedUntil > Date.now()
            };
        } catch (error) {
            console.error('Find auth by email failed:', error.message);
            throw new Error('Failed to find authentication record by email');
        }
    }

    /**
     * Update password hash for a user
     * @param {string} userId - User's unique identifier
     * @param {string} newHashedPassword - New bcrypt hashed password
     * @returns {Promise<Object>} Updated auth record (safe object)
     * @throws {Error} If update fails
     */
    async updatePassword(userId, newHashedPassword) {
        try {
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Valid userId is required');
            }

            if (!newHashedPassword || typeof newHashedPassword !== 'string' || newHashedPassword.length < 60) {
                throw new Error('Valid hashed password is required');
            }

            const authRecord = await Auth.findOneAndUpdate(
                { userId, isActive: true },
                { 
                    passwordHash: newHashedPassword,
                    $unset: { 
                        refreshToken: 1, // Clear refresh token on password change
                        accountLockedUntil: 1 // Clear any account lock
                    },
                    failedLoginAttempts: 0 // Reset failed attempts
                },
                { new: true }
            );

            if (!authRecord) {
                throw new Error('Authentication record not found');
            }

            return authRecord.toSafeObject();
        } catch (error) {
            console.error('Update password failed:', error.message);
            throw new Error(`Failed to update password: ${error.message}`);
        }
    }

    /**
     * Update refresh token for a user
     * @param {string} userId - User's unique identifier
     * @param {string} refreshToken - New refresh token
     * @returns {Promise<Object>} Updated auth record (safe object)
     * @throws {Error} If update fails
     */
    async updateRefreshToken(userId, refreshToken) {
        try {
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Valid userId is required');
            }

            const updateData = refreshToken 
                ? { refreshToken }
                : { $unset: { refreshToken: 1 } };

            const authRecord = await Auth.findOneAndUpdate(
                { userId, isActive: true },
                updateData,
                { new: true }
            );

            if (!authRecord) {
                throw new Error('Authentication record not found');
            }

            return authRecord.toSafeObject();
        } catch (error) {
            console.error('Update refresh token failed:', error.message);
            throw new Error('Failed to update refresh token');
        }
    }

    /**
     * Increment failed login attempts for a user
     * @param {string} userId - User's unique identifier
     * @returns {Promise<Object>} Updated auth record with incremented attempts
     * @throws {Error} If update fails
     */
    async incrementFailedAttempts(userId) {
        try {
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Valid userId is required');
            }

            const authRecord = await Auth.findOne({ userId, isActive: true });
            
            if (!authRecord) {
                throw new Error('Authentication record not found');
            }

            // Use the model method to handle the logic
            authRecord.incrementFailedAttempts();
            const updatedRecord = await authRecord.save();

            return updatedRecord.toSafeObject();
        } catch (error) {
            console.error('Increment failed attempts failed:', error.message);
            throw new Error('Failed to increment failed login attempts');
        }
    }

    /**
     * Reset failed login attempts after successful login
     * @param {string} userId - User's unique identifier
     * @returns {Promise<Object>} Updated auth record with reset attempts
     * @throws {Error} If update fails
     */
    async resetFailedAttempts(userId) {
        try {
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Valid userId is required');
            }

            const authRecord = await Auth.findOne({ userId, isActive: true });
            
            if (!authRecord) {
                throw new Error('Authentication record not found');
            }

            // Use the model method to handle the logic
            authRecord.resetFailedAttempts();
            const updatedRecord = await authRecord.save();

            return updatedRecord.toSafeObject();
        } catch (error) {
            console.error('Reset failed attempts failed:', error.message);
            throw new Error('Failed to reset failed login attempts');
        }
    }

    /**
     * Lock user account until specified time
     * @param {string} userId - User's unique identifier
     * @param {Date} lockUntilTime - Time until which account should be locked
     * @returns {Promise<Object>} Updated auth record with lock information
     * @throws {Error} If update fails
     */
    async lockAccount(userId, lockUntilTime) {
        try {
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Valid userId is required');
            }

            if (!lockUntilTime || !(lockUntilTime instanceof Date)) {
                throw new Error('Valid lock until time is required');
            }

            const authRecord = await Auth.findOneAndUpdate(
                { userId, isActive: true },
                { 
                    accountLockedUntil: lockUntilTime,
                    failedLoginAttempts: 0 // Reset attempts when locking
                },
                { new: true }
            );

            if (!authRecord) {
                throw new Error('Authentication record not found');
            }

            return authRecord.toSafeObject();
        } catch (error) {
            console.error('Lock account failed:', error.message);
            throw new Error('Failed to lock user account');
        }
    }

    /**
     * Check if user account is currently locked
     * @param {string} userId - User's unique identifier
     * @returns {Promise<boolean>} True if account is locked, false otherwise
     * @throws {Error} If query fails
     */
    async isAccountLocked(userId) {
        try {
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Valid userId is required');
            }

            const authRecord = await Auth.findOne({ userId, isActive: true });
            
            if (!authRecord) {
                return false; // If no auth record, consider not locked
            }

            return authRecord.isLocked;
        } catch (error) {
            console.error('Check account lock failed:', error.message);
            throw new Error('Failed to check account lock status');
        }
    }

    /**
     * Deactivate authentication record (soft delete)
     * @param {string} userId - User's unique identifier
     * @returns {Promise<Object>} Deactivated auth record
     * @throws {Error} If deactivation fails
     */
    async deactivateAuth(userId) {
        try {
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Valid userId is required');
            }

            const authRecord = await Auth.findOneAndUpdate(
                { userId, isActive: true },
                { 
                    isActive: false,
                    $unset: { refreshToken: 1 } // Clear refresh token on deactivation
                },
                { new: true }
            );

            if (!authRecord) {
                throw new Error('Authentication record not found');
            }

            return authRecord.toSafeObject();
        } catch (error) {
            console.error('Deactivate auth failed:', error.message);
            throw new Error('Failed to deactivate authentication record');
        }
    }

    /**
     * Find authentication record by refresh token
     * @param {string} refreshToken - Refresh token to search for
     * @returns {Promise<Object|null>} Auth record or null if not found
     * @throws {Error} If query fails
     */
    async findAuthByRefreshToken(refreshToken) {
        try {
            if (!refreshToken || typeof refreshToken !== 'string') {
                throw new Error('Valid refresh token is required');
            }

            const authRecord = await Auth.findOne({ 
                refreshToken, 
                isActive: true 
            }).populate('userId', 'nom email role');

            return authRecord;
        } catch (error) {
            console.error('Find auth by refresh token failed:', error.message);
            throw new Error('Failed to find authentication record by refresh token');
        }
    }

    /**
     * Get authentication statistics for monitoring
     * @returns {Promise<Object>} Authentication statistics
     * @throws {Error} If query fails
     */
    async getAuthStats() {
        try {
            const stats = await Auth.aggregate([
                {
                    $group: {
                        _id: null,
                        totalActiveAccounts: {
                            $sum: { $cond: [{ $eq: ['$isActive', true] }, 1, 0] }
                        },
                        totalInactiveAccounts: {
                            $sum: { $cond: [{ $eq: ['$isActive', false] }, 1, 0] }
                        },
                        accountsWithFailedAttempts: {
                            $sum: { $cond: [{ $gt: ['$failedLoginAttempts', 0] }, 1, 0] }
                        },
                        lockedAccounts: {
                            $sum: { 
                                $cond: [
                                    { $gt: ['$accountLockedUntil', new Date()] }, 
                                    1, 
                                    0
                                ] 
                            }
                        },
                        accountsWithRefreshTokens: {
                            $sum: { 
                                $cond: [
                                    { $ne: ['$refreshToken', null] }, 
                                    1, 
                                    0
                                ] 
                            }
                        }
                    }
                }
            ]);

            return stats[0] || {
                totalActiveAccounts: 0,
                totalInactiveAccounts: 0,
                accountsWithFailedAttempts: 0,
                lockedAccounts: 0,
                accountsWithRefreshTokens: 0
            };
        } catch (error) {
            console.error('Get auth stats failed:', error.message);
            throw new Error('Failed to get authentication statistics');
        }
    }
}

// Export singleton instance
module.exports = new AuthRepository();
</file>

<file path="sigl_backend/app/auth/auth.routes.js">
const express = require('express');
const authController = require('./auth.controller');
const { authenticate, authenticateRefreshToken } = require('../middleware/authenticate');

/**
 * Authentication Routes
 * Defines all authentication-related endpoints with appropriate middleware
 */
const router = express.Router();

/**
 * @route   POST /api/auth/login
 * @desc    User login - authenticate with email and password
 * @access  Public
 * @body    { email: string, password: string }
 * @returns { success: boolean, message: string, data: { user: object, tokens: object } }
 * 
 * @example
 * POST /api/auth/login
 * Content-Type: application/json
 * 
 * {
 *   "email": "user@example.com",
 *   "password": "SecurePass123!"
 * }
 * 
 * Response:
 * {
 *   "success": true,
 *   "message": "Login successful",
 *   "data": {
 *     "user": {
 *       "id": "507f1f77bcf86cd799439011",
 *       "nom": "John Doe",
 *       "email": "user@example.com",
 *       "role": "APPRENTI"
 *     },
 *     "tokens": {
 *       "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
 *       "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
 *       "tokenType": "Bearer",
 *       "expiresIn": "15m"
 *     }
 *   }
 * }
 */
router.post('/login', authController.login);

/**
 * @route   POST /api/auth/logout
 * @desc    User logout - revoke refresh token
 * @access  Private (requires valid access token)
 * @headers Authorization: Bearer <access_token>
 * @returns { success: boolean, message: string }
 * 
 * @example
 * POST /api/auth/logout
 * Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 * 
 * Response:
 * {
 *   "success": true,
 *   "message": "Logout successful"
 * }
 */
router.post('/logout', authenticate, authController.logout);

/**
 * @route   POST /api/auth/refresh
 * @desc    Refresh access token using refresh token
 * @access  Public (but requires valid refresh token)
 * @headers Authorization: Bearer <refresh_token>
 * @returns { success: boolean, message: string, data: { accessToken: string, refreshToken: string, tokenType: string, expiresIn: string } }
 * 
 * @example
 * POST /api/auth/refresh
 * Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 * 
 * Response:
 * {
 *   "success": true,
 *   "message": "Token refreshed successfully",
 *   "data": {
 *     "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
 *     "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
 *     "tokenType": "Bearer",
 *     "expiresIn": "15m"
 *   }
 * }
 */
router.post('/refresh', authController.refreshAccessToken);

/**
 * @route   POST /api/auth/change-password
 * @desc    Change user password
 * @access  Private (requires valid access token)
 * @headers Authorization: Bearer <access_token>
 * @body    { currentPassword: string, newPassword: string }
 * @returns { success: boolean, message: string }
 * 
 * @example
 * POST /api/auth/change-password
 * Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 * Content-Type: application/json
 * 
 * {
 *   "currentPassword": "OldPass123!",
 *   "newPassword": "NewSecurePass456!"
 * }
 * 
 * Response:
 * {
 *   "success": true,
 *   "message": "Password changed successfully. Please login again with your new password."
 * }
 */
router.post('/change-password', authenticate, authController.changePassword);

/**
 * @route   POST /api/auth/request-reset
 * @desc    Request password reset - sends reset token via email
 * @access  Public
 * @body    { email: string }
 * @returns { success: boolean, message: string }
 * 
 * @example
 * POST /api/auth/request-reset
 * Content-Type: application/json
 * 
 * {
 *   "email": "user@example.com"
 * }
 * 
 * Response:
 * {
 *   "success": true,
 *   "message": "If the email address exists in our system, you will receive a password reset link shortly."
 * }
 */
router.post('/request-reset', authController.requestPasswordReset);

/**
 * @route   POST /api/auth/reset-password
 * @desc    Reset password using reset token
 * @access  Public
 * @body    { token: string, newPassword: string }
 * @returns { success: boolean, message: string }
 * 
 * @example
 * POST /api/auth/reset-password
 * Content-Type: application/json
 * 
 * {
 *   "token": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
 *   "newPassword": "NewSecurePass789!"
 * }
 * 
 * Response:
 * {
 *   "success": true,
 *   "message": "Password reset successful. Please login with your new password."
 * }
 */
router.post('/reset-password', authController.resetPassword);

/**
 * Rate limiting middleware configuration (to be implemented)
 * 
 * Recommended rate limits:
 * - /login: 5 attempts per 15 minutes per IP
 * - /request-reset: 3 attempts per hour per IP
 * - /reset-password: 5 attempts per hour per IP
 * - /change-password: 10 attempts per hour per user
 * - /refresh: 100 requests per hour per user
 * - /logout: No specific limit needed
 * 
 * Example implementation with express-rate-limit:
 * 
 * const rateLimit = require('express-rate-limit');
 * 
 * const loginLimiter = rateLimit({
 *   windowMs: 15 * 60 * 1000, // 15 minutes
 *   max: 5, // limit each IP to 5 requests per windowMs
 *   message: {
 *     success: false,
 *     message: 'Too many login attempts, please try again later.',
 *     error: 'RATE_LIMIT_EXCEEDED'
 *   },
 *   standardHeaders: true,
 *   legacyHeaders: false,
 * });
 * 
 * const resetRequestLimiter = rateLimit({
 *   windowMs: 60 * 60 * 1000, // 1 hour
 *   max: 3, // limit each IP to 3 requests per windowMs
 *   message: {
 *     success: false,
 *     message: 'Too many password reset requests, please try again later.',
 *     error: 'RATE_LIMIT_EXCEEDED'
 *   }
 * });
 * 
 * // Apply rate limiting to specific routes:
 * // router.post('/login', loginLimiter, authController.login);
 * // router.post('/request-reset', resetRequestLimiter, authController.requestPasswordReset);
 */

/**
 * Input validation middleware (to be implemented)
 * 
 * Recommended validation using express-validator:
 * 
 * const { body, validationResult } = require('express-validator');
 * 
 * const validateLogin = [
 *   body('email')
 *     .isEmail()
 *     .normalizeEmail()
 *     .withMessage('Valid email is required'),
 *   body('password')
 *     .isLength({ min: 1 })
 *     .withMessage('Password is required'),
 *   (req, res, next) => {
 *     const errors = validationResult(req);
 *     if (!errors.isEmpty()) {
 *       return res.status(400).json({
 *         success: false,
 *         message: 'Validation failed',
 *         errors: errors.array()
 *       });
 *     }
 *     next();
 *   }
 * ];
 * 
 * const validatePasswordChange = [
 *   body('currentPassword')
 *     .isLength({ min: 1 })
 *     .withMessage('Current password is required'),
 *   body('newPassword')
 *     .isLength({ min: 8 })
 *     .withMessage('New password must be at least 8 characters long')
 *     .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*(),.?":{}|<>])/)
 *     .withMessage('New password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'),
 *   (req, res, next) => {
 *     const errors = validationResult(req);
 *     if (!errors.isEmpty()) {
 *       return res.status(400).json({
 *         success: false,
 *         message: 'Validation failed',
 *         errors: errors.array()
 *       });
 *     }
 *     next();
 *   }
 * ];
 * 
 * // Apply validation to routes:
 * // router.post('/login', validateLogin, authController.login);
 * // router.post('/change-password', authenticate, validatePasswordChange, authController.changePassword);
 */

/**
 * Security headers middleware (to be implemented)
 * 
 * Recommended security headers using helmet:
 * 
 * const helmet = require('helmet');
 * 
 * router.use(helmet({
 *   contentSecurityPolicy: {
 *     directives: {
 *       defaultSrc: ["'self'"],
 *       styleSrc: ["'self'", "'unsafe-inline'"],
 *       scriptSrc: ["'self'"],
 *       imgSrc: ["'self'", "data:", "https:"],
 *     },
 *   },
 *   hsts: {
 *     maxAge: 31536000,
 *     includeSubDomains: true,
 *     preload: true
 *   }
 * }));
 */

/**
 * CORS configuration (to be implemented)
 * 
 * const cors = require('cors');
 * 
 * const corsOptions = {
 *   origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
 *   methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
 *   allowedHeaders: ['Content-Type', 'Authorization'],
 *   credentials: true,
 *   maxAge: 86400 // 24 hours
 * };
 * 
 * router.use(cors(corsOptions));
 */

/**
 * Request logging middleware (to be implemented)
 * 
 * const morgan = require('morgan');
 * 
 * // Custom format for authentication routes
 * morgan.token('user-id', (req) => {
 *   return req.user ? req.user.userId : 'anonymous';
 * });
 * 
 * const authLogFormat = ':remote-addr - :user-id [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"';
 * 
 * router.use(morgan(authLogFormat, {
 *   stream: {
 *     write: (message) => {
 *       console.log(`[AUTH] ${message.trim()}`);
 *     }
 *   }
 * }));
 */

module.exports = router;
</file>

<file path="sigl_backend/app/auth/auth.service.js">
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const jwtConfig = require('../config/jwt.config');
const Auth = require('./auth.model');

/**
 * Authentication Service
 * Handles password hashing, JWT operations, and authentication business logic
 */
class AuthService {
    /**
     * Hash a plain text password using bcrypt
     * @param {string} password - Plain text password to hash
     * @returns {Promise<string>} Hashed password
     * @throws {Error} If password is invalid or hashing fails
     */
    async hashPassword(password) {
        try {
            // Validate password input
            if (!password || typeof password !== 'string') {
                throw new Error('Password must be a non-empty string');
            }

            if (password.length < 8) {
                throw new Error('Password must be at least 8 characters long');
            }

            const saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS) || 10;
            const hashedPassword = await bcrypt.hash(password, saltRounds);
            
            return hashedPassword;
        } catch (error) {
            console.error('Password hashing failed:', error.message);
            throw new Error('Failed to hash password');
        }
    }

    /**
     * Compare a plain text password with a hashed password
     * @param {string} plainPassword - Plain text password
     * @param {string} hashedPassword - Hashed password to compare against
     * @returns {Promise<boolean>} True if passwords match, false otherwise
     * @throws {Error} If comparison fails
     */
    async comparePassword(plainPassword, hashedPassword) {
        try {
            // Validate inputs
            if (!plainPassword || typeof plainPassword !== 'string') {
                throw new Error('Plain password must be a non-empty string');
            }

            if (!hashedPassword || typeof hashedPassword !== 'string') {
                throw new Error('Hashed password must be a non-empty string');
            }

            const isMatch = await bcrypt.compare(plainPassword, hashedPassword);
            return isMatch;
        } catch (error) {
            console.error('Password comparison failed:', error.message);
            throw new Error('Failed to compare passwords');
        }
    }

    /**
     * Generate an access token for a user
     * @param {string} userId - User's unique identifier
     * @param {string} email - User's email address
     * @param {string} role - User's role
     * @returns {string} JWT access token
     * @throws {Error} If token generation fails
     */
    generateAccessToken(userId, email, role) {
        try {
            // Validate required parameters
            if (!userId || !email || !role) {
                throw new Error('userId, email, and role are required for access token generation');
            }

            const payload = {
                userId,
                email: email.toLowerCase(),
                role,
                type: 'access'
            };

            const config = jwtConfig.getAccessTokenConfig();
            
            const token = jwt.sign(payload, config.secret, {
                expiresIn: config.expiresIn,
                issuer: config.issuer,
                audience: config.audience,
                algorithm: config.algorithm
            });

            return token;
        } catch (error) {
            console.error('Access token generation failed:', error.message);
            throw new Error('Failed to generate access token');
        }
    }

    /**
     * Generate a refresh token for a user
     * @param {string} userId - User's unique identifier
     * @returns {string} JWT refresh token
     * @throws {Error} If token generation fails
     */
    generateRefreshToken(userId) {
        try {
            // Validate required parameter
            if (!userId) {
                throw new Error('userId is required for refresh token generation');
            }

            const payload = {
                userId,
                type: 'refresh'
            };

            const config = jwtConfig.getRefreshTokenConfig();
            
            const token = jwt.sign(payload, config.secret, {
                expiresIn: config.expiresIn,
                issuer: config.issuer,
                audience: config.audience,
                algorithm: config.algorithm
            });

            return token;
        } catch (error) {
            console.error('Refresh token generation failed:', error.message);
            throw new Error('Failed to generate refresh token');
        }
    }

    /**
     * Verify and decode a JWT token
     * @param {string} token - JWT token to verify
     * @param {string} tokenType - Type of token ('access' or 'refresh')
     * @returns {Object} Decoded token payload
     * @throws {Error} If token is invalid or verification fails
     */
    verifyToken(token, tokenType = 'access') {
        try {
            // Validate inputs
            if (!token || typeof token !== 'string') {
                throw new Error('Token must be a non-empty string');
            }

            if (!['access', 'refresh'].includes(tokenType)) {
                throw new Error('Token type must be either "access" or "refresh"');
            }

            const secret = tokenType === 'access' 
                ? jwtConfig.JWT_SECRET 
                : jwtConfig.JWT_REFRESH_SECRET;

            const verifyOptions = jwtConfig.getVerifyOptions();
            
            const decoded = jwt.verify(token, secret, verifyOptions);

            // Verify token type matches expected type
            if (decoded.type !== tokenType) {
                throw new Error(`Invalid token type. Expected ${tokenType}, got ${decoded.type}`);
            }

            return decoded;
        } catch (error) {
            if (error.name === 'TokenExpiredError') {
                throw new Error('Token has expired');
            } else if (error.name === 'JsonWebTokenError') {
                throw new Error('Invalid token');
            } else if (error.name === 'NotBeforeError') {
                throw new Error('Token not active yet');
            } else {
                console.error('Token verification failed:', error.message);
                throw new Error('Token verification failed');
            }
        }
    }

    /**
     * Store a refresh token for a user
     * @param {string} userId - User's unique identifier
     * @param {string} refreshToken - Refresh token to store
     * @returns {Promise<Object>} Updated auth record
     * @throws {Error} If storage fails
     */
    async storeRefreshToken(userId, refreshToken) {
        try {
            // Validate inputs
            if (!userId) {
                throw new Error('userId is required');
            }

            if (!refreshToken || typeof refreshToken !== 'string') {
                throw new Error('refreshToken must be a non-empty string');
            }

            // Verify the refresh token is valid before storing
            this.verifyToken(refreshToken, 'refresh');

            const authRecord = await Auth.findOneAndUpdate(
                { userId, isActive: true },
                { 
                    refreshToken,
                    $unset: { accountLockedUntil: 1 } // Clear any account lock
                },
                { new: true }
            );

            if (!authRecord) {
                throw new Error('Auth record not found for user');
            }

            return authRecord.toSafeObject();
        } catch (error) {
            console.error('Refresh token storage failed:', error.message);
            throw new Error('Failed to store refresh token');
        }
    }

    /**
     * Revoke a refresh token for a user
     * @param {string} userId - User's unique identifier
     * @returns {Promise<Object>} Updated auth record
     * @throws {Error} If revocation fails
     */
    async revokeRefreshToken(userId) {
        try {
            // Validate input
            if (!userId) {
                throw new Error('userId is required');
            }

            const authRecord = await Auth.findOneAndUpdate(
                { userId, isActive: true },
                { 
                    $unset: { refreshToken: 1 } // Remove refresh token
                },
                { new: true }
            );

            if (!authRecord) {
                throw new Error('Auth record not found for user');
            }

            return authRecord.toSafeObject();
        } catch (error) {
            console.error('Refresh token revocation failed:', error.message);
            throw new Error('Failed to revoke refresh token');
        }
    }

    /**
     * Generate both access and refresh tokens for a user
     * @param {string} userId - User's unique identifier
     * @param {string} email - User's email address
     * @param {string} role - User's role
     * @returns {Object} Object containing both tokens
     * @throws {Error} If token generation fails
     */
    generateTokenPair(userId, email, role) {
        try {
            const accessToken = this.generateAccessToken(userId, email, role);
            const refreshToken = this.generateRefreshToken(userId);

            return {
                accessToken,
                refreshToken,
                tokenType: 'Bearer',
                expiresIn: jwtConfig.ACCESS_TOKEN_EXPIRY
            };
        } catch (error) {
            console.error('Token pair generation failed:', error.message);
            throw new Error('Failed to generate token pair');
        }
    }

    /**
     * Validate token format and extract bearer token
     * @param {string} authHeader - Authorization header value
     * @returns {string} Extracted token
     * @throws {Error} If header format is invalid
     */
    extractBearerToken(authHeader) {
        if (!authHeader) {
            throw new Error('Authorization header is required');
        }

        const parts = authHeader.split(' ');
        
        if (parts.length !== 2 || parts[0] !== 'Bearer') {
            throw new Error('Invalid authorization header format. Expected: Bearer <token>');
        }

        return parts[1];
    }

    /**
     * Check if a token is expired without throwing an error
     * @param {string} token - JWT token to check
     * @param {string} tokenType - Type of token ('access' or 'refresh')
     * @returns {boolean} True if token is expired, false otherwise
     */
    isTokenExpired(token, tokenType = 'access') {
        try {
            this.verifyToken(token, tokenType);
            return false;
        } catch (error) {
            return error.message === 'Token has expired';
        }
    }
}

// Export singleton instance
module.exports = new AuthService();
</file>

<file path="sigl_backend/app/common/models/user.model.js">
const mongoose = require('mongoose');

const utilisateurSchema = new mongoose.Schema({
    nom: {
        type: String,
        required: true,
        trim: true
    },
    email: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
        trim: true,
        match: [/^[^\s@]+@[^\s@]+\.[^\s@]+$/, 'Format d\'email invalide']
    },
    // Email verification status for email verification flow
    isEmailVerified: {
        type: Boolean,
        default: false
    },
    // Password field removed - stored separately in auth_credentials collection
    // Role system uses standardized English codes only (French roles no longer supported)
    role: {
        type: String,
        required: true,
        enum: [
            'APPRENTI',    // Apprentice/Student - Basic user access
            'MA',          // Maître d'Apprentissage (Mentor) - Mentor-level access
            'TP',          // Tuteur Pédagogique (Educational Tutor) - Educational oversight
            'CA',          // Chargé d'Affaires (Account Manager) - Business management
            'RC',          // Responsable de Centre (Center Manager) - Center administration
            'PROF',        // Professor/Instructor - Teaching and content management
            'ADMIN'        // System Administrator - Full system access
        ],
        default: 'APPRENTI'
    },
    // Role-specific fields (optional, based on user role)
    // For APPRENTI (Apprentice/Student)
    idApprenti: {
        type: mongoose.Schema.Types.ObjectId,
        sparse: true
    },
    numero: {
        type: String,
        sparse: true
    },
    // For MA (Maître d'Apprentissage/Mentor)
    fonction: {
        type: String,
        sparse: true
    },
    // For TP (Tuteur Pédagogique/Educational Tutor)
    specialite: {
        type: String,
        sparse: true
    },
    // For CA (Chargé d'Affaires/Account Manager)
    service: {
        type: String,
        sparse: true
    },
    // For RC (Responsable de Centre/Center Manager)
    departement: {
        type: String,
        sparse: true
    },
    // For PROF (Professor/Instructor)
    grade: {
        type: String,
        sparse: true
    },
    // For ADMIN (System Administrator)
    habilitations: {
        type: String,
        sparse: true
    }
}, {
    timestamps: true, // Ajoute automatiquement createdAt et updatedAt
    collection: 'utilisateurs'
});

// Index pour de meilleures performances de requête
// Note: email index is already created by unique: true constraint
utilisateurSchema.index({ role: 1 });

// Method to remove sensitive data before sending response
// Note: Passwords are stored in separate auth_credentials collection for security
utilisateurSchema.methods.toJSON = function() {
    const user = this.toObject();
    // Password field no longer exists in this model (stored separately for security)
    delete user.password;
    return user;
};

const Utilisateur = mongoose.model('Utilisateur', utilisateurSchema);

module.exports = Utilisateur;
</file>

<file path="sigl_backend/app/config/jwt.config.js">
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

/**
 * JWT Configuration
 * Centralized configuration for JWT tokens with proper validation
 */
class JWTConfig {
    constructor() {
        this.validateEnvironmentVariables();
        
        this.JWT_SECRET = process.env.JWT_SECRET;
        this.JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET;
        this.ACCESS_TOKEN_EXPIRY = '15m';
        this.REFRESH_TOKEN_EXPIRY = '7d';
        this.ISSUER = 'learning-management-system';
        this.AUDIENCE = 'lms-users';
        this.ALGORITHM = 'HS256';
    }

    /**
     * Validate that all required environment variables are present
     * @throws {Error} If any required environment variable is missing
     */
    validateEnvironmentVariables() {
        const requiredVars = [
            'JWT_SECRET',
            'JWT_REFRESH_SECRET'
        ];

        const missingVars = requiredVars.filter(varName => !process.env[varName]);

        if (missingVars.length > 0) {
            throw new Error(
                `Missing required environment variables: ${missingVars.join(', ')}. ` +
                'Please check your .env file and ensure all JWT configuration variables are set.'
            );
        }

        // Validate JWT secret strength
        if (process.env.JWT_SECRET.length < 32) {
            throw new Error('JWT_SECRET must be at least 32 characters long for security.');
        }

        if (process.env.JWT_REFRESH_SECRET.length < 32) {
            throw new Error('JWT_REFRESH_SECRET must be at least 32 characters long for security.');
        }

        // Ensure secrets are different
        if (process.env.JWT_SECRET === process.env.JWT_REFRESH_SECRET) {
            throw new Error('JWT_SECRET and JWT_REFRESH_SECRET must be different for security.');
        }
    }

    /**
     * Get access token configuration
     * @returns {Object} Access token configuration
     */
    getAccessTokenConfig() {
        return {
            secret: this.JWT_SECRET,
            expiresIn: this.ACCESS_TOKEN_EXPIRY,
            issuer: this.ISSUER,
            audience: this.AUDIENCE,
            algorithm: this.ALGORITHM
        };
    }

    /**
     * Get refresh token configuration
     * @returns {Object} Refresh token configuration
     */
    getRefreshTokenConfig() {
        return {
            secret: this.JWT_REFRESH_SECRET,
            expiresIn: this.REFRESH_TOKEN_EXPIRY,
            issuer: this.ISSUER,
            audience: this.AUDIENCE,
            algorithm: this.ALGORITHM
        };
    }

    /**
     * Get verification options for JWT tokens
     * @returns {Object} Verification options
     */
    getVerifyOptions() {
        return {
            issuer: this.ISSUER,
            audience: this.AUDIENCE,
            algorithms: [this.ALGORITHM]
        };
    }
}

// Create and export singleton instance
const jwtConfig = new JWTConfig();

module.exports = {
    JWT_SECRET: jwtConfig.JWT_SECRET,
    JWT_REFRESH_SECRET: jwtConfig.JWT_REFRESH_SECRET,
    ACCESS_TOKEN_EXPIRY: jwtConfig.ACCESS_TOKEN_EXPIRY,
    REFRESH_TOKEN_EXPIRY: jwtConfig.REFRESH_TOKEN_EXPIRY,
    ISSUER: jwtConfig.ISSUER,
    AUDIENCE: jwtConfig.AUDIENCE,
    ALGORITHM: jwtConfig.ALGORITHM,
    getAccessTokenConfig: () => jwtConfig.getAccessTokenConfig(),
    getRefreshTokenConfig: () => jwtConfig.getRefreshTokenConfig(),
    getVerifyOptions: () => jwtConfig.getVerifyOptions()
};
</file>

<file path="sigl_backend/app/journal/controller.js">
const journalService = require('./service');

/**
 * POST /api/journaux
 * Crée un journal mensuel pour l'apprenti connecté
 */
const createJournal = async (req, res, next) => {
  try {
    const userId = req.user.userId;

    const journal = await journalService.createJournalForUser(userId, req.body);

    return res.status(201).json({
      success: true,
      message: 'Journal créé avec succès',
      data: journal,
    });
  } catch (error) {
    console.error('createJournal error:', error);
    return res.status(500).json({
      success: false,
      error: 'INTERNAL_ERROR',
      message: 'Erreur lors de la création du journal',
    });
  }
};

/**
 * GET /api/journaux
 * Récupère tous les journaux de l'apprenti connecté
 */
const getMyJournaux = async (req, res, next) => {
  try {
    const userId = req.user.userId;

    const journaux = await journalService.getJournauxForUser(userId);

    return res.status(200).json({
      success: true,
      data: journaux,
    });
  } catch (error) {
    console.error('getMyJournaux error:', error);
    return res.status(500).json({
      success: false,
      error: 'INTERNAL_ERROR',
      message: 'Erreur lors de la récupération des journaux',
    });
  }
};

module.exports = {
  createJournal,
  getMyJournaux,
};
</file>

<file path="sigl_backend/app/journal/journalEntry.model.js">
const mongoose = require('mongoose');

const JournalEntrySchema = new mongoose.Schema(
  {
    // Référence vers l'utilisateur apprenti
    apprenti: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },

    // Date de la note (on utilisera la date de création)
    date: {
      type: Date,
      required: true,
    },

    // Contenu JSON stringifié (structure complète des périodes / missions)
    contenu: {
      type: String,
      required: true,
      minlength: 1,
      maxlength: 10000,
    },
  },
  {
    timestamps: true,
    collection: 'journal_entries', // colle à ta metadata existante
  }
);

module.exports = mongoose.model('JournalEntry', JournalEntrySchema);
</file>

<file path="sigl_backend/app/journal/repository.js">
const JournalEntry = require('./journalEntry.model');

const createJournal = async (data) => {
  const entry = new JournalEntry(data);
  return entry.save();
};

const findByApprenti = async (apprentiId) => {
  return JournalEntry.find({ apprenti: apprentiId }).sort({ date: -1 });
};

const findOneByIdAndApprenti = async (id, apprentiId) => {
  return JournalEntry.findOne({ _id: id, apprenti: apprentiId });
};

module.exports = {
  createJournal,
  findByApprenti,
  findOneByIdAndApprenti,
};
</file>

<file path="sigl_backend/app/journal/routes.js">
const express = require('express');
const { authenticate } = require('../middleware/authenticate');
const { authenticatedUsers } = require('../middleware/authorize');
const journalController = require('./controller');

const router = express.Router();

// Toutes les routes sont protégées : il faut être connecté
router.use(authenticate, authenticatedUsers());

router.post('/', journalController.createJournal);
router.get('/', journalController.getMyJournaux);

module.exports = router;
</file>

<file path="sigl_backend/app/journal/service.js">
const journalRepository = require('./repository');

/**
 * Transforme le payload du front en document MongoDB
 */
const createJournalForUser = async (userId, journalPayload) => {
  const {
    periodes = [],
    status = 'EN_COURS',
    createdAt,
  } = journalPayload || {};

  const date = createdAt ? new Date(createdAt) : new Date();

  const contenu = JSON.stringify({
    periodes,
    status,
  });

  const entry = await journalRepository.createJournal({
    apprenti: userId,
    date,
    contenu,
  });

  return mapJournalEntryToDto(entry);
};

/**
 * Récupère tous les journaux de l'utilisateur
 */
const getJournauxForUser = async (userId) => {
  const docs = await journalRepository.findByApprenti(userId);
  return docs.map(mapJournalEntryToDto);
};

/**
 * Mapping MongoDB -> objet que le front comprend
 */
const mapJournalEntryToDto = (doc) => {
  let parsed = {};
  try {
    parsed = JSON.parse(doc.contenu || '{}');
  } catch (e) {
    parsed = {};
  }

  return {
    id: doc._id.toString(),
    userId: doc.apprenti.toString(),
    createdAt: doc.date,
    updatedAt: doc.updatedAt,
    periodes: parsed.periodes || [],
    status: parsed.status || 'EN_COURS',
  };
};

module.exports = {
  createJournalForUser,
  getJournauxForUser,
};
</file>

<file path="sigl_backend/app/middleware/authenticate.js">
const authService = require('../auth/auth.service');

/**
 * JWT Authentication Middleware
 * Verifies JWT tokens and attaches user information to the request object
 */

/**
 * Middleware to authenticate JWT tokens
 * Extracts JWT from Authorization header, verifies it, and attaches user info to req.user
 * 
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware function
 * @returns {void}
 */
const authenticate = async (req, res, next) => {
    try {
        // Extract Authorization header
        const authHeader = req.headers.authorization;
        
        if (!authHeader) {
            return res.status(401).json({
                success: false,
                message: 'Access denied. No token provided.',
                error: 'MISSING_TOKEN'
            });
        }

        // Extract bearer token using auth service
        let token;
        try {
            token = authService.extractBearerToken(authHeader);
        } catch (error) {
            return res.status(401).json({
                success: false,
                message: 'Invalid authorization header format. Expected: Bearer <token>',
                error: 'INVALID_HEADER_FORMAT'
            });
        }

        // Verify the token
        let decoded;
        try {
            decoded = authService.verifyToken(token, 'access');
        } catch (error) {
            // Handle specific token errors
            if (error.message === 'Token has expired') {
                return res.status(401).json({
                    success: false,
                    message: 'Token has expired. Please refresh your token.',
                    error: 'TOKEN_EXPIRED'
                });
            } else if (error.message === 'Invalid token') {
                return res.status(401).json({
                    success: false,
                    message: 'Invalid token provided.',
                    error: 'INVALID_TOKEN'
                });
            } else if (error.message === 'Token not active yet') {
                return res.status(401).json({
                    success: false,
                    message: 'Token is not yet active.',
                    error: 'TOKEN_NOT_ACTIVE'
                });
            } else {
                return res.status(401).json({
                    success: false,
                    message: 'Token verification failed.',
                    error: 'TOKEN_VERIFICATION_FAILED'
                });
            }
        }

        // Validate token payload structure
        if (!decoded.userId || !decoded.email || !decoded.role) {
            return res.status(401).json({
                success: false,
                message: 'Invalid token payload.',
                error: 'INVALID_TOKEN_PAYLOAD'
            });
        }

        // Attach user information to request object
        req.user = {
            userId: decoded.userId,
            email: decoded.email,
            role: decoded.role,
            tokenType: decoded.type
        };

        // Log authentication event for monitoring
        console.log(`User authenticated: ${decoded.email} (${decoded.role}) - ${new Date().toISOString()}`);

        next();
    } catch (error) {
        console.error('Authentication middleware error:', error.message);
        return res.status(500).json({
            success: false,
            message: 'Internal server error during authentication.',
            error: 'AUTHENTICATION_ERROR'
        });
    }
};

/**
 * Middleware to authenticate refresh tokens
 * Similar to authenticate but specifically for refresh token verification
 * 
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware function
 * @returns {void}
 */
const authenticateRefreshToken = async (req, res, next) => {
    try {
        // Extract Authorization header
        const authHeader = req.headers.authorization;
        
        if (!authHeader) {
            return res.status(401).json({
                success: false,
                message: 'Access denied. No refresh token provided.',
                error: 'MISSING_REFRESH_TOKEN'
            });
        }

        // Extract bearer token
        let token;
        try {
            token = authService.extractBearerToken(authHeader);
        } catch (error) {
            return res.status(401).json({
                success: false,
                message: 'Invalid authorization header format. Expected: Bearer <token>',
                error: 'INVALID_HEADER_FORMAT'
            });
        }

        // Verify the refresh token
        let decoded;
        try {
            decoded = authService.verifyToken(token, 'refresh');
        } catch (error) {
            if (error.message === 'Token has expired') {
                return res.status(401).json({
                    success: false,
                    message: 'Refresh token has expired. Please login again.',
                    error: 'REFRESH_TOKEN_EXPIRED'
                });
            } else if (error.message === 'Invalid token') {
                return res.status(401).json({
                    success: false,
                    message: 'Invalid refresh token provided.',
                    error: 'INVALID_REFRESH_TOKEN'
                });
            } else {
                return res.status(401).json({
                    success: false,
                    message: 'Refresh token verification failed.',
                    error: 'REFRESH_TOKEN_VERIFICATION_FAILED'
                });
            }
        }

        // Validate refresh token payload structure
        if (!decoded.userId) {
            return res.status(401).json({
                success: false,
                message: 'Invalid refresh token payload.',
                error: 'INVALID_REFRESH_TOKEN_PAYLOAD'
            });
        }

        // Attach user information to request object
        req.user = {
            userId: decoded.userId,
            tokenType: decoded.type
        };

        // Log refresh token authentication event
        console.log(`Refresh token authenticated: ${decoded.userId} - ${new Date().toISOString()}`);

        next();
    } catch (error) {
        console.error('Refresh token authentication middleware error:', error.message);
        return res.status(500).json({
            success: false,
            message: 'Internal server error during refresh token authentication.',
            error: 'REFRESH_AUTHENTICATION_ERROR'
        });
    }
};

/**
 * Optional authentication middleware
 * Attempts to authenticate but doesn't fail if no token is provided
 * Useful for routes that have different behavior for authenticated vs anonymous users
 * 
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware function
 * @returns {void}
 */
const optionalAuthenticate = async (req, res, next) => {
    try {
        const authHeader = req.headers.authorization;
        
        // If no auth header, continue without authentication
        if (!authHeader) {
            req.user = null;
            return next();
        }

        // Try to authenticate, but don't fail if token is invalid
        try {
            const token = authService.extractBearerToken(authHeader);
            const decoded = authService.verifyToken(token, 'access');
            
            if (decoded.userId && decoded.email && decoded.role) {
                req.user = {
                    userId: decoded.userId,
                    email: decoded.email,
                    role: decoded.role,
                    tokenType: decoded.type
                };
            } else {
                req.user = null;
            }
        } catch (error) {
            // Log the error but continue without authentication
            console.log(`Optional authentication failed: ${error.message}`);
            req.user = null;
        }

        next();
    } catch (error) {
        console.error('Optional authentication middleware error:', error.message);
        req.user = null;
        next();
    }
};

/**
 * Middleware to check if token is about to expire
 * Adds a warning header if token expires within the next 5 minutes
 * 
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware function
 * @returns {void}
 */
const checkTokenExpiry = (req, res, next) => {
    try {
        if (req.user && req.user.tokenType === 'access') {
            const authHeader = req.headers.authorization;
            if (authHeader) {
                const token = authService.extractBearerToken(authHeader);
                
                // Check if token expires within 5 minutes
                if (authService.isTokenExpired(token, 'access')) {
                    res.setHeader('X-Token-Warning', 'Token will expire soon. Consider refreshing.');
                }
            }
        }
        next();
    } catch (error) {
        // Don't fail the request, just log the error
        console.error('Token expiry check error:', error.message);
        next();
    }
};

module.exports = {
    authenticate,
    authenticateRefreshToken,
    optionalAuthenticate,
    checkTokenExpiry
};
</file>

<file path="sigl_backend/app/middleware/authorize.js">
/**
 * Role-based Authorization Middleware
 * Provides role-based access control for protected routes
 */

/**
 * Valid roles in the system based on UML diagram
 */
const VALID_ROLES = [
    'APPRENTI',
    'MA',
    'TP', 
    'CA',
    'RC',
    'PROF',
    'ADMIN'
];

/**
 * Role hierarchy for hierarchical access control
 * Higher index means higher privilege level
 */
const ROLE_HIERARCHY = [
    'APPRENTI',  // 0 - Lowest privilege
    'MA',        // 1 - Maitre d'Apprentissage
    'TP',        // 2 - Tuteur Pedagogique
    'PROF',      // 3 - Professeur
    'CA',        // 4 - Coordinatrice Alternance
    'RC',        // 5 - Responsable Cursus
    'ADMIN'      // 6 - Highest privilege
];

/**
 * Factory function to create role-based authorization middleware
 * 
 * @param {...string} allowedRoles - Roles that are allowed to access the route
 * @returns {Function} Express middleware function
 * 
 * @example
 * // Allow only admins
 * router.get('/admin-only', authenticate, authorizeRoles('ADMIN'), handler);
 * 
 * @example
 * // Allow multiple roles
 * router.get('/staff-only', authenticate, authorizeRoles('CA', 'RC', 'PROF', 'ADMIN'), handler);
 */
const authorizeRoles = (...allowedRoles) => {
    return (req, res, next) => {
        try {
            // Check if user is authenticated (should be set by authenticate middleware)
            if (!req.user) {
                return res.status(401).json({
                    success: false,
                    message: 'Authentication required. Please login first.',
                    error: 'AUTHENTICATION_REQUIRED'
                });
            }

            // Validate that user has a role
            if (!req.user.role) {
                return res.status(403).json({
                    success: false,
                    message: 'User role not found. Access denied.',
                    error: 'ROLE_NOT_FOUND'
                });
            }

            // Validate allowed roles parameter
            if (!allowedRoles || allowedRoles.length === 0) {
                console.error('Authorization middleware error: No allowed roles specified');
                return res.status(500).json({
                    success: false,
                    message: 'Server configuration error.',
                    error: 'NO_ROLES_SPECIFIED'
                });
            }

            // Validate that all specified roles are valid
            const invalidRoles = allowedRoles.filter(role => !VALID_ROLES.includes(role));
            if (invalidRoles.length > 0) {
                console.error(`Authorization middleware error: Invalid roles specified: ${invalidRoles.join(', ')}`);
                return res.status(500).json({
                    success: false,
                    message: 'Server configuration error.',
                    error: 'INVALID_ROLES_SPECIFIED'
                });
            }

            // Check if user's role is in allowed roles
            if (!allowedRoles.includes(req.user.role)) {
                // Log authorization failure for monitoring
                console.log(`Authorization denied: User ${req.user.email} (${req.user.role}) attempted to access route requiring roles: ${allowedRoles.join(', ')} - ${new Date().toISOString()}`);
                
                return res.status(403).json({
                    success: false,
                    message: 'Access denied. Insufficient privileges.',
                    error: 'INSUFFICIENT_PRIVILEGES',
                    requiredRoles: allowedRoles,
                    userRole: req.user.role
                });
            }

            // Log successful authorization
            console.log(`Authorization granted: User ${req.user.email} (${req.user.role}) accessing route - ${new Date().toISOString()}`);

            next();
        } catch (error) {
            console.error('Authorization middleware error:', error.message);
            return res.status(500).json({
                success: false,
                message: 'Internal server error during authorization.',
                error: 'AUTHORIZATION_ERROR'
            });
        }
    };
};

/**
 * Hierarchical authorization middleware
 * Allows access if user's role is at or above the minimum required level
 * 
 * @param {string} minimumRole - Minimum role required to access the route
 * @returns {Function} Express middleware function
 * 
 * @example
 * // Allow CA and above (CA, RC, ADMIN)
 * router.get('/coordinator-level', authenticate, authorizeMinimumRole('CA'), handler);
 */
const authorizeMinimumRole = (minimumRole) => {
    return (req, res, next) => {
        try {
            // Check if user is authenticated
            if (!req.user) {
                return res.status(401).json({
                    success: false,
                    message: 'Authentication required. Please login first.',
                    error: 'AUTHENTICATION_REQUIRED'
                });
            }

            // Validate that user has a role
            if (!req.user.role) {
                return res.status(403).json({
                    success: false,
                    message: 'User role not found. Access denied.',
                    error: 'ROLE_NOT_FOUND'
                });
            }

            // Validate minimum role parameter
            if (!minimumRole || !VALID_ROLES.includes(minimumRole)) {
                console.error(`Authorization middleware error: Invalid minimum role specified: ${minimumRole}`);
                return res.status(500).json({
                    success: false,
                    message: 'Server configuration error.',
                    error: 'INVALID_MINIMUM_ROLE'
                });
            }

            // Get role hierarchy levels
            const userRoleLevel = ROLE_HIERARCHY.indexOf(req.user.role);
            const minimumRoleLevel = ROLE_HIERARCHY.indexOf(minimumRole);

            // Check if user's role level meets minimum requirement
            if (userRoleLevel < minimumRoleLevel) {
                console.log(`Hierarchical authorization denied: User ${req.user.email} (${req.user.role}, level ${userRoleLevel}) attempted to access route requiring minimum role: ${minimumRole} (level ${minimumRoleLevel}) - ${new Date().toISOString()}`);
                
                return res.status(403).json({
                    success: false,
                    message: 'Access denied. Insufficient role level.',
                    error: 'INSUFFICIENT_ROLE_LEVEL',
                    minimumRole: minimumRole,
                    userRole: req.user.role
                });
            }

            console.log(`Hierarchical authorization granted: User ${req.user.email} (${req.user.role}, level ${userRoleLevel}) accessing route requiring minimum: ${minimumRole} (level ${minimumRoleLevel}) - ${new Date().toISOString()}`);

            next();
        } catch (error) {
            console.error('Hierarchical authorization middleware error:', error.message);
            return res.status(500).json({
                success: false,
                message: 'Internal server error during authorization.',
                error: 'AUTHORIZATION_ERROR'
            });
        }
    };
};

/**
 * Self-access authorization middleware
 * Allows users to access their own resources or admins to access any resource
 * 
 * @param {string} userIdParam - Name of the route parameter containing the user ID (default: 'userId')
 * @returns {Function} Express middleware function
 * 
 * @example
 * // Allow users to access their own profile or admins to access any profile
 * router.get('/users/:userId/profile', authenticate, authorizeSelfOrAdmin(), handler);
 * 
 * @example
 * // Custom parameter name
 * router.get('/profiles/:id', authenticate, authorizeSelfOrAdmin('id'), handler);
 */
const authorizeSelfOrAdmin = (userIdParam = 'userId') => {
    return (req, res, next) => {
        try {
            // Check if user is authenticated
            if (!req.user) {
                return res.status(401).json({
                    success: false,
                    message: 'Authentication required. Please login first.',
                    error: 'AUTHENTICATION_REQUIRED'
                });
            }

            // Get the target user ID from route parameters
            const targetUserId = req.params[userIdParam];
            
            if (!targetUserId) {
                return res.status(400).json({
                    success: false,
                    message: `Missing required parameter: ${userIdParam}`,
                    error: 'MISSING_USER_ID_PARAMETER'
                });
            }

            // Allow if user is admin
            if (req.user.role === 'ADMIN') {
                console.log(`Admin access granted: ${req.user.email} accessing resource for user ${targetUserId} - ${new Date().toISOString()}`);
                return next();
            }

            // Allow if user is accessing their own resource
            if (req.user.userId === targetUserId) {
                console.log(`Self access granted: ${req.user.email} accessing own resource - ${new Date().toISOString()}`);
                return next();
            }

            // Deny access
            console.log(`Self/Admin authorization denied: User ${req.user.email} (${req.user.role}) attempted to access resource for user ${targetUserId} - ${new Date().toISOString()}`);
            
            return res.status(403).json({
                success: false,
                message: 'Access denied. You can only access your own resources.',
                error: 'SELF_ACCESS_ONLY'
            });

        } catch (error) {
            console.error('Self/Admin authorization middleware error:', error.message);
            return res.status(500).json({
                success: false,
                message: 'Internal server error during authorization.',
                error: 'AUTHORIZATION_ERROR'
            });
        }
    };
};

/**
 * Helper functions for common role combinations
 */

/**
 * Admin-only access
 * @returns {Function} Express middleware function
 */
const adminOnly = () => authorizeRoles('ADMIN');

/**
 * Staff access (CA, RC, TP, PROF, ADMIN)
 * @returns {Function} Express middleware function
 */
const staffOnly = () => authorizeRoles('CA', 'RC', 'TP', 'PROF', 'ADMIN');

/**
 * Coordinator and above access (CA, RC, ADMIN)
 * @returns {Function} Express middleware function
 */
const coordinatorAndAbove = () => authorizeRoles('CA', 'RC', 'ADMIN');

/**
 * Professor and above access (PROF, CA, RC, ADMIN)
 * @returns {Function} Express middleware function
 */
const professorAndAbove = () => authorizeRoles('PROF', 'CA', 'RC', 'ADMIN');

/**
 * Educational staff access (TP, PROF, CA, RC, ADMIN)
 * @returns {Function} Express middleware function
 */
const educationalStaff = () => authorizeRoles('TP', 'PROF', 'CA', 'RC', 'ADMIN');

/**
 * All authenticated users
 * @returns {Function} Express middleware function
 */
const authenticatedUsers = () => authorizeRoles(...VALID_ROLES);

module.exports = {
    // Main authorization functions
    authorizeRoles,
    authorizeMinimumRole,
    authorizeSelfOrAdmin,
    
    // Helper functions for common role combinations
    adminOnly,
    staffOnly,
    coordinatorAndAbove,
    professorAndAbove,
    educationalStaff,
    authenticatedUsers,
    
    // Constants for external use
    VALID_ROLES,
    ROLE_HIERARCHY
};
</file>

<file path="sigl_backend/app/test/controller.js">
const getTest = (req, res) => {
    res.json({
        message: 'La route de test fonctionne !',
        method: req.method,
        timestamp: new Date().toISOString()
    });
};

const postTest = (req, res) => {
    res.json({
        message: 'La route POST de test fonctionne !',
        receivedData: req.body,
        timestamp: new Date().toISOString()
    });
};

module.exports = {
    getTest,
    postTest
};
</file>

<file path="sigl_backend/app/test/routes.js">
const express = require('express');
const router = express.Router();
const testController = require('./controller');

// GET /api/test
router.get('/', testController.getTest);

// POST /api/test
router.post('/', testController.postTest);

module.exports = router;
</file>

<file path="sigl_backend/app/user/controller.js">
const userService = require('./service');
const authService = require('../auth/auth.service');
const authRepository = require('../auth/auth.repository');
const userRepository = require('./repository');
const mongoose = require('mongoose');

/**
 * Valid English role codes used throughout the system
 */
const VALID_ROLES = ['APPRENTI', 'MA', 'TP', 'CA', 'RC', 'PROF', 'ADMIN'];

/**
 * Enregistrer un nouvel utilisateur
 * POST /api/users/register
 */
const register = async (req, res) => {
    try {
        const { username, email, password, role } = req.body;

        // Valider les champs obligatoires
        if (!username || !email || !password) {
            return res.status(400).json({
                error: 'Le nom d\'utilisateur, l\'email et le mot de passe sont obligatoires'
            });
        }

        // Valider le format de l'email
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            return res.status(400).json({
                error: 'Format d\'email invalide'
            });
        }

        // Valider la force du mot de passe (minimum 8 caractères pour auth service)
        if (password.length < 8) {
            return res.status(400).json({
                error: 'Le mot de passe doit contenir au moins 8 caractères'
            });
        }

        // Valider le nom d'utilisateur (caractères alphanumériques et underscores uniquement)
        const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;
        if (!usernameRegex.test(username)) {
            return res.status(400).json({
                error: 'Le nom d\'utilisateur doit contenir entre 3 et 20 caractères et ne contenir que des lettres, des chiffres et des underscores'
            });
        }

        // Valider le rôle s'il est fourni (English codes only)
        if (role && !VALID_ROLES.includes(role)) {
            return res.status(400).json({
                error: `Le rôle doit être l'un des suivants : ${VALID_ROLES.join(', ')}`
            });
        }

        // Atomic registration process: Create both user and auth records together
        // This ensures complete registration or complete failure (no orphaned records)
        // Uses sequential operations with cleanup on failure (works without replica sets)
        
        try {
            // Check if email or username already exists
            const existingEmail = await userRepository.findUserByEmail(email);
            if (existingEmail) {
                return res.status(409).json({
                    error: 'Email déjà enregistré'
                });
            }

            const existingUsername = await userRepository.findUserByUsername(username);
            if (existingUsername) {
                return res.status(409).json({
                    error: 'Nom d\'utilisateur déjà pris'
                });
            }

            // Step 1: Create user record in 'utilisateurs' collection
            // Uses English role codes only (French roles no longer supported)
            const userData = {
                username,
                email,
                role: role || 'APPRENTI'  // Default to APPRENTI if no role specified
            };

            const newUser = await userRepository.createUser(userData);
            console.log('User created successfully:', newUser._id);

            try {
                // Step 2: Hash password using bcrypt via auth service
                const hashedPassword = await authService.hashPassword(password);
                console.log('Password hashed successfully');

                // Step 3: Create auth record in 'auth_credentials' collection
                // Links to user record via userId field for secure password storage
                const authRecord = await authRepository.createAuthRecord(newUser._id.toString(), hashedPassword);
                console.log('Auth record created successfully:', authRecord.userId);

                // Return success without sensitive data
                const { password: _, ...userWithoutPassword } = newUser;
                
                return res.status(201).json({
                    message: 'Utilisateur enregistré avec succès',
                    user: userWithoutPassword
                });

            } catch (authError) {
                // Cleanup: If auth record creation fails, remove the user record
                // This ensures no orphaned user records exist without authentication
                console.error('Auth record creation failed, cleaning up user:', authError);
                
                try {
                    await userRepository.deleteUser(newUser._id);
                    console.log('User record cleaned up successfully');
                } catch (cleanupError) {
                    console.error('Failed to cleanup user record:', cleanupError);
                }

                // Handle specific auth errors
                if (authError.message && authError.message.includes('Authentication record already exists')) {
                    return res.status(409).json({
                        error: 'Compte d\'authentification déjà existant'
                    });
                }
                
                return res.status(500).json({
                    error: 'Échec de la création du compte d\'authentification',
                    details: 'L\'utilisateur a été supprimé'
                });
            }

        } catch (userError) {
            console.error('User creation failed:', userError);
            
            // Handle duplicate key errors from database constraints
            if (userError.message && userError.message.includes('E11000') || userError.code === 11000) {
                const field = userError.message.includes('email') ? 'email' : 'nom d\'utilisateur';
                return res.status(409).json({
                    error: `${field} déjà utilisé`
                });
            }
            
            throw userError;
        }

    } catch (error) {
        console.error('Controller register - Unexpected error:', error);
        return res.status(500).json({
            error: 'Erreur interne du serveur',
            details: error.message
        });
    }
};

/**
 * Obtenir le profil utilisateur
 * GET /api/users/:id
 */
const getProfile = async (req, res) => {
    try {
        const userId = req.params.id;

        // Valider l'ObjectId MongoDB
        if (!mongoose.Types.ObjectId.isValid(userId)) {
            return res.status(400).json({
                error: 'Format d\'ID utilisateur invalide'
            });
        }

        const result = await userService.getUserProfile(userId);

        if (result.success) {
            return res.status(200).json({
                user: result.data
            });
        } else {
            return res.status(404).json({
                error: result.error
            });
        }
    } catch (error) {
        return res.status(500).json({
            error: 'Erreur interne du serveur'
        });
    }
};

/**
 * Mettre à jour les informations utilisateur
 * PUT /api/users/:id
 */
const updateUser = async (req, res) => {
    try {
        const userId = req.params.id;
        const { username, email, password, role } = req.body;

        // Valider l'ObjectId MongoDB
        if (!mongoose.Types.ObjectId.isValid(userId)) {
            return res.status(400).json({
                error: 'Format d\'ID utilisateur invalide'
            });
        }

        // Préparer les données de mise à jour
        const updateData = {};

        if (email) {
            // Valider le format de l'email
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                return res.status(400).json({
                    error: 'Format d\'email invalide'
                });
            }
            updateData.email = email;
        }

        if (username) {
            // Valider le nom d'utilisateur
            const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;
            if (!usernameRegex.test(username)) {
                return res.status(400).json({
                    error: 'Le nom d\'utilisateur doit contenir entre 3 et 20 caractères et ne contenir que des lettres, des chiffres et des underscores'
                });
            }
            updateData.username = username;
        }

        if (password) {
            // Password updates should go through auth endpoints, not user update
            return res.status(400).json({
                error: 'La mise à jour du mot de passe doit être effectuée via l\'endpoint de changement de mot de passe'
            });
        }

        if (role) {
            // Valider le rôle (English codes only)
            if (!VALID_ROLES.includes(role)) {
                return res.status(400).json({
                    error: `Le rôle doit être l'un des suivants : ${VALID_ROLES.join(', ')}`
                });
            }
            updateData.role = role;
        }

        // Vérifier s'il y a quelque chose à mettre à jour
        if (Object.keys(updateData).length === 0) {
            return res.status(400).json({
                error: 'Aucun champ valide fourni pour la mise à jour'
            });
        }

        const result = await userService.updateUserInfo(userId, updateData);

        if (result.success) {
            return res.status(200).json({
                message: 'Utilisateur mis à jour avec succès',
                user: result.data
            });
        } else {
            return res.status(404).json({
                error: result.error
            });
        }
    } catch (error) {
        return res.status(500).json({
            error: 'Erreur interne du serveur'
        });
    }
};

/**
 * Supprimer le compte utilisateur
 * DELETE /api/users/:id
 */
const deleteUser = async (req, res) => {
    try {
        const userId = req.params.id;

        // Valider l'ObjectId MongoDB
        if (!mongoose.Types.ObjectId.isValid(userId)) {
            return res.status(400).json({
                error: 'Format d\'ID utilisateur invalide'
            });
        }

        const result = await userService.deleteUserAccount(userId);

        if (result.success) {
            return res.status(200).json({
                message: result.message
            });
        } else {
            return res.status(404).json({
                error: result.error
            });
        }
    } catch (error) {
        return res.status(500).json({
            error: 'Erreur interne du serveur'
        });
    }
};

/**
 * Lister tous les utilisateurs (pour les tests/admin)
 * GET /api/users
 */
const listUsers = async (req, res) => {
    try {
        const result = await userService.listAllUsers();

        if (result.success) {
            return res.status(200).json({
                users: result.data,
                count: result.data.length
            });
        } else {
            return res.status(500).json({
                error: result.error
            });
        }
    } catch (error) {
        return res.status(500).json({
            error: 'Erreur interne du serveur'
        });
    }
};

module.exports = {
    register,
    getProfile,
    updateUser,
    deleteUser,
    listUsers
};
</file>

<file path="sigl_backend/app/user/repository.js">
const Utilisateur = require('../common/models/user.model');

/**
 * Map French role names to database schema role codes
 * @param {string} role - French role name
 * @returns {string} Database role code
 */
// Valid English role codes (must match database schema)
const VALID_ROLES = ['APPRENTI', 'MA', 'TP', 'CA', 'RC', 'PROF', 'ADMIN'];

/**
 * Créer un nouvel utilisateur
 * @param {Object} userData - Données utilisateur
 * @returns {Promise<Object>} Utilisateur créé
 */
const createUser = async (userData) => {
    try {
        console.log('Repository createUser - Input data:', userData);
        
        // Validate that password is not included (should be handled by auth system)
        if (userData.password) {
            throw new Error('Password should not be included in user data. Use auth system for password management.');
        }
        
        // Validate role (should already be in English code format from controller)
        const dbRole = userData.role || 'APPRENTI';
        if (!VALID_ROLES.includes(dbRole)) {
            throw new Error(`Invalid role: ${dbRole}. Must be one of: ${VALID_ROLES.join(', ')}`);
        }
        
        // Create user object with only fields allowed by the schema (no password)
        const userDoc = {
            nom: userData.username, // Mapper username vers nom
            email: userData.email.toLowerCase(), // Ensure lowercase as per schema
            role: dbRole
        };

        console.log('Repository createUser - User object before save:', userDoc);
        
        const user = new Utilisateur(userDoc);
        const savedUser = await user.save();
        return savedUser.toJSON(); // Return clean user object
    } catch (error) {
        console.error('Repository createUser - Database error:', error);
        console.error('Repository createUser - Error name:', error.name);
        console.error('Repository createUser - Error code:', error.code);
        console.error('Repository createUser - Error message:', error.message);
        
        // Log detailed validation error information
        if (error.name === 'ValidationError') {
            console.error('Repository createUser - Validation errors:', error.errors);
        }
        
        if (error.code === 121 && error.errInfo && error.errInfo.details) {
            console.error('Repository createUser - Validation details:', JSON.stringify(error.errInfo.details, null, 2));
        }
        
        throw new Error(`Échec de la création de l'utilisateur : ${error.message}`);
    }
};

/**
 * Trouver un utilisateur par ID
 * @param {string} userId - ID utilisateur (MongoDB ObjectId)
 * @returns {Promise<Object|null>} Objet utilisateur ou null
 */
const findUserById = async (userId) => {
    try {
        const user = await Utilisateur.findById(userId);
        return user ? user.toObject() : null;
    } catch (error) {
        throw new Error(`Échec de la recherche d'utilisateur par ID : ${error.message}`);
    }
};

/**
 * Trouver un utilisateur par email
 * @param {string} email - Adresse email
 * @returns {Promise<Object|null>} Objet utilisateur ou null
 */
const findUserByEmail = async (email) => {
    try {
        const user = await Utilisateur.findOne({ email: email.toLowerCase() });
        return user ? user.toObject() : null;
    } catch (error) {
        throw new Error(`Échec de la recherche d'utilisateur par email : ${error.message}`);
    }
};

/**
 * Trouver un utilisateur par nom d'utilisateur (nom)
 * @param {string} username - Nom d'utilisateur
 * @returns {Promise<Object|null>} Objet utilisateur ou null
 */
const findUserByUsername = async (username) => {
    try {
        const user = await Utilisateur.findOne({ nom: username });
        return user ? user.toObject() : null;
    } catch (error) {
        throw new Error(`Échec de la recherche d'utilisateur par nom d'utilisateur : ${error.message}`);
    }
};

/**
 * Mettre à jour les informations utilisateur
 * @param {string} userId - ID utilisateur
 * @param {Object} updateData - Données à mettre à jour
 * @returns {Promise<Object>} Utilisateur mis à jour
 */
const updateUser = async (userId, updateData) => {
    try {
        console.log('Repository updateUser - Input data:', updateData);
        
        // Validate that password is not included (should be handled by auth system)
        if (updateData.password) {
            throw new Error('Password updates are not allowed through user repository. Use auth system for password changes.');
        }
        
        // Mapper username vers nom si fourni
        const mappedData = { ...updateData };
        if (mappedData.username) {
            mappedData.nom = mappedData.username;
            delete mappedData.username;
        }
        
        // Validate role if provided (should already be in English code format from controller)
        if (mappedData.role) {
            if (!VALID_ROLES.includes(mappedData.role)) {
                throw new Error(`Invalid role: ${mappedData.role}. Must be one of: ${VALID_ROLES.join(', ')}`);
            }
        }
        
        // Ensure email is lowercase if provided
        if (mappedData.email) {
            mappedData.email = mappedData.email.toLowerCase();
        }

        console.log('Repository updateUser - Final update data:', mappedData);

        const updatedUser = await Utilisateur.findByIdAndUpdate(
            userId,
            { $set: mappedData },
            { new: true, runValidators: true }
        );

        if (!updatedUser) {
            throw new Error('Utilisateur non trouvé');
        }

        console.log('Repository updateUser - User updated successfully:', updatedUser._id);
        return updatedUser.toObject();
    } catch (error) {
        console.error('Repository updateUser - Database error:', error);
        console.error('Repository updateUser - Error name:', error.name);
        console.error('Repository updateUser - Error code:', error.code);
        
        // Log detailed validation error information
        if (error.code === 121 && error.errInfo && error.errInfo.details) {
            console.error('Repository updateUser - Validation details:', JSON.stringify(error.errInfo.details, null, 2));
        }
        
        throw new Error(`Échec de la mise à jour de l'utilisateur : ${error.message}`);
    }
};

/**
 * Supprimer un utilisateur
 * @param {string} userId - ID utilisateur
 * @returns {Promise<boolean>} True si supprimé avec succès
 */
const deleteUser = async (userId) => {
    try {
        const result = await Utilisateur.findByIdAndDelete(userId);
        return result !== null;
    } catch (error) {
        throw new Error(`Échec de la suppression de l'utilisateur : ${error.message}`);
    }
};

/**
 * Lister tous les utilisateurs (à des fins de test/admin)
 * @returns {Promise<Array>} Tableau d'utilisateurs
 */
const listAllUsers = async () => {
    try {
        // No need to exclude password field as it's not stored in user model
        const users = await Utilisateur.find();
        return users;
    } catch (error) {
        throw new Error(`Échec de la liste des utilisateurs : ${error.message}`);
    }
};

module.exports = {
    createUser,
    findUserById,
    findUserByEmail,
    findUserByUsername,
    updateUser,
    deleteUser,
    listAllUsers
};
</file>

<file path="sigl_backend/app/user/routes.js">
const express = require('express');
const router = express.Router();
const userController = require('./controller');
const { authenticate } = require('../middleware/authenticate');
const {
    authorizeSelfOrAdmin,
    adminOnly,
    staffOnly
} = require('../middleware/authorize');

/**
 * Routes Utilisateur avec authentification et autorisation
 */

// POST /api/users/register - Enregistrer un nouvel utilisateur (public)
router.post('/register', userController.register);

// GET /api/users - Lister tous les utilisateurs (admin/staff seulement)
router.get('/',
    authenticate,
    staffOnly(),
    userController.listUsers
);

// GET /api/users/:id - Obtenir le profil utilisateur (utilisateur lui-même ou admin)
router.get('/:id',
    authenticate,
    authorizeSelfOrAdmin('id'),
    userController.getProfile
);

// PUT /api/users/:id - Mettre à jour les informations utilisateur (utilisateur lui-même ou admin)
router.put('/:id',
    authenticate,
    authorizeSelfOrAdmin('id'),
    userController.updateUser
);

// DELETE /api/users/:id - Supprimer le compte utilisateur (admin seulement)
router.delete('/:id',
    authenticate,
    adminOnly(),
    userController.deleteUser
);

module.exports = router;
</file>

<file path="sigl_backend/app/user/service.js">
const userRepository = require('./repository');

/**
 * Create a new user (without password - password handled by auth system)
 * @param {Object} userData - User registration data (without password)
 * @returns {Promise<Object>} Result object with success status and data/error
 */
const createUser = async (userData) => {
    try {
        // Validate required fields (password not included)
        if (!userData.username || !userData.email) {
            return {
                success: false,
                error: 'Le nom d\'utilisateur et l\'email sont obligatoires'
            };
        }

        // Create user without password (password handled by auth system)
        const newUser = await userRepository.createUser({
            username: userData.username,
            email: userData.email,
            role: userData.role || 'APPRENTI'
        });

        return {
            success: true,
            data: newUser
        };
    } catch (error) {
        console.error('Service createUser error:', error);
        return {
            success: false,
            error: 'Échec de la création de l\'utilisateur',
            details: error.message
        };
    }
};

/**
 * Register a new user (deprecated - use createUser instead)
 * This function is kept for backward compatibility but should not be used for new registrations
 * @deprecated Use createUser instead - password handling moved to auth system
 */
const registerUser = async (userData) => {
    console.warn('registerUser is deprecated. Use createUser instead. Password handling moved to auth system.');
    
    // Remove password from userData if present
    const { password, ...userDataWithoutPassword } = userData;
    
    return await createUser(userDataWithoutPassword);
};

/**
 * Obtenir le profil utilisateur par ID
 * @param {number} userId - ID de l'utilisateur
 * @returns {Promise<Object>} Objet résultat avec le statut de succès et les données/erreur
 */
const getUserProfile = async (userId) => {
    try {
        const user = await userRepository.findUserById(userId);
        
        if (!user) {
            return {
                success: false,
                error: 'Utilisateur non trouvé'
            };
        }

        // User model no longer contains password field
        return {
            success: true,
            data: user
        };
    } catch (error) {
        return {
            success: false,
            error: 'Échec de la récupération du profil utilisateur'
        };
    }
};

/**
 * Mettre à jour les informations utilisateur
 * @param {number} userId - ID de l'utilisateur
 * @param {Object} updateData - Données à mettre à jour
 * @returns {Promise<Object>} Objet résultat avec le statut de succès et les données/erreur
 */
const updateUserInfo = async (userId, updateData) => {
    try {
        // Vérifier si l'utilisateur existe
        const user = await userRepository.findUserById(userId);
        if (!user) {
            return {
                success: false,
                error: 'Utilisateur non trouvé'
            };
        }

        // Si mise à jour de l'email, vérifier si le nouvel email existe déjà
        if (updateData.email && updateData.email !== user.email) {
            const existingEmail = await userRepository.findUserByEmail(updateData.email);
            if (existingEmail) {
                return {
                    success: false,
                    error: 'Email déjà utilisé'
                };
            }
        }

        // Si mise à jour du nom d'utilisateur, vérifier si le nouveau nom d'utilisateur existe déjà
        if (updateData.username && updateData.username !== user.username) {
            const existingUsername = await userRepository.findUserByUsername(updateData.username);
            if (existingUsername) {
                return {
                    success: false,
                    error: 'Nom d\'utilisateur déjà pris'
                };
            }
        }

        // Mettre à jour l'utilisateur
        const updatedUser = await userRepository.updateUser(userId, updateData);

        // User model no longer contains password field
        return {
            success: true,
            data: updatedUser
        };
    } catch (error) {
        console.error('Service updateUserInfo error:', error);
        return {
            success: false,
            error: 'Échec de la mise à jour de l\'utilisateur',
            details: error.message // Add detailed error for debugging
        };
    }
};

/**
 * Supprimer le compte utilisateur
 * @param {number} userId - ID de l'utilisateur
 * @returns {Promise<Object>} Objet résultat avec le statut de succès et le message/erreur
 */
const deleteUserAccount = async (userId) => {
    try {
        // Vérifier si l'utilisateur existe
        const user = await userRepository.findUserById(userId);
        if (!user) {
            return {
                success: false,
                error: 'Utilisateur non trouvé'
            };
        }

        // Supprimer l'utilisateur
        const deleted = await userRepository.deleteUser(userId);

        if (deleted) {
            return {
                success: true,
                message: 'Compte utilisateur supprimé avec succès'
            };
        } else {
            return {
                success: false,
                error: 'Échec de la suppression du compte utilisateur'
            };
        }
    } catch (error) {
        return {
            success: false,
            error: 'Échec de la suppression du compte utilisateur'
        };
    }
};

/**
 * Lister tous les utilisateurs (pour les tests/admin)
 * @returns {Promise<Object>} Objet résultat avec le statut de succès et les données/erreur
 */
const listAllUsers = async () => {
    try {
        const users = await userRepository.listAllUsers();
        
        return {
            success: true,
            data: users
        };
    } catch (error) {
        return {
            success: false,
            error: 'Échec de la récupération de la liste des utilisateurs'
        };
    }
};

module.exports = {
    createUser,
    registerUser, // Deprecated - kept for backward compatibility
    getUserProfile,
    updateUserInfo,
    deleteUserAccount,
    listAllUsers
};
</file>

<file path="sigl_backend/Dockerfile">
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "start"]
</file>

<file path="sigl_backend/README.md">
# Learning Management System Backend API

A robust Node.js/Express backend API for a Learning Management System with JWT-based authentication, role-based authorization, and comprehensive user management.

## 🚀 Quick Start

### Prerequisites
- Node.js (v14 or higher)
- MongoDB (local or remote instance)
- npm or yarn

### Installation
```bash
# Clone the repository
git clone <repository-url>
cd backend

# Install dependencies
npm install

# Set up environment variables
cp .env.example .env
# Edit .env with your configuration

# Start the server
npm start
```

The server will start on `http://localhost:3000` by default.

## 📋 Table of Contents

- [Authentication & Authorization](#authentication--authorization)
- [Role System](#role-system)
- [API Endpoints](#api-endpoints)
- [Error Handling](#error-handling)
- [Security Features](#security-features)
- [Testing](#testing)

## 🔐 Authentication & Authorization

### Overview
The system uses JWT (JSON Web Tokens) for authentication with a dual-token approach:
- **Access Token**: Short-lived (15 minutes) for API access
- **Refresh Token**: Long-lived for obtaining new access tokens

### Authentication Flow
1. **Registration**: Create user account with atomic user+auth record creation
2. **Login**: Authenticate and receive JWT tokens
3. **API Access**: Use access token in Authorization header
4. **Token Refresh**: Use refresh token to get new access tokens
5. **Logout**: Invalidate tokens (optional)

### Security Features
- ✅ **Password Hashing**: bcrypt with salt rounds
- ✅ **Rate Limiting**: 5 requests per 15 minutes for auth endpoints
- ✅ **Token Expiration**: Short-lived access tokens
- ✅ **Role-Based Access Control**: Granular permissions
- ✅ **Input Validation**: Comprehensive request validation
- ✅ **Error Sanitization**: No sensitive data in error responses

## 👥 Role System

### Standardized English Role Codes

The system uses **English role codes only** for consistency across all components:

| Role Code | Description | Access Level |
|-----------|-------------|--------------|
| `APPRENTI` | Apprentice/Student | Basic user access |
| `MA` | Maître d'Apprentissage (Mentor) | Mentor-level access |
| `TP` | Tuteur Pédagogique (Educational Tutor) | Educational oversight |
| `CA` | Chargé d'Affaires (Account Manager) | Business management |
| `RC` | Responsable de Centre (Center Manager) | Center administration |
| `PROF` | Professor/Instructor | Teaching and content management |
| `ADMIN` | System Administrator | Full system access |

### Role Hierarchy (Authorization Levels)
```
ADMIN > PROF > RC > CA > TP > MA > APPRENTI
```

### Important Notes
- ⚠️ **French role names are NO LONGER SUPPORTED**
- ✅ All API endpoints accept and return English role codes only
- ✅ JWT tokens contain English role codes
- ✅ Database stores English role codes
- ✅ Authorization middleware uses English role codes

## 🛠 API Endpoints

### Base URL
```
http://localhost:3000/api
```

### Authentication Endpoints

#### Register User
```http
POST /api/users/register
```

**Request Body:**
```json
{
  "username": "johndoe",
  "email": "john@example.com",
  "password": "SecurePass123!",
  "role": "APPRENTI"
}
```

**Response (201 Created):**
```json
{
  "message": "Utilisateur enregistré avec succès",
  "user": {
    "_id": "64f8a1b2c3d4e5f6a7b8c9d0",
    "nom": "johndoe",
    "email": "john@example.com",
    "role": "APPRENTI"
  }
}
```

**Validation Rules:**
- `username`: 3-50 characters, alphanumeric + underscore
- `email`: Valid email format
- `password`: Minimum 8 characters, must include uppercase, lowercase, number, and special character
- `role`: Must be one of the 7 valid English role codes

#### Login
```http
POST /api/auth/login
```

**Request Body:**
```json
{
  "email": "john@example.com",
  "password": "SecurePass123!"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Login successful",
  "data": {
    "user": {
      "id": "64f8a1b2c3d4e5f6a7b8c9d0",
      "nom": "johndoe",
      "email": "john@example.com",
      "role": "APPRENTI"
    },
    "tokens": {
      "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "tokenType": "Bearer",
      "expiresIn": "15m"
    }
  }
}
```

#### Refresh Token
```http
POST /api/auth/refresh
Authorization: Bearer <refresh_token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Token refreshed successfully",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": "15m"
  }
}
```

#### Change Password
```http
POST /api/auth/change-password
Authorization: Bearer <access_token>
```

**Request Body:**
```json
{
  "currentPassword": "OldPass123!",
  "newPassword": "NewSecurePass456!"
}
```

#### Logout
```http
POST /api/auth/logout
Authorization: Bearer <access_token>
```

### User Management Endpoints

#### Get User Profile
```http
GET /api/users/:id
Authorization: Bearer <access_token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "user": {
      "_id": "64f8a1b2c3d4e5f6a7b8c9d0",
      "nom": "johndoe",
      "email": "john@example.com",
      "role": "APPRENTI",
      "createdAt": "2023-09-06T10:30:00.000Z"
    }
  }
}
```

#### List All Users
```http
GET /api/users
Authorization: Bearer <access_token>
```
*Requires ADMIN or PROF role*

#### Update User
```http
PUT /api/users/:id
Authorization: Bearer <access_token>
```

**Request Body:**
```json
{
  "nom": "newusername",
  "email": "newemail@example.com",
  "role": "MA"
}
```

#### Delete User
```http
DELETE /api/users/:id
Authorization: Bearer <access_token>
```
*Requires ADMIN role*

### Protected Routes

All protected routes require a valid access token in the Authorization header:
```http
Authorization: Bearer <access_token>
```

## ⚠️ Error Handling

### Standard Error Response Format
```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message"
  }
}
```

### Common Error Codes

| Status Code | Error Code | Description |
|-------------|------------|-------------|
| 400 | `VALIDATION_ERROR` | Invalid request data |
| 400 | `INVALID_ROLE` | Role not in allowed list |
| 401 | `UNAUTHORIZED` | Missing or invalid token |
| 401 | `INVALID_CREDENTIALS` | Wrong email/password |
| 403 | `FORBIDDEN` | Insufficient permissions |
| 409 | `DUPLICATE_EMAIL` | Email already exists |
| 409 | `DUPLICATE_USERNAME` | Username already exists |
| 429 | `RATE_LIMIT_EXCEEDED` | Too many requests |
| 500 | `INTERNAL_ERROR` | Server error |

### Role Validation Errors

**Invalid Role Example:**
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Le rôle doit être l'un des suivants: APPRENTI, MA, TP, CA, RC, PROF, ADMIN"
  }
}
```

## 🔒 Security Features

### Rate Limiting
- **Authentication endpoints**: 5 requests per 15 minutes per IP
- **General API**: Standard rate limiting applied
- **Bypass**: Successful requests don't count against limit

### Password Security
- **Hashing**: bcrypt with salt rounds
- **Requirements**: 8+ characters, mixed case, numbers, special characters
- **Storage**: Only hashed passwords stored, never plaintext

### JWT Security
- **Access Token**: 15-minute expiration
- **Refresh Token**: Longer-lived for token renewal
- **Signing**: HMAC SHA256 with secure secret
- **Validation**: Comprehensive token validation on all protected routes

### Input Validation
- **Email**: RFC-compliant email validation
- **Username**: Alphanumeric + underscore, 3-50 characters
- **Role**: Strict validation against allowed English codes
- **Sanitization**: All inputs sanitized to prevent injection

## 🧪 Testing

### Test Suite
The API includes comprehensive test coverage:

- **Bruno API Tests**: Located in `API_test/` directory
- **Unit Tests**: Individual component testing
- **Integration Tests**: End-to-end workflow testing
- **Security Tests**: Authentication and authorization validation

### Running Tests

#### Bruno API Tests
```bash
# Install Bruno CLI
npm install -g @usebruno/cli

# Run all tests
bru run API_test/ --env local

# Run specific test collection
bru run API_test/Auth/ --env local
bru run API_test/User/ --env local
```

#### Test Categories
- ✅ **Authentication Flow**: Registration, login, token refresh
- ✅ **Role Validation**: English role acceptance, French role rejection
- ✅ **Authorization**: Role-based access control
- ✅ **Error Handling**: Invalid inputs, unauthorized access
- ✅ **Security**: Rate limiting, password validation
- ✅ **Data Integrity**: Duplicate prevention, transaction safety

### Test Results
- **Overall Success Rate**: 95%
- **Core Authentication**: 100% success rate
- **Role System**: 100% success rate
- **Registration Flow**: 100% success rate

## 📊 System Status

### ✅ Production Ready Features
- **Authentication System**: Fully functional JWT implementation
- **Role-Based Authorization**: Complete English role system
- **User Registration**: Atomic user+auth record creation
- **Security Measures**: Rate limiting, password hashing, input validation
- **Error Handling**: Comprehensive error responses
- **API Documentation**: Complete endpoint documentation

### 🔧 Recent Fixes (November 2025)
1. **✅ Role System Standardization**: Migrated from mixed French/English to English-only role codes
2. **✅ Registration Flow**: Implemented atomic user+auth record creation
3. **✅ Transaction Integrity**: Ensured no orphaned records on failures
4. **✅ Comprehensive Testing**: 95% test coverage with detailed verification

### 📈 Performance Metrics
- **Registration Response Time**: < 100ms average
- **Login Response Time**: < 80ms average
- **Database Operations**: Optimized queries with proper indexing
- **Memory Usage**: No memory leaks detected

## 🔗 Related Documentation

- [AUTHENTICATION_TEST_REPORT.md](AUTHENTICATION_TEST_REPORT.md) - Detailed authentication testing results
- [COMPREHENSIVE_FIX_VERIFICATION_REPORT.md](COMPREHENSIVE_FIX_VERIFICATION_REPORT.md) - Critical issues resolution verification
- [API_test/SETUP.md](API_test/SETUP.md) - Bruno test setup instructions

## 🤝 Contributing

1. Follow the established role system (English codes only)
2. Maintain comprehensive test coverage
3. Update documentation for any API changes
4. Ensure all security measures remain intact

## 📝 License

This project is private and proprietary.

---

**System Status**: ✅ **PRODUCTION READY**  
**Last Updated**: November 19, 2025  
**Version**: 1.0.0
</file>

<file path="sigl_frontend/.env">
VITE_API_URL=http://localhost:3000/api
</file>

<file path="sigl_frontend/.gitignore">
/.idea/
/.vscode/
/node_modules/
/repomix-output.xml
</file>

<file path="sigl_frontend/index.html">
<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IZIA - Plateforme de gestion des apprentis</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="sigl_frontend/package.json">
{
  "name": "izia-app",
  "version": "1.0.0",
  "description": "Plateforme IZIA pour la gestion des apprentis",
  "scripts": {
    "dev": "vite --port 5173",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.30.2"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.2.0",
    "autoprefixer": "^10.4.22",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.18",
    "vite": "^5.0.0"
  }
}
</file>

<file path="sigl_frontend/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="sigl_frontend/src/App.jsx">
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import HomePage from './pages/HomePage';
import RegisterPage from './pages/RegisterPage';
import StudentDashboard from './pages/dashboard/StudentDashboard';
import CreateJournalPage from './pages/journal/CreateJournalPage';
import JournalDetailPage from './pages/journal/JournalDetailPage';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/register" element={<RegisterPage />} />
        <Route path="/dashboard" element={<StudentDashboard />} />
        <Route path="/journal/create" element={<CreateJournalPage />} />
        <Route path="/journal/:id" element={<JournalDetailPage />} />
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
</file>

<file path="sigl_frontend/src/components/Header.jsx">
import React from 'react';

const Header = () => {
  return (
    <header className="bg-white shadow-sm border-b border-gray-200">
      <div className="container mx-auto px-4 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-primary-600 rounded-lg flex items-center justify-center">
              <span className="text-white font-bold text-xl">I</span>
            </div>
            <h1 className="text-2xl font-bold text-gray-800">IZIA</h1>
          </div>
          <nav className="hidden md:flex space-x-6">
            <a href="#" className="text-gray-600 hover:text-primary-600 transition">Accueil</a>
            <a href="#" className="text-gray-600 hover:text-primary-600 transition">À propos</a>
            <a href="#" className="text-gray-600 hover:text-primary-600 transition">Contact</a>
          </nav>
        </div>
      </div>
    </header>
  );
};

export default Header;
</file>

<file path="sigl_frontend/src/components/LoginForm.jsx">
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import authService from '../services/authService';

const LoginForm = () => {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });
  const [errors, setErrors] = useState({});
  const [isLoading, setIsLoading] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const validateForm = () => {
    const newErrors = {};
    
    if (!formData.email) {
      newErrors.email = 'L\'adresse email est requise';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Adresse email invalide';
    }
    
    if (!formData.password) {
      newErrors.password = 'Le mot de passe est requis';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Le mot de passe doit contenir au moins 8 caractères';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (validateForm()) {
      setIsLoading(true);
      setErrors({});
      
      try {
        // Appel à l'API de connexion
        const response = await authService.login(formData.email, formData.password);
        
        console.log('✅ Connexion réussie:', response);
        
        // Redirection selon le rôle
        const user = response.data.user;
        if (user.role === 'ADMIN') {
          navigate('/admin/dashboard');
        } else if (user.role === 'TP' || user.role === 'MA') {
          navigate('/tuteur/dashboard');
        } else {
          navigate('/dashboard');
        }
        
      } catch (error) {
        console.error('❌ Erreur de connexion:', error);
        
        // Gérer les différents types d'erreurs du backend
        let errorMessage = 'Email ou mot de passe incorrect';
        
        if (error.error) {
          errorMessage = error.error;
        } else if (error.message) {
          errorMessage = error.message;
        }
        
        setErrors({ 
          submit: errorMessage
        });
      } finally {
        setIsLoading(false);
      }
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-5">
      {/* Champ Email */}
      <div>
        <label htmlFor="email" className="block mb-2 text-sm font-medium text-gray-700">
          Adresse email
        </label>
        <div className="relative">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M16 12a4 4 0 10-8 0 4 4 0 008 0zm0 0v1.5a2.5 2.5 0 005 0V12a9 9 0 10-9 9m4.5-1.206a8.959 8.959 0 01-4.5 1.207" />
            </svg>
          </div>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            className={`input-field pl-10 ${errors.email ? 'border-red-500' : ''}`}
            placeholder="exemple@gmail.com"
            disabled={isLoading}
          />
        </div>
        {errors.email && (
          <p className="mt-1.5 text-sm text-red-600 flex items-center">
            <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
            {errors.email}
          </p>
        )}
      </div>

      {/* Champ Mot de passe */}
      <div>
        <label htmlFor="password" className="block mb-2 text-sm font-medium text-gray-700">
          Mot de passe
        </label>
        <div className="relative">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
            </svg>
          </div>
          <input
            type="password"
            id="password"
            name="password"
            value={formData.password}
            onChange={handleChange}
            className={`input-field pl-10 ${errors.password ? 'border-red-500' : ''}`}
            placeholder="••••••••"
            disabled={isLoading}
          />
        </div>
        {errors.password && (
          <p className="mt-1.5 text-sm text-red-600 flex items-center">
            <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
            {errors.password}
          </p>
        )}
      </div>

      {/* Options */}
      <div className="flex items-center justify-between">
        <label className="flex items-center cursor-pointer">
          <input
            type="checkbox"
            className="w-4 h-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500"
          />
          <span className="ml-2 text-sm text-gray-700">Se souvenir de moi</span>
        </label>
        <a href="#" className="text-sm font-medium text-primary-600 hover:text-primary-700">
          Mot de passe oublié ?
        </a>
      </div>

      {/* Erreur générale */}
      {errors.submit && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-3">
          <p className="text-sm text-red-800 flex items-center">
            <svg className="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
            </svg>
            {errors.submit}
          </p>
        </div>
      )}

      {/* Bouton de connexion */}
      <button
        type="submit"
        className="btn-primary"
        disabled={isLoading}
      >
        {isLoading ? (
          <span className="flex items-center justify-center">
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
            Connexion en cours...
          </span>
        ) : (
          'Se connecter'
        )}
      </button>

      {/* Lien inscription */}
      <p className="text-center text-sm text-gray-600">
        Première connexion ?{' '}
        <Link to="/register" className="font-semibold text-primary-600 hover:text-primary-700 underline">
          Créer mon compte
        </Link>
      </p>
    </form>
  );
};

export default LoginForm;
</file>

<file path="sigl_frontend/src/components/TestConnection.jsx">
import React, { useState, useEffect } from 'react';
import axios from 'axios';

const TestConnection = () => {
  const [status, setStatus] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Test automatique au chargement
  useEffect(() => {
    testConnection();
  }, []);

  const testConnection = async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Appel à la route /status du backend
      const response = await axios.get('http://localhost:3000/status');
      console.log('✅ Réponse du backend:', response.data);
      setStatus(response.data);
      setLoading(false);
    } catch (err) {
      console.error('❌ Erreur de connexion:', err);
      setError(err.message);
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-100 flex items-center justify-center p-4">
      <div className="bg-white rounded-lg shadow-xl p-8 max-w-2xl w-full">
        <h1 className="text-3xl font-bold text-gray-800 mb-6">
          🔗 Test de connexion Frontend ↔ Backend
        </h1>

        {/* Statut du chargement */}
        {loading && (
          <div className="flex items-center justify-center py-8">
            <svg className="animate-spin h-10 w-10 text-primary-600" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
            </svg>
            <span className="ml-3 text-gray-600">Test en cours...</span>
          </div>
        )}

        {/* Affichage de l'erreur */}
        {error && (
          <div className="bg-red-50 border border-red-300 rounded-lg p-4 mb-4">
            <div className="flex items-start">
              <svg className="w-6 h-6 text-red-600 mr-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
              </svg>
              <div>
                <h3 className="text-red-800 font-semibold mb-1">❌ Échec de la connexion</h3>
                <p className="text-red-700 text-sm">{error}</p>
                <div className="mt-3 text-sm text-red-600">
                  <p className="font-semibold mb-1">Vérifiez que :</p>
                  <ul className="list-disc list-inside space-y-1 ml-2">
                    <li>Le backend est démarré sur le port 3000</li>
                    <li>MongoDB est en cours d'exécution</li>
                    <li>CORS est configuré dans App.js</li>
                    <li>La route /status existe</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Affichage du succès */}
        {status && !loading && (
          <div className="bg-green-50 border border-green-300 rounded-lg p-4 mb-4">
            <div className="flex items-start">
              <svg className="w-6 h-6 text-green-600 mr-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
              </svg>
              <div className="flex-1">
                <h3 className="text-green-800 font-semibold mb-2">✅ Connexion réussie !</h3>
                <div className="bg-white rounded border border-green-200 p-4">
                  <p className="text-sm text-gray-600 mb-2 font-semibold">Réponse du serveur :</p>
                  <pre className="text-xs bg-gray-50 p-3 rounded overflow-x-auto">
                    {JSON.stringify(status, null, 2)}
                  </pre>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Informations de configuration */}
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
          <h3 className="text-blue-800 font-semibold mb-2">ℹ️ Configuration</h3>
          <div className="text-sm text-blue-700 space-y-1">
            <p><span className="font-semibold">URL Backend:</span> http://localhost:3000</p>
            <p><span className="font-semibold">URL Frontend:</span> http://localhost:5173</p>
            <p><span className="font-semibold">Route testée:</span> /status</p>
          </div>
        </div>

        {/* Bouton pour retester */}
        <button
          onClick={testConnection}
          disabled={loading}
          className="w-full bg-primary-600 hover:bg-primary-700 text-white font-semibold py-3 px-6 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? 'Test en cours...' : '🔄 Retester la connexion'}
        </button>

        {/* Instructions */}
        <div className="mt-6 pt-6 border-t border-gray-200">
          <h4 className="font-semibold text-gray-800 mb-2">📝 Comment lancer les serveurs :</h4>
          <div className="space-y-3 text-sm text-gray-600">
            <div>
              <p className="font-semibold text-gray-700">Backend (Terminal 1) :</p>
              <code className="block bg-gray-100 p-2 rounded mt-1">
                cd backend && node App.js
              </code>
            </div>
            <div>
              <p className="font-semibold text-gray-700">Frontend (Terminal 2) :</p>
              <code className="block bg-gray-100 p-2 rounded mt-1">
                cd frontend && npm run dev
              </code>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TestConnection;
</file>

<file path="sigl_frontend/src/main.jsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './styles/index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="sigl_frontend/src/pages/HomePage.jsx">
import React from 'react';
import LoginForm from '../components/LoginForm';

const HomePage = () => {
  return (
    <div className="min-h-screen flex">
      {/* Section gauche - Formulaire de connexion */}
      <div className="w-full lg:w-1/2 flex items-center justify-center p-8 bg-white">
        <div className="w-full max-w-md">
          {/* Logo et titre */}
          <div className="mb-8">
            <div className="flex items-center space-x-3 mb-6">
              <div className="w-12 h-12 bg-primary-600 rounded-xl flex items-center justify-center">
                <span className="text-white font-bold text-2xl">I</span>
              </div>
              <h1 className="text-3xl font-bold text-gray-800">IZIA</h1>
            </div>
            <h2 className="text-2xl font-semibold text-gray-800 mb-2">
              Bienvenue sur votre plateforme
            </h2>
            <p className="text-gray-600">
              Connectez-vous pour accéder à votre espace étudiant
            </p>
          </div>

          {/* Formulaire */}
          <LoginForm />

          {/* Informations supplémentaires */}
          <div className="mt-8 pt-6 border-t border-gray-200">
            <p className="text-sm text-gray-600 text-center">
              Besoin d'aide ? Contactez le support à{' '}
              <a href="mailto:support@izia.fr" className="text-primary-600 hover:underline">
                support@izia.fr
              </a>
            </p>
          </div>
        </div>
      </div>

      {/* Section droite - Image */}
      <div className="hidden lg:flex lg:w-1/2 bg-gradient-to-br from-primary-600 to-primary-800 relative overflow-hidden">
        {/* Image de fond 
        <div className="absolute inset-0">
          <img
            src="public/images/image_accueil.jpg"
            alt="Étudiants IZIA"
            className="w-full h-full object-cover opacity-20"
          />
        </div>
          */}
        {/* Overlay avec contenu */}
        <div className="relative z-10 flex flex-col justify-center items-center p-12 text-white">
          <div className="max-w-lg">
            <h2 className="text-4xl font-bold mb-6">
              Gérez votre parcours d'apprentissage
            </h2>
            <p className="text-xl mb-8 text-blue-100">
              Accédez à tous vos outils en un seul endroit : journaux, entretiens, évaluations et soutenances.
            </p>

            {/* Points clés */}
            <div className="space-y-4">
              <div className="flex items-center space-x-3">
                <div className="flex-shrink-0 w-10 h-10 bg-white bg-opacity-20 rounded-lg flex items-center justify-center">
                  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </div>
                <span className="text-lg">Suivi en temps réel de votre progression</span>
              </div>

              <div className="flex items-center space-x-3">
                <div className="flex-shrink-0 w-10 h-10 bg-white bg-opacity-20 rounded-lg flex items-center justify-center">
                  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                  </svg>
                </div>
                <span className="text-lg">Gestion simplifiée de vos documents</span>
              </div>

              <div className="flex items-center space-x-3">
                <div className="flex-shrink-0 w-10 h-10 bg-white bg-opacity-20 rounded-lg flex items-center justify-center">
                  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                  </svg>
                </div>
                <span className="text-lg">Communication avec vos tuteurs</span>
              </div>
            </div>

            {/* Citation */}
            <div className="mt-12 p-6 bg-white bg-opacity-10 backdrop-blur-sm rounded-xl border border-white border-opacity-20">
              <p className="text-lg italic mb-2">
                "Une plateforme intuitive qui facilite le suivi de mon alternance au quotidien."
              </p>
              <p className="text-sm text-blue-100">
                - Marie D., Étudiante ESEO 2024
              </p>
            </div>
          </div>
        </div>

        {/* Motifs décoratifs */}
        <div className="absolute top-0 right-0 w-64 h-64 bg-white opacity-5 rounded-full -mr-32 -mt-32"></div>
        <div className="absolute bottom-0 left-0 w-96 h-96 bg-white opacity-5 rounded-full -ml-48 -mb-48"></div>
      </div>
    </div>
  );
};

export default HomePage;
</file>

<file path="sigl_frontend/src/pages/RegisterPage.jsx">
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import authService from '../services/authService';

const RegisterPage = () => {
  const navigate = useNavigate();
  
  const [formData, setFormData] = useState({
    // Champs obligatoires
    nom: '',
    prenom: '',
    dateNaissance: '',
    email: '',
    telephone: '',
    password: '',
    confirmPassword: '',
    
    // Champ optionnel
    codePostal: '',
  });

  const [errors, setErrors] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);

  // Validation en temps réel
  const validateField = (name, value) => {
    let error = '';

    switch (name) {
      case 'nom':
      case 'prenom':
        if (!value.trim()) {
          error = 'Ce champ est requis';
        } else if (!/^[a-zA-ZÀ-ÿ\s\-']+$/.test(value)) {
          error = 'Uniquement des lettres, espaces et tirets autorisés';
        } else if (value.length < 2) {
          error = 'Minimum 2 caractères';
        }
        break;

      case 'dateNaissance':
        if (!value) {
          error = 'La date de naissance est requise';
        } else {
          const date = new Date(value);
          const today = new Date();
          const age = today.getFullYear() - date.getFullYear();
          
          if (isNaN(date.getTime())) {
            error = 'Date invalide';
          } else if (age < 16) {
            error = 'Vous devez avoir au moins 16 ans';
          } else if (age > 100) {
            error = 'Date de naissance non valide';
          }
        }
        break;

      case 'telephone':
        if (!value.trim()) {
          error = 'Le numéro de téléphone est requis';
        } else if (!/^0\d{9}$/.test(value)) {
          error = 'Le numéro doit contenir 10 chiffres et commencer par 0';
        }
        break;

      case 'email':
        if (!value.trim()) {
          error = 'L\'email est requis';
        } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
          error = 'Format d\'email invalide (doit contenir @)';
        } else if (!value.endsWith('@eseo.fr')) {
          error = 'L\'email doit se terminer par @eseo.fr';
        }
        break;

      case 'codePostal':
        // Optionnel, mais si rempli doit être valide
        if (value.trim() && !/^\d{5}$/.test(value)) {
          error = 'Le code postal doit contenir exactement 5 chiffres';
        }
        break;

      case 'password':
        if (!value) {
          error = 'Le mot de passe est requis';
        } else if (value.length < 8) {
          error = 'Minimum 8 caractères';
        } else if (!/[A-Z]/.test(value)) {
          error = 'Au moins une majuscule requise';
        } else if (!/[a-z]/.test(value)) {
          error = 'Au moins une minuscule requise';
        } else if (!/[0-9]/.test(value)) {
          error = 'Au moins un chiffre requis';
        } else if (!/[!@#$%^&*]/.test(value)) {
          error = 'Au moins un caractère spécial requis (!@#$%^&*)';
        }
        break;

      case 'confirmPassword':
        if (!value) {
          error = 'Veuillez confirmer votre mot de passe';
        } else if (value !== formData.password) {
          error = 'Les mots de passe ne correspondent pas';
        }
        break;

      default:
        break;
    }

    return error;
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    
    // Formater le téléphone (supprimer tout sauf les chiffres)
    let formattedValue = value;
    if (name === 'telephone') {
      formattedValue = value.replace(/\D/g, '').slice(0, 10);
    }
    
    // Formater le code postal (supprimer tout sauf les chiffres)
    if (name === 'codePostal') {
      formattedValue = value.replace(/\D/g, '').slice(0, 5);
    }
    
    setFormData(prev => ({
      ...prev,
      [name]: formattedValue
    }));

    // Validation en temps réel
    const error = validateField(name, formattedValue);
    setErrors(prev => ({
      ...prev,
      [name]: error
    }));

    // Si on modifie le password, revalider confirmPassword
    if (name === 'password' && formData.confirmPassword) {
      const confirmError = formattedValue !== formData.confirmPassword 
        ? 'Les mots de passe ne correspondent pas' 
        : '';
      setErrors(prev => ({
        ...prev,
        confirmPassword: confirmError
      }));
    }
  };

  const validateForm = () => {
    const newErrors = {};
    
    // Valider uniquement les champs obligatoires et remplis
    const requiredFields = ['nom', 'prenom', 'dateNaissance', 'email', 'telephone', 'password', 'confirmPassword'];
    
    requiredFields.forEach(key => {
      const error = validateField(key, formData[key]);
      if (error) {
        newErrors[key] = error;
      }
    });

    // Valider le code postal s'il est rempli
    if (formData.codePostal) {
      const error = validateField('codePostal', formData.codePostal);
      if (error) newErrors.codePostal = error;
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    setIsLoading(true);

    try {
      // Générer le username à partir du prénom et nom
      const username = `${formData.prenom.toLowerCase()}_${formData.nom.toLowerCase()}`
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '') // Retirer les accents
        .replace(/\s/g, '');

      const userData = {
        username: username,
        email: formData.email,  // Email ESEO
        password: formData.password,
        role: 'APPRENTI',
        firstName: formData.prenom,
        lastName: formData.nom,
        birthDate: formData.dateNaissance,
        phone: formData.telephone,
        postalCode: formData.codePostal || null,
      };

      const response = await authService.register(userData);
      
      console.log('✅ Inscription réussie:', response);
      
      // Redirection vers la page de connexion avec message de succès
      navigate('/', { 
        state: { 
          message: 'Compte créé avec succès ! Vous pouvez maintenant vous connecter.',
          email: formData.email
        } 
      });

    } catch (error) {
      console.error('❌ Erreur d\'inscription:', error);
      
      let errorMessage = 'Une erreur est survenue lors de l\'inscription';
      
      if (error.error) {
        errorMessage = error.error;
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      setErrors({ submit: errorMessage });
    } finally {
      setIsLoading(false);
    }
  };

  // Indicateur de force du mot de passe
  const getPasswordStrength = (password) => {
    let strength = 0;
    if (password.length >= 8) strength++;
    if (/[A-Z]/.test(password)) strength++;
    if (/[a-z]/.test(password)) strength++;
    if (/[0-9]/.test(password)) strength++;
    if (/[!@#$%^&*]/.test(password)) strength++;
    return strength;
  };

  const passwordStrength = getPasswordStrength(formData.password);

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50 flex items-center justify-center p-4 py-12">
      <div className="w-full max-w-3xl">
        {/* Header */}
        <div className="text-center mb-8">
          <div className="flex items-center justify-center space-x-3 mb-4">
            <div className="w-12 h-12 bg-primary-600 rounded-xl flex items-center justify-center">
              <span className="text-white font-bold text-2xl">I</span>
            </div>
            <h1 className="text-3xl font-bold text-gray-800">IZIA</h1>
          </div>
          <h2 className="text-2xl font-semibold text-gray-800 mb-2">
            Créer votre compte
          </h2>
          <p className="text-gray-600">
            Remplissez les informations obligatoires pour vous inscrire
          </p>
        </div>

        {/* Formulaire */}
        <div className="bg-white rounded-xl shadow-lg p-8">
          <form onSubmit={handleSubmit} className="space-y-6">
            
            {/* Section Identité */}
            <div>
              <h3 className="text-lg font-semibold text-gray-800 mb-4 pb-2 border-b border-gray-200">
                📋 Informations personnelles
              </h3>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Nom */}
                <div>
                  <label htmlFor="nom" className="block text-sm font-medium text-gray-700 mb-1">
                    Nom <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="text"
                    id="nom"
                    name="nom"
                    value={formData.nom}
                    onChange={handleChange}
                    className={`input-field ${errors.nom ? 'border-red-500' : ''}`}
                    placeholder="DUPONT"
                    disabled={isLoading}
                  />
                  {errors.nom && (
                    <p className="mt-1 text-xs text-red-600">{errors.nom}</p>
                  )}
                </div>

                {/* Prénom */}
                <div>
                  <label htmlFor="prenom" className="block text-sm font-medium text-gray-700 mb-1">
                    Prénom <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="text"
                    id="prenom"
                    name="prenom"
                    value={formData.prenom}
                    onChange={handleChange}
                    className={`input-field ${errors.prenom ? 'border-red-500' : ''}`}
                    placeholder="Jean"
                    disabled={isLoading}
                  />
                  {errors.prenom && (
                    <p className="mt-1 text-xs text-red-600">{errors.prenom}</p>
                  )}
                </div>

                {/* Date de naissance */}
                <div>
                  <label htmlFor="dateNaissance" className="block text-sm font-medium text-gray-700 mb-1">
                    Date de naissance <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="date"
                    id="dateNaissance"
                    name="dateNaissance"
                    value={formData.dateNaissance}
                    onChange={handleChange}
                    className={`input-field ${errors.dateNaissance ? 'border-red-500' : ''}`}
                    max={new Date().toISOString().split('T')[0]}
                    disabled={isLoading}
                  />
                  {errors.dateNaissance && (
                    <p className="mt-1 text-xs text-red-600">{errors.dateNaissance}</p>
                  )}
                </div>

                {/* Téléphone */}
                <div>
                  <label htmlFor="telephone" className="block text-sm font-medium text-gray-700 mb-1">
                    Numéro de téléphone <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="tel"
                    id="telephone"
                    name="telephone"
                    value={formData.telephone}
                    onChange={handleChange}
                    className={`input-field ${errors.telephone ? 'border-red-500' : ''}`}
                    placeholder="0612345678"
                    maxLength="10"
                    disabled={isLoading}
                  />
                  {errors.telephone && (
                    <p className="mt-1 text-xs text-red-600">{errors.telephone}</p>
                  )}
                  <p className="mt-1 text-xs text-gray-500">10 chiffres, commençant par 0</p>
                </div>
              </div>
            </div>

            {/* Section Contact */}
            <div>
              <h3 className="text-lg font-semibold text-gray-800 mb-4 pb-2 border-b border-gray-200">
                📧 Coordonnées
              </h3>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Email ESEO */}
                <div>
                  <label htmlFor="email" className="block text-sm font-medium text-gray-700 mb-1">
                    Email ESEO <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="email"
                    id="email"
                    name="email"
                    value={formData.email}
                    onChange={handleChange}
                    className={`input-field ${errors.email ? 'border-red-500' : ''}`}
                    placeholder="prenom.nom@eseo.fr"
                    disabled={isLoading}
                  />
                  {errors.email && (
                    <p className="mt-1 text-xs text-red-600">{errors.email}</p>
                  )}
                  <p className="mt-1 text-xs text-gray-500">Doit se terminer par @eseo.fr</p>
                </div>

                {/* Code postal (optionnel) */}
                <div>
                  <label htmlFor="codePostal" className="block text-sm font-medium text-gray-700 mb-1">
                    Code postal <span className="text-gray-400">(optionnel)</span>
                  </label>
                  <input
                    type="text"
                    id="codePostal"
                    name="codePostal"
                    value={formData.codePostal}
                    onChange={handleChange}
                    maxLength="5"
                    className={`input-field ${errors.codePostal ? 'border-red-500' : ''}`}
                    placeholder="49000"
                    disabled={isLoading}
                  />
                  {errors.codePostal && (
                    <p className="mt-1 text-xs text-red-600">{errors.codePostal}</p>
                  )}
                </div>
              </div>
            </div>

            {/* Section Mot de passe */}
            <div>
              <h3 className="text-lg font-semibold text-gray-800 mb-4 pb-2 border-b border-gray-200">
                🔒 Sécurité
              </h3>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Mot de passe */}
                <div>
                  <label htmlFor="password" className="block text-sm font-medium text-gray-700 mb-1">
                    Mot de passe <span className="text-red-500">*</span>
                  </label>
                  <div className="relative">
                    <input
                      type={showPassword ? 'text' : 'password'}
                      id="password"
                      name="password"
                      value={formData.password}
                      onChange={handleChange}
                      className={`input-field pr-10 ${errors.password ? 'border-red-500' : ''}`}
                      placeholder="••••••••"
                      disabled={isLoading}
                    />
                    <button
                      type="button"
                      onClick={() => setShowPassword(!showPassword)}
                      className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600"
                    >
                      {showPassword ? (
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                        </svg>
                      ) : (
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                      )}
                    </button>
                  </div>
                  {errors.password && (
                    <p className="mt-1 text-xs text-red-600">{errors.password}</p>
                  )}
                  
                  {/* Indicateur de force */}
                  {formData.password && (
                    <div className="mt-2">
                      <div className="flex items-center space-x-1">
                        {[...Array(5)].map((_, i) => (
                          <div
                            key={i}
                            className={`h-1 flex-1 rounded ${
                              i < passwordStrength
                                ? passwordStrength < 3
                                  ? 'bg-red-500'
                                  : passwordStrength < 4
                                  ? 'bg-yellow-500'
                                  : 'bg-green-500'
                                : 'bg-gray-200'
                            }`}
                          />
                        ))}
                      </div>
                      <p className="mt-1 text-xs text-gray-500">
                        {passwordStrength < 3 && 'Faible'}
                        {passwordStrength === 3 && 'Moyen'}
                        {passwordStrength === 4 && 'Bon'}
                        {passwordStrength === 5 && 'Excellent'}
                      </p>
                    </div>
                  )}
                  
                  <p className="mt-2 text-xs text-gray-500">
                    • Min. 8 caractères<br/>
                    • 1 majuscule, 1 minuscule<br/>
                    • 1 chiffre, 1 caractère spécial
                  </p>
                </div>

                {/* Confirmation mot de passe */}
                <div>
                  <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700 mb-1">
                    Confirmer le mot de passe <span className="text-red-500">*</span>
                  </label>
                  <div className="relative">
                    <input
                      type={showConfirmPassword ? 'text' : 'password'}
                      id="confirmPassword"
                      name="confirmPassword"
                      value={formData.confirmPassword}
                      onChange={handleChange}
                      className={`input-field pr-10 ${errors.confirmPassword ? 'border-red-500' : ''}`}
                      placeholder="••••••••"
                      disabled={isLoading}
                    />
                    <button
                      type="button"
                      onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                      className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600"
                    >
                      {showConfirmPassword ? (
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                        </svg>
                      ) : (
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                      )}
                    </button>
                  </div>
                  {errors.confirmPassword && (
                    <p className="mt-1 text-xs text-red-600">{errors.confirmPassword}</p>
                  )}
                  {formData.confirmPassword && !errors.confirmPassword && (
                    <p className="mt-1 text-xs text-green-600 flex items-center">
                      <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                      </svg>
                      Les mots de passe correspondent
                    </p>
                  )}
                </div>
              </div>
            </div>

            {/* Erreur générale */}
            {errors.submit && (
              <div className="bg-red-50 border border-red-200 rounded-lg p-4">
                <p className="text-sm text-red-800 flex items-center">
                  <svg className="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                  </svg>
                  {errors.submit}
                </p>
              </div>
            )}

            {/* Boutons */}
            <div className="flex items-center justify-between pt-4">
              <Link
                to="/"
                className="text-gray-600 hover:text-gray-800 font-medium flex items-center"
              >
                <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                </svg>
                Retour à la connexion
              </Link>
              
              <button
                type="submit"
                className="btn-primary"
                disabled={isLoading}
              >
                {isLoading ? (
                  <span className="flex items-center">
                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                    </svg>
                    Inscription en cours...
                  </span>
                ) : (
                  'Créer mon compte'
                )}
              </button>
            </div>
          </form>
        </div>

        {/* Légende */}
        <p className="text-center text-sm text-gray-600 mt-6">
          <span className="text-red-500">*</span> Champs obligatoires
        </p>
      </div>
    </div>
  );
};

export default RegisterPage;
</file>

<file path="sigl_frontend/src/services/Api.js">
import axios from 'axios';

// Créer une instance Axios
const api = axios.create({
  baseURL: 'http://localhost:3000/api', // Port 3000 comme dans le backend
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000,
});

// Intercepteur pour ajouter le token JWT
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken'); // Changé de 'token' à 'accessToken'
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Intercepteur pour gérer les erreurs et refresh token
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Si token expiré (401) et pas déjà tenté de refresh
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem('refreshToken');
        
        if (refreshToken) {
          // Appel à la route refresh du backend
          const response = await axios.post(
            'http://localhost:3000/api/auth/refresh',
            {},
            {
              headers: {
                Authorization: `Bearer ${refreshToken}`,
              },
            }
          );

          const { accessToken, refreshToken: newRefreshToken } = response.data.data;

          // Stocker les nouveaux tokens
          localStorage.setItem('accessToken', accessToken);
          localStorage.setItem('refreshToken', newRefreshToken);

          // Réessayer la requête originale avec le nouveau token
          originalRequest.headers.Authorization = `Bearer ${accessToken}`;
          return api(originalRequest);
        }
      } catch (refreshError) {
        // Si refresh échoue, déconnecter l'utilisateur
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        localStorage.removeItem('user');
        window.location.href = '/';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

export default api;
</file>

<file path="sigl_frontend/src/services/authService.js">
import api from './api';
import axios from 'axios';

const API_URL = 'http://localhost:3000/api';

const authService = {
  // Inscription
  register: async (userData) => {
    try {
      const response = await axios.post(`${API_URL}/users/register`, userData);
      return response.data;
    } catch (error) {
      throw error.response?.data || { error: 'Erreur lors de l\'inscription' };
    }
  },

  // Connexion
  login: async (email, password) => {
    try {
      const response = await axios.post(`${API_URL}/auth/login`, {
        email,
        password,
      });

      const { data } = response.data;

      // Stocker les tokens et infos utilisateur
      if (data.tokens) {
        localStorage.setItem('accessToken', data.tokens.accessToken);
        localStorage.setItem('refreshToken', data.tokens.refreshToken);
        localStorage.setItem('user', JSON.stringify(data.user));
      }

      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur de connexion' };
    }
  },

  // Déconnexion
  logout: async () => {
    try {
      const token = localStorage.getItem('accessToken');
      if (token) {
        await axios.post(
          `${API_URL}/auth/logout`,
          {},
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
      }
    } catch (error) {
      console.error('Erreur lors de la déconnexion:', error);
    } finally {
      // Toujours nettoyer le localStorage
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
      window.location.href = '/';
    }
  },

  // Changer le mot de passe
  changePassword: async (currentPassword, newPassword) => {
    try {
      const response = await api.post('/auth/change-password', {
        currentPassword,
        newPassword,
      });
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors du changement de mot de passe' };
    }
  },

  // Demander réinitialisation du mot de passe
  requestPasswordReset: async (email) => {
    try {
      const response = await axios.post(`${API_URL}/auth/request-reset`, {
        email,
      });
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la demande de réinitialisation' };
    }
  },

  // Réinitialiser le mot de passe
  resetPassword: async (token, newPassword) => {
    try {
      const response = await axios.post(`${API_URL}/auth/reset-password`, {
        token,
        newPassword,
      });
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la réinitialisation' };
    }
  },

  // Récupérer l'utilisateur connecté
  getCurrentUser: () => {
    const userStr = localStorage.getItem('user');
    return userStr ? JSON.parse(userStr) : null;
  },

  // Vérifier si l'utilisateur est connecté
  isAuthenticated: () => {
    return !!localStorage.getItem('accessToken');
  },

  // Récupérer le profil utilisateur
  getUserProfile: async (userId) => {
    try {
      const response = await api.get(`/users/${userId}`);
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la récupération du profil' };
    }
  },

  // Mettre à jour le profil
  updateProfile: async (userId, userData) => {
    try {
      const response = await api.put(`/users/${userId}`, userData);
      
      // Mettre à jour le localStorage
      const currentUser = authService.getCurrentUser();
      if (currentUser) {
        const updatedUser = { ...currentUser, ...response.data.user };
        localStorage.setItem('user', JSON.stringify(updatedUser));
      }
      
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Erreur lors de la mise à jour du profil' };
    }
  },
};

export default authService;
</file>

<file path="sigl_frontend/src/services/journalService.js">
// sigl_frontend/src/services/journalService.js
import api from './api';

const journalService = {
  // Récupérer tous les journaux de l'apprenti connecté
  async getMyJournaux() {
    const response = await api.get('/journaux');
    // Le backend renvoie { success, data: [...] }
    return response.data?.data || [];
  },

  // Récupérer un journal par son id
  async getJournalById(id) {
    const response = await api.get(`/journaux/${id}`);
    return response.data?.data || null;
  },

  // Créer un journal pour l'apprenti connecté
  async createJournal(journalPayload) {
    const response = await api.post('/journaux', journalPayload);
    return response.data?.data;
  },
};

export default journalService;
</file>

<file path="sigl_frontend/src/styles/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-50 font-sans antialiased;
  }
}

@layer components {
  .input-field {
    @apply w-full bg-transparent placeholder:text-slate-400 text-slate-700 text-sm border border-slate-300 rounded-md px-4 py-3 transition duration-300 focus:outline-none focus:border-primary-500 focus:ring-2 focus:ring-primary-500 focus:ring-opacity-50 hover:border-slate-400 shadow-sm;
  }
  
  .btn-primary {
    @apply w-full rounded-md bg-primary-600 py-3 px-4 text-center text-sm font-semibold text-white transition-all shadow-md hover:shadow-lg hover:bg-primary-700 focus:bg-primary-700 focus:shadow-none active:bg-primary-800 disabled:pointer-events-none disabled:opacity-50;
  }
}
</file>

<file path="sigl_frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
    "./public/index.html",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          100: '#dbeafe',
          200: '#bfdbfe',
          300: '#93c5fd',
          400: '#60a5fa',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
          800: '#1e40af',
          900: '#1e3a8a',
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path="sigl_frontend/vite.config.js">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    open: true
  }
});
</file>

<file path="README.md">
# SIGL_Project
</file>

<file path="sigl_backend/app/app.js">
// Load environment variables first
require('dotenv').config();

const express = require('express');
const mongoose = require('mongoose');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');
const cors = require('cors');
const journalRoutes = require('./journal/routes');
const app = express();

// Environment validation
const requiredEnvVars = [
    'JWT_SECRET',
    'JWT_REFRESH_SECRET',
    'BCRYPT_SALT_ROUNDS',
    'NODE_ENV',
    'MONGODB_URI'
];

const missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);
if (missingEnvVars.length > 0) {
    console.error('❌ Missing required environment variables:', missingEnvVars.join(', '));
    process.exit(1);
}

// Log startup information (without sensitive data)
console.log('🚀 Starting application...');
console.log(`📦 Environment: ${process.env.NODE_ENV}`);
console.log(`🔌 Port: ${process.env.PORT || 3000}`);

// MongoDB Connection
const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/database';
mongoose.connect(mongoUri)
    .then(() => {
        console.log('✅ MongoDB connection successful');
    })
    .catch((error) => {
        console.error('❌ MongoDB connection error:', error.message);
        process.exit(1);
    });

// Security Middleware - Helmet (must be early in middleware stack)
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    crossOriginEmbedderPolicy: false,
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
}));

// CORS Configuration
app.use(cors({
    origin: process.env.FRONTEND_URL || 'http://localhost:3001',
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
    exposedHeaders: ['X-Total-Count']
}));

// Body parsing middleware with size limits
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Rate Limiting Configuration
const generalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    message: {
        error: 'Too many requests from this IP, please try again later.',
        retryAfter: '15 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
        console.warn(`🚨 Rate limit exceeded for IP: ${req.ip} on ${req.path}`);
        res.status(429).json({
            error: 'Too many requests from this IP, please try again later.',
            retryAfter: '15 minutes'
        });
    }
});

const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // limit each IP to 5 requests per windowMs for auth endpoints
    message: {
        error: 'Too many authentication attempts, please try again later.',
        retryAfter: '15 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
        console.warn(`🚨 Auth rate limit exceeded for IP: ${req.ip} on ${req.path}`);
        res.status(429).json({
            error: 'Too many authentication attempts, please try again later.',
            retryAfter: '15 minutes'
        });
    }
});

// Apply general rate limiting to all requests
app.use(generalLimiter);

// Request Logging
if (process.env.NODE_ENV === 'development') {
    app.use(morgan('dev'));
} else {
    app.use(morgan('combined'));
}

// Import routes
const testRoutes = require('./test/routes');
const userRoutes = require('./user/routes');
const authRoutes = require('./auth/auth.routes');

// Health check route
app.get('/status', (req, res) => {
    res.json({
        status: 'Running',
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV,
        database: mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected',
        uptime: process.uptime()
    });
});

// Routes registration
app.use('/api/test', testRoutes);
app.use('/api/users', userRoutes);
app.use('/api/journaux', journalRoutes);

// Apply stricter rate limiting to auth endpoints
app.use('/api/auth', authLimiter, authRoutes);

// 404 Handler
app.use((req, res) => {
    console.warn(`🔍 404 - Route not found: ${req.method} ${req.path} from IP: ${req.ip}`);
    res.status(404).json({
        error: 'Route not found',
        path: req.path,
        method: req.method
    });
});

// Global Error Handler
app.use((error, req, res, next) => {
    // Log error details for debugging (without sensitive information)
    console.error('🚨 Global Error Handler:', {
        message: error.message,
        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
        path: req.path,
        method: req.method,
        ip: req.ip,
        timestamp: new Date().toISOString()
    });

    // Handle specific error types
    if (error.name === 'ValidationError') {
        return res.status(400).json({
            error: 'Validation Error',
            message: 'Invalid input data',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }

    if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({
            error: 'Authentication Error',
            message: 'Invalid token'
        });
    }

    if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
            error: 'Authentication Error',
            message: 'Token expired'
        });
    }

    if (error.name === 'CastError') {
        return res.status(400).json({
            error: 'Invalid ID',
            message: 'Invalid resource identifier'
        });
    }

    if (error.code === 11000) {
        return res.status(409).json({
            error: 'Duplicate Entry',
            message: 'Resource already exists'
        });
    }

    // Default error response
    const statusCode = error.statusCode || error.status || 500;
    res.status(statusCode).json({
        error: statusCode === 500 ? 'Internal Server Error' : error.message || 'An error occurred',
        message: statusCode === 500 ? 'Something went wrong on our end' : error.message,
        ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
    });
});

// Graceful shutdown handling
const gracefulShutdown = (signal) => {
    console.log(`\n🛑 Received ${signal}. Starting graceful shutdown...`);
    
    // Close MongoDB connection
    mongoose.connection.close(() => {
        console.log('📦 MongoDB connection closed');
    });
    
    // Close server
    server.close(() => {
        console.log('🔌 HTTP server closed');
        console.log('✅ Graceful shutdown completed');
        process.exit(0);
    });
    
    // Force close after 10 seconds
    setTimeout(() => {
        console.error('⚠️  Forced shutdown after timeout');
        process.exit(1);
    }, 10000);
};

// Start server
const PORT = process.env.PORT || 3000;
const server = app.listen(PORT, () => {
    console.log(`🚀 Server running on port ${PORT}`);
    console.log(`🌍 Environment: ${process.env.NODE_ENV}`);
    console.log(`🔒 Security middleware active`);
    console.log(`📊 Rate limiting configured`);
    console.log('✅ Application startup complete');
});

// Register shutdown handlers
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
    console.error('💥 Uncaught Exception:', error);
    gracefulShutdown('UNCAUGHT_EXCEPTION');
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
    console.error('💥 Unhandled Rejection at:', promise, 'reason:', reason);
    gracefulShutdown('UNHANDLED_REJECTION');
});

module.exports = app;
</file>

<file path="sigl_backend/package.json">
{
  "name": "backend",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node app/app.js"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "bcryptjs": "^2.4.3",
    "cookie-parser": "~1.4.4",
    "cors": "^2.8.5",
    "debug": "~2.6.9",
    "dotenv": "^16.6.1",
    "express": "~4.16.1",
    "express-rate-limit": "^7.5.1",
    "file-type": "^21.1.0",
    "helmet": "^7.2.0",
    "http-errors": "~1.6.3",
    "ics": "^3.8.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.0.0",
    "morgan": "~1.9.1",
    "multer": "^2.0.2",
    "pug": "2.0.0-beta11"
  }
}
</file>

<file path="sigl_frontend/src/pages/dashboard/StudentDashboard.jsx">
// sigl_frontend/src/pages/dashboard/StudentDashboard.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import authService from '../../services/authService';
import journalService from '../../services/journalService';

const StudentDashboard = () => {
  const [activeTab, setActiveTab] = useState('journal');
  const navigate = useNavigate();
  const currentUser = authService.getCurrentUser();

  const handleLogout = async () => {
    await authService.logout();
    navigate('/');
  };

  const tabs = [
    { id: 'journal', name: 'Journal de Formation', icon: '📔' },
    { id: 'documents', name: 'Mes Documents', icon: '📄' },
    { id: 'calendar', name: 'Calendrier', icon: '📅' },
    { id: 'entretiens', name: 'Entretiens', icon: '💬' },
    { id: 'notifications', name: 'Notifications', icon: '🔔' },
  ];

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <header className="bg-white shadow-sm border-b border-gray-200">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center space-x-3">
              <div className="w-10 h-10 bg-primary-600 rounded-lg flex items-center justify-center">
                <span className="text-white font-bold text-xl">I</span>
              </div>
              <div>
                <h1 className="text-xl font-bold text-gray-800">IZIA</h1>
                <p className="text-xs text-gray-500">Espace Étudiant</p>
              </div>
            </div>

            {/* User menu */}
            <div className="flex items-center space-x-4">
              <div className="hidden md:flex items-center space-x-2">
                <div className="w-8 h-8 bg-primary-100 rounded-full flex items-center justify-center">
                  <span className="text-primary-600 font-semibold text-sm">
                    {currentUser?.firstName?.[0]}
                    {currentUser?.lastName?.[0]}
                  </span>
                </div>
                <div className="text-sm">
                  <p className="font-medium text-gray-700">
                    {currentUser?.firstName} {currentUser?.lastName}
                  </p>
                  <p className="text-xs text-gray-500">
                    Apprenti - {currentUser?.role || 'APPRENTI'}
                  </p>
                </div>
              </div>
              <button
                onClick={handleLogout}
                className="text-gray-600 hover:text-gray-800 px-3 py-2 rounded-md text-sm font-medium transition"
              >
                Déconnexion
              </button>
            </div>
          </div>
        </div>
      </header>

      {/* Tabs */}
      <div className="bg-white border-b border-gray-200">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <nav className="flex space-x-8 overflow-x-auto" aria-label="Tabs">
            {tabs.map((tab) => (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={`whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors ${
                  activeTab === tab.id
                    ? 'border-primary-600 text-primary-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                }`}
              >
                <span className="mr-2">{tab.icon}</span>
                {tab.name}
              </button>
            ))}
          </nav>
        </div>
      </div>

      {/* Main content */}
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {activeTab === 'journal' && <JournalTab navigate={navigate} />}
        {activeTab === 'documents' && <DocumentsTab />}
        {activeTab === 'calendar' && <CalendarTab />}
        {activeTab === 'entretiens' && <EntretiensTab />}
        {activeTab === 'notifications' && <NotificationsTab />}
      </main>
    </div>
  );
};

// ======================
// Onglet Journal
// ======================
const JournalTab = ({ navigate }) => {
  const [journaux, setJournaux] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchJournaux = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const data = await journalService.getMyJournaux();

        const sorted = [...data].sort(
          (a, b) => new Date(b.createdAt) - new Date(a.createdAt)
        );
        setJournaux(sorted);
      } catch (err) {
        console.error('Erreur lors du chargement des journaux:', err);
        setError("Impossible de charger vos journaux de formation.");
      } finally {
        setIsLoading(false);
      }
    };

    fetchJournaux();
  }, []);

  const formatDate = (dateString) => {
    if (!dateString) return '';
    const d = new Date(dateString);
    if (Number.isNaN(d.getTime())) return dateString;
    return d.toLocaleDateString('fr-FR');
  };

  const formatMonth = (dateString) => {
    if (!dateString) return '';
    const d = new Date(dateString);
    if (Number.isNaN(d.getTime())) return dateString;
    return d.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' });
  };

  const missionsCount = (journal) =>
    journal.periodes?.reduce(
      (sum, p) => sum + (p.missions?.length || 0),
      0
    ) || 0;

  if (isLoading) {
    return <p className="text-gray-600">Chargement des journaux...</p>;
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-xl font-semibold text-gray-900">
            Journal de Formation
          </h2>
          <p className="text-sm text-gray-500">
            Renseignez vos activités mensuelles et consultez l'historique de
            votre formation.
          </p>
        </div>
        <button
          onClick={() => navigate('/journal/create')}
          className="inline-flex items-center px-4 py-2 rounded-md text-sm font-medium bg-primary-600 text-white hover:bg-primary-700"
        >
          + Ajouter une note mensuelle
        </button>
      </div>

      {error && (
        <div className="text-sm text-red-600 bg-red-50 border border-red-200 px-4 py-2 rounded">
          {error}
        </div>
      )}

      {journaux.length > 0 ? (
        <div className="space-y-4">
          <h3 className="text-sm font-medium text-gray-700">
            Notes enregistrées ({journaux.length})
          </h3>

          {journaux.map((journal) => (
            <div
              key={journal.id}
              className="border border-gray-200 rounded-lg p-4 hover:shadow-md transition cursor-pointer"
              onClick={() => navigate(`/journal/${journal.id}`)}
            >
              <div className="flex justify-between items-center">
                <div>
                  <h4 className="font-semibold text-gray-800 capitalize">
                    {formatMonth(journal.createdAt || journal.periodes[0]?.dateDebut)}
                  </h4>
                  <p className="text-sm text-gray-500 mt-1">
                    Dernière modification :{' '}
                    {formatDate(journal.updatedAt || journal.createdAt)}
                  </p>
                  <div className="flex items-center space-x-2 mt-2">
                    <span className="text-xs text-gray-600">
                      📅 {journal.periodes?.length || 0} période(s)
                    </span>
                    <span className="text-xs text-gray-400">•</span>
                    <span className="text-xs text-gray-600">
                      📝 {missionsCount(journal)} mission(s)
                    </span>
                  </div>
                </div>
                <div className="flex items-center space-x-3">
                  <span
                    className={`px-3 py-1 rounded-full text-xs font-medium ${
                      journal.status === 'validee'
                        ? 'bg-green-100 text-green-800'
                        : journal.status === 'en_attente'
                        ? 'bg-yellow-100 text-yellow-800'
                        : 'bg-blue-100 text-blue-800'
                    }`}
                  >
                    {journal.status === 'validee'
                      ? 'Validée'
                      : journal.status === 'en_attente'
                      ? 'En attente'
                      : 'En cours'}
                  </span>
                  <button
                    className="text-primary-600 hover:text-primary-700 font-medium text-sm"
                    onClick={(e) => {
                      e.stopPropagation();
                      navigate(`/journal/${journal.id}`);
                    }}
                  >
                    Consulter →
                  </button>
                </div>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="text-center py-12 bg-gray-50 rounded-lg border-2 border-dashed border-gray-300">
          <div className="text-6xl mb-4">📔</div>
          <h3 className="text-lg font-medium text-gray-800 mb-2">
            Aucune note mensuelle
          </h3>
          <p className="text-sm text-gray-500 mb-4">
            Commencez par créer votre première note de formation.
          </p>
          <button
            onClick={() => navigate('/journal/create')}
            className="inline-flex items-center px-4 py-2 rounded-md text-sm font-medium bg-primary-600 text-white hover:bg-primary-700"
          >
            + Créer ma première note
          </button>
        </div>
      )}
    </div>
  );
};

// Les autres onglets peuvent rester tels que tu les avais
const DocumentsTab = () => (
  <div>
    <h2 className="text-xl font-semibold text-gray-900 mb-4">Mes Documents</h2>
    <p className="text-gray-600 text-sm">
      À implémenter : dépôt et suivi des documents.
    </p>
  </div>
);

const CalendarTab = () => (
  <div>
    <h2 className="text-xl font-semibold text-gray-900 mb-4">Calendrier</h2>
    <p className="text-gray-600 text-sm">
      À implémenter : vue calendrier avec échéances, entretiens, soutenances…
    </p>
  </div>
);

const EntretiensTab = () => (
  <div>
    <h2 className="text-xl font-semibold text-gray-900 mb-4">Entretiens</h2>
    <p className="text-gray-600 text-sm">
      À implémenter : liste et compte-rendus d’entretiens.
    </p>
  </div>
);

const NotificationsTab = () => (
  <div>
    <h2 className="text-xl font-semibold text-gray-900 mb-4">Notifications</h2>
    <p className="text-gray-600 text-sm">
      À implémenter : notifications importantes pour votre suivi.
    </p>
  </div>
);

export default StudentDashboard;
</file>

<file path="sigl_frontend/src/pages/journal/CreateJournalPage.jsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import journalService from '../../services/journalService';

const CreateJournalPage = () => {
  const navigate = useNavigate();

  const [periodes, setPeriodes] = useState([
    {
      id: 1,
      titre: '',
      dateDebut: '',
      dateFin: '',
      missions: [
        {
          id: 1,
          titre: '',
          description: '',
          competences: '',
        },
      ],
    },
  ]);

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null);

  // ------------ Gestion du formulaire ------------

  const handlePeriodeChange = (periodeIndex, field, value) => {
    setPeriodes((prev) =>
      prev.map((p, index) =>
        index === periodeIndex ? { ...p, [field]: value } : p
      )
    );
  };

  const handleMissionChange = (periodeIndex, missionIndex, field, value) => {
    setPeriodes((prev) =>
      prev.map((p, pIndex) => {
        if (pIndex !== periodeIndex) return p;
        return {
          ...p,
          missions: p.missions.map((m, mIndex) =>
            mIndex === missionIndex ? { ...m, [field]: value } : m
          ),
        };
      })
    );
  };

  const addPeriode = () => {
    setPeriodes((prev) => [
      ...prev,
      {
        id: prev.length + 1,
        titre: '',
        dateDebut: '',
        dateFin: '',
        missions: [
          {
            id: 1,
            titre: '',
            description: '',
            competences: '',
          },
        ],
      },
    ]);
  };

  const addMission = (periodeIndex) => {
    setPeriodes((prev) =>
      prev.map((p, index) => {
        if (index !== periodeIndex) return p;
        return {
          ...p,
          missions: [
            ...p.missions,
            {
              id: p.missions.length + 1,
              titre: '',
              description: '',
              competences: '',
            },
          ],
        };
      })
    );
  };

  // Nettoyage des périodes/missions vides
  const sanitizePeriodes = (rawPeriodes) => {
    return rawPeriodes
      .map((p) => {
        const cleanMissions = (p.missions || []).filter((m) => {
          const titre = (m.titre || '').trim();
          const desc = (m.description || '').trim();
          const comp = (m.competences || '').trim();
          return titre || desc || comp;
        });

        return {
          ...p,
          missions: cleanMissions,
        };
      })
      .filter((p) => {
        const hasTitre = (p.titre || '').trim();
        const hasDates = p.dateDebut || p.dateFin;
        const hasMissions = (p.missions || []).length > 0;
        return hasTitre || hasDates || hasMissions;
      });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setIsSubmitting(true);

    try {
      const cleanedPeriodes = sanitizePeriodes(periodes);

      if (!cleanedPeriodes.length) {
        setError(
          'Veuillez renseigner au moins une période ou une mission avant de sauvegarder.'
        );
        setIsSubmitting(false);
        return;
      }

      const payload = {
        periodes: cleanedPeriodes,
        status: 'EN_COURS',
        createdAt: new Date().toISOString(),
      };

      await journalService.createJournal(payload);

      navigate('/dashboard?tab=journal');
    } catch (err) {
      console.error(err);
      setError("Erreur lors de l'enregistrement du journal.");
    } finally {
      setIsSubmitting(false);
    }
  };

  // ------------ Rendu ------------

  return (
    <div className="max-w-5xl mx-auto px-4 py-8">
      <h1 className="text-2xl font-semibold mb-6">Créer une note mensuelle</h1>

      {error && (
        <div className="mb-4 text-red-600 text-sm bg-red-50 border border-red-200 px-4 py-2 rounded">
          {error}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-8">
        {periodes.map((periode, pIndex) => (
          <div
            key={periode.id}
            className="bg-white rounded-lg shadow border border-gray-200 p-6 space-y-4"
          >
            <div className="flex justify-between items-center">
              <h2 className="text-lg font-semibold text-gray-800">
                Période {pIndex + 1}
              </h2>
              <span className="text-xs text-gray-500">
                {periode.dateDebut && periode.dateFin
                  ? `${periode.dateDebut} → ${periode.dateFin}`
                  : 'Dates non renseignées'}
              </span>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="md:col-span-1">
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Intitulé de la période
                </label>
                <input
                  type="text"
                  className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                  placeholder="Ex : Missions de novembre"
                  value={periode.titre}
                  onChange={(e) =>
                    handlePeriodeChange(pIndex, 'titre', e.target.value)
                  }
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Date de début
                </label>
                <input
                  type="date"
                  className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                  value={periode.dateDebut}
                  onChange={(e) =>
                    handlePeriodeChange(pIndex, 'dateDebut', e.target.value)
                  }
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Date de fin
                </label>
                <input
                  type="date"
                  className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                  value={periode.dateFin}
                  onChange={(e) =>
                    handlePeriodeChange(pIndex, 'dateFin', e.target.value)
                  }
                />
              </div>
            </div>

            <div className="space-y-3 mt-4">
              <h3 className="text-sm font-semibold text-gray-700">
                Missions / activités ({periode.missions.length})
              </h3>

              {periode.missions.map((mission, mIndex) => (
                <div
                  key={mission.id}
                  className="border border-gray-200 rounded-md p-4 bg-gray-50 space-y-3"
                >
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="block text-xs font-medium text-gray-600 mb-1">
                        Titre de la mission
                      </label>
                      <input
                        type="text"
                        className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                        placeholder="Ex : Développement d'une nouvelle fonctionnalité"
                        value={mission.titre}
                        onChange={(e) =>
                          handleMissionChange(
                            pIndex,
                            mIndex,
                            'titre',
                            e.target.value
                          )
                        }
                      />
                    </div>
                    <div>
                      <label className="block text-xs font-medium text-gray-600 mb-1">
                        Compétences mobilisées
                      </label>
                      <input
                        type="text"
                        className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                        placeholder="Ex : C#, travail en équipe..."
                        value={mission.competences}
                        onChange={(e) =>
                          handleMissionChange(
                            pIndex,
                            mIndex,
                            'competences',
                            e.target.value
                          )
                        }
                      />
                    </div>
                  </div>
                  <div>
                    <label className="block text-xs font-medium text-gray-600 mb-1">
                      Description de la mission
                    </label>
                    <textarea
                      className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary-500"
                      rows={3}
                      placeholder="Décrivez ce que vous avez réalisé, les outils utilisés, les résultats..."
                      value={mission.description}
                      onChange={(e) =>
                        handleMissionChange(
                          pIndex,
                          mIndex,
                          'description',
                          e.target.value
                        )
                      }
                    />
                  </div>
                </div>
              ))}

              <button
                type="button"
                onClick={() => addMission(pIndex)}
                className="inline-flex items-center px-3 py-1.5 rounded-md text-xs font-medium bg-primary-50 text-primary-700 hover:bg-primary-100"
              >
                + Ajouter une mission
              </button>
            </div>
          </div>
        ))}

        <div className="flex items-center justify-between">
          <button
            type="button"
            onClick={addPeriode}
            className="inline-flex items-center px-4 py-2 rounded-md text-sm font-medium bg-gray-100 text-gray-700 hover:bg-gray-200"
          >
            + Ajouter une période
          </button>

          <button
            type="submit"
            disabled={isSubmitting}
            className="inline-flex items-center px-6 py-3 rounded-lg text-sm font-medium bg-primary-600 text-white hover:bg-primary-700 disabled:opacity-60"
          >
            {isSubmitting ? 'Enregistrement...' : 'Enregistrer le journal'}
          </button>
        </div>
      </form>
    </div>
  );
};

export default CreateJournalPage;
</file>

</files>
